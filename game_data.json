{"name": "Modern Mathematics with Lean", "version": "0.12", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Modern Mathematics with Lean-0.12-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "text", "content": "5"}, {"type": "tactic", "content": "6", "name": "from", "sideBar": true}, {"type": "tactic", "content": "7", "name": "exact", "sideBar": true}, {"type": "axiom", "content": "8", "name": "rfl {a : \u03b1} :", "sideBar": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": true}, {"type": "lean", "content": "11", "hidden": true}, {"type": "lean", "content": "12", "hidden": false}, {"type": "theorem", "text": "13", "lean": "theorem x_plus_y_eq_x_plus_y : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 75, "lastProofLineNumber": 78, "textBefore": "import mynat.basic -- hide\n\n/-\n# Equations\n\n## Level 1: Proving equations through reflexivity\n\nThe `rfl` principle (short for reflexivity) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are natural numbers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2115\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2115` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare natural numbers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `from rfl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n\nIn `from rfl`, the word `from` is a *tactic*. This tactic takes a proof term and closes a goal\nif the provided proof term exactly matches the target. The list of tactics you've seen so far\nis presented in the left-hand pane.\n-/\n\n/-\n## Translation to a hand-written proof\n\nIn words, the `from rfl` says, \"The result holds from reflexivity\".\n\n-/\n\n/- Tactic : from\nIf `h` is a hypothesis or proof term that matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n-/\n\n/- Tactic : exact\nIf `h` is a hypothesis or proof term that matches the target, then `exact h` will close the goal.\n-/\n\n/- Axiom : rfl {a : \u03b1} :\na = a\n-/\n\nnamespace exlean -- hide\n\nopen mynat -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2115) -- Declare `x` and `y` to be natural numbers.\n\n/- Theorem : no-side-bar\n$x + y = x + y$, for all natural numbers $x$ and $y$.\n-/\ntheorem x_plus_y_eq_x_plus_y : x + y = x + y :=\nbegin\n", "proof": "  from rfl,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 74, "name": "x_plus_y_eq_x_plus_y", "statement": "x + y = x + y"}, {"type": "lean", "content": "14", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "15", "hidden": true}, {"type": "text", "content": "16"}, {"type": "tactic", "content": "17", "name": "apply", "sideBar": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "axiom", "content": "21", "name": "add_comm (a b : \u2115) :", "sideBar": true}, {"type": "lean", "content": "22", "hidden": true}, {"type": "theorem", "text": "23", "lean": "theorem add_3_eq_3_add : x + 3 = 3 + x :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import mynat.add_mul_lemmas  -- hide\n\n/-\n# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, than `x + 3 = 3 + x`.\nTry `from rfl,` below (remember to put a comma after `rfl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + 3 = 3 + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `rfl` to prove `x + 3 = 3 + x`, but it expects a target\nof the form `?m_2 = ?m_2`.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are natural numbers.\n\nTo apply this theorem, we'll use the `from` tactic.\n\nReplace the `sorry` below with `from add_comm x 3` (followed by a comma\u2014I won't mention this from now\non).\n\nAlternatively, write `apply add_comm`. The `apply` tactic automatically fills in the missing\narguments to `add_comm`.\n-/\n\n/- Tactic : apply\n`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (x y : \u2115) -- hide\n\n/- Axiom : add_comm (a b : \u2115) :\na + b = b + a\n-/\ntheorem add_comm (a b : \u2115) : a + b = b + a := mynat.add_comm' a b -- hide\n\n/- Theorem : no-side-bar\n$x + 3 = 3 + x$, for all natural numbers $x$.\n-/\ntheorem add_3_eq_3_add : x + 3 = 3 + x :=\nbegin\n", "proof": "  apply add_comm,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n\n/-\n## Translation to a hand-written proof\n\nIn words, `from add_comm x 3` says, \"The result follows from additive commutativity applied\nto $x$ and $3$.\"\n\nLikewise, `apply add_comm` says, \"The result follows by applying additive commutativity\".\n-/\n\n/-\n## Anatomy of a level\n\nEach level contains three vertical panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n-/", "height": 3, "editorText": "sorry", "lineOffset": 58, "name": "add_3_eq_3_add", "statement": "x + 3 = 3 + x"}, {"type": "lean", "content": "24", "hidden": true}, {"type": "text", "content": "25"}, {"type": "text", "content": "26"}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "text", "content": "28"}, {"type": "tactic", "content": "29", "name": "have", "sideBar": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "lean", "content": "34", "hidden": false}, {"type": "text", "content": "35"}, {"type": "text", "content": "36"}, {"type": "tactic", "content": "37", "name": "show", "sideBar": true}, {"type": "lean", "content": "38", "hidden": false}, {"type": "text", "content": "39"}, {"type": "text", "content": "40"}, {"type": "theorem", "text": "41", "lean": "theorem bc_add_comm : b + c = c + b :=\n", "sideBar": false, "firstProofLineNumber": 86, "firstProofHintLineNumber": 89, "lastProofHintLineNumber": 90, "lastProofLineNumber": 93, "textBefore": "import equations.add_comm -- hide\n\n/-\n# Equations\n\n## Level 3: `have` and `show`\n\nThe `have` tactic enables you to structure your proofs by adding intermediate results into the\ncontext. The `show` tactic helps your reader understand what you are proving.\n\n-/\n\n/- Tactic : have\n`have` is used to introduce a hypothesis into the context. For example,\n`have h : x + y = x + y, from rfl,` introduces the hypothesis `h : x + y = x + y` into the context.\n`have` requires a tactic proof of the claimed result. Here, `from rfl` is a tactic proof of `x + y = x + y`.\n\nMore generally, `have h : \u03b1, T` introduces `h : \u03b1` into the context if `T` is a tactic proof of `\u03b1`.\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (a b c : \u2115) -- hide\n\n/-\nIn the example below, the first line adds `h : a + b = b + a` into the context. Here,\n`apply add_comm` gives a proof of `a + b = b + a`. The second lines uses this intermediate result\nto close the goal. In this simple example `have` is not necessary as the proof can be done in one\nline with `apply add_comm`.\n-/\n\n\nexample : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  from h,\nend\n\n/-\n## Translation to a hand-written proof\n\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> The result follows from $h$.\n-/\n\n\n/-\nChanging the last line of the Lean proof above, we indicate what is being proved with the `show` tactic.\n-/\n\n/- Tactic : show\n`show` is used to state what is being proved. If, for example, the target is to prove `x + y = x + y`,\nyou can indicate and prove this using `show x + y = x + y, from rfl`.\n\nMore generally, if the target is to prove `\u03b1`, you can close the goal using `show \u03b1, T` where `T` is a tactic proof of `\u03b1`.\n-/\n\n\nexample : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  show a + b = b + a, from h,\nend\n\n/-\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> We show $a + b = b + a$ from $h$.\n-/\n\n\n/-\n## Task\nReplace the underscores `_` below with statements and the `sorry` with a proof.\n-/\n\n\n/- Theorem : no-side-bar\n$b + c = c + b$, for all natural numbers $b$ and $c$.\n-/\ntheorem bc_add_comm : b + c = c + b :=\nbegin\n", "proof": "  have h : b + c = c + b, apply add_comm,\n  show b + c = c + b, from h,\n/- hint\nhave h : _, sorry,\nshow _, from h,\n-/\n\n", "proof_hint": "have h : _, sorry,\nshow _, from h,", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 8, "editorText": "have h : _, sorry,\nshow _, from h,", "lineOffset": 85, "name": "bc_add_comm", "statement": "b + c = c + b"}, {"type": "lean", "content": "42", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "lean", "content": "47", "hidden": true}, {"type": "axiom", "content": "48", "name": "eq.sub (P : T \u2192 Prop) (h : a = b) (ha : P a) :", "sideBar": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "text", "content": "50"}, {"type": "axiom", "content": "51", "name": "add_comm_congr_left (s t u : \u2115) :", "sideBar": true}, {"type": "lean", "content": "52", "hidden": false}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": false}, {"type": "text", "content": "55"}, {"type": "lean", "content": "56", "hidden": false}, {"type": "text", "content": "57"}, {"type": "hint", "content": "58", "title": "59"}, {"type": "theorem", "text": "60", "lean": "theorem add_comm_congr_right : (s + t) + u  = (t + s) + u :=\n", "sideBar": true, "firstProofLineNumber": 96, "firstProofHintLineNumber": 101, "lastProofHintLineNumber": 104, "lastProofLineNumber": 107, "textBefore": "import equations.add_comm -- hide\n\n/-\n# Equations\n\n## Level 4: Substitution\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n\n/- Axiom : eq.sub (P : T \u2192 Prop) (h : a = b) (ha : P a) :\nP b\n-/\n-- begin hide\n@[elab_as_eliminator]\ndef eq.sub {T} {a b : T} (P : T -> Prop) (h : a = b) (ha : P a) := @eq.rec T a P ha b h\n-- end hide\n\n\n/-\nIf you know `h\u2081 : a = b` and you know `h\u2082 : P(a)`, where `P(a)` is some statement involving `a`,\nthen you know `P(b)`. This principle is called *substitution*. In Lean, `eq.sub P h\u2081 h\u2082` is a\nproof of `P(b)`.\n\nA statement that depends on a variable (or on zero or more variables) is called a *predicate*. Thus,\n`P` above is a predicate.\n\nWe use the substitution principle to prove $s + (t + u) = s + (u + t)$. Let $P(x)$ be the statement\n$s + (t + u) = s + x$. We have $h_1 : t + u = u + t$, by commutativity of addition.\nWe have $h_2 : P (t + u)$ (that is $s + (t + u) = s + (t + u)$), from reflexivity.\n\nThus, the result (which is $P(u + t)$) follows by substituting $h_1$ into $h_2$.\n\nThis proof is written in Lean as follows.\n-/\n\n/- Axiom : add_comm_congr_left (s t u : \u2115) :\ns + (t + u) = s + (u + t)\n-/\n\ntheorem add_comm_congr_left : s + (t + u) = s + (u + t) :=\nbegin\n  let P : \u2115 \u2192 Prop := \u03bb x, s + (t + u) = s + x,\n  have h\u2081 : t + u = u + t, apply add_comm,\n  have h\u2082 : P(t + u), from rfl,\n  show P(u + t), from eq.sub P h\u2081 h\u2082,\nend\n\n/-\nIn the proof below, we don't give $P$ explicitly. By using the underscore `_` as an argument to\n`eq.sub`, we ask Lean to infer the correct predicate `P`.\n-/\n\nexample : s + (t + u) = s + (u + t) :=\nbegin\n  have h\u2081 : t + u = u + t, from add_comm t u,\n  have h\u2082 : s + (t + u) = s + (t + u), from rfl,\n  show s + (t + u) = s + (u + t) , from eq.sub _ h\u2081 h\u2082,\nend\n\n/-\nFinally, we can give a very terse proof of the result.\n-/\n\nexample : s + (t + u) = s + (u + t) :=\nbegin\n  from eq.sub _ (add_comm t u) rfl,\nend\n\n/-\n## Task \n\nComplete the proof below, adapting the proof above. Replace each underscore `_` with a statement\nand each `sorry` with a proof.\n\nHere, `\u2115`, the type of natural numbers, is written `\\N` while `\u03bb` is typed `\\lam`.\n-/\n\n/- Hint : Avoiding the predicate\nIf you're struggling to determine the predicate `P`, delete the `let` line, replace `h\u2082 : P(s + t)`\nwith `h\u2082 : (s + t) + u = (s + t) + u`, and replace `eq.sub P h\u2081 h\u2082` with `eq.sub _ h\u2081 h\u2082`.\n-/\n\n\n/- Theorem : \n$(s + t) + u = (t + s) + u$, for all natural numbers $s$, $t$, $u$.\n-/\ntheorem add_comm_congr_right : (s + t) + u  = (t + s) + u :=\nbegin\n", "proof": "  let P : \u2115 \u2192 Prop := \u03bb x, (s + t) + u = x + u,\n  have h\u2081 : s + t = t + s, from add_comm s t,\n  have h\u2082 : P(s + t), from rfl,\n  show (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,\n/- hint\nlet P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,\n-/\n\n", "proof_hint": "let P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 12, "editorText": "let P : \u2115 \u2192 Prop := \u03bb x, _,\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : P(s + t), from sorry,\nshow (s + t) + u  = (t + s) + u, from eq.sub P h\u2081 h\u2082,", "lineOffset": 95, "name": "add_comm_congr_right", "statement": "(s + t) + u  = (t + s) + u"}, {"type": "lean", "content": "61", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "62", "hidden": true}, {"type": "text", "content": "63"}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "text", "content": "67"}, {"type": "hint", "content": "68", "title": "69"}, {"type": "hint", "content": "70", "title": "71"}, {"type": "theorem", "text": "72", "lean": "theorem add_comm_left_right : (s + t) + u  = u + (t + s) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 45, "textBefore": "import equations.substitution -- hide\n\n/-\n# Equations\n\n## Level 5: Substitution 2\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n/-\n## Task \n\nComplete the proof below. Get hints if needed by clicking on the drop-down menus below.\nIf you want to start with an explicit predicate, the first line should be\n```let P : \u2115 \u2192 Prop := \u03bb x, _,```\nwhere you should replace `_` with a statement depending on `x`.\n-/\n\n/- Hint: Structure of the proof\nYou can do this with (no more than) two `have`s and an application of substitution.\n-/\n\n/- Hint: A useful result\nThe result proved in the previous level will come in handy.\n-/\n\n\n/- Theorem : no-side-bar\n$(s + t) + u  = u + (t + s)$, for all natural numbers $s$, $t$, and $u$.\n-/\ntheorem add_comm_left_right : (s + t) + u  = u + (t + s) :=\nbegin\n", "proof": "  let P : \u2115 \u2192 Prop := \u03bb x, (s + t) + u = x,\n  have h\u2081 : (t + s) + u = u + (t + s), apply add_comm,\n  have h\u2082 : P((t + s) + u), apply add_comm_congr_right,\n  from eq.sub P h\u2081 h\u2082,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "sorry", "lineOffset": 38, "name": "add_comm_left_right", "statement": "(s + t) + u  = u + (t + s)"}, {"type": "lean", "content": "73", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "lean", "content": "76", "hidden": true}, {"type": "lean", "content": "77", "hidden": true}, {"type": "lean", "content": "78", "hidden": true}, {"type": "axiom", "content": "79", "name": "congr_arg (f : \u03b1 \u2192 \u03b2) (h : a\u2081 = a\u2082) :", "sideBar": true}, {"type": "text", "content": "80"}, {"type": "lean", "content": "81", "hidden": false}, {"type": "text", "content": "82"}, {"type": "text", "content": "83"}, {"type": "theorem", "text": "84", "lean": "theorem congr_intro : (s + (t + u)) * t = (s + (u + t)) * t :=\n", "sideBar": false, "firstProofLineNumber": 58, "firstProofHintLineNumber": 62, "lastProofHintLineNumber": 63, "lastProofLineNumber": 64, "textBefore": "import equations.substitution2 -- hide\n\n/-\n# Equations\n\n## Level 6: Congruence of arguments\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nvariables (s t u : \u2115) -- hide\n\n/- Axiom :  congr_arg (f : \u03b1 \u2192 \u03b2) (h : a\u2081 = a\u2082) :\nf a\u2081 = f a\u2082\n-/\n\n/-\nLet `f` be a function. Suppose `h : a = b`. Then `congr_arg f h` gives a proof of `f(a) = f (b)`.\nThis is called congruence of arguments.\n\nIn the example below, $f$ is the function from $\\mathbb N$ to $\\mathbb N$ given by $f(x) := 5 x$.\nThe term $h$ is a proof of $t + u = u + t$. Thus, `congr_arg f h` is a proof that\n$5(t + u) = 5(u + t)$.\n-/\n\nexample : 5 * (t + u) = 5 * (u + t) :=\nbegin\n  let f : \u2115 \u2192 \u2115 := \u03bb x, 5 * x,\n  have h : t + u = u + t, apply add_comm,\n  show 5 * (t + u) = 5 * (u + t), from congr_arg f h,\nend\n\n/-\n## Translation to a hand-written proof\n\nThe proof above can be written by hand as follows.\n> Let $f : \\mathbb N \\to \\mathbb N$ be the function $f(x) := 5 x$.\n> We have $h : t + u = u + t$ by commutativity of addition.\n> The result follows by congruence of arguments with $f$ and $h$.\n-/\n\n/-\n## Task \n\nComplete the proof below, adapting the proof above.\n-/\n\n\n/- Theorem : no-side-bar\n$(s + (t + u))  t = (s + (u + t))  t$, for all natural numbers\n$s$, $t$, $u$.\n-/\ntheorem congr_intro : (s + (t + u)) * t = (s + (u + t)) * t :=\nbegin\n", "proof": "  let f : \u2115 \u2192 \u2115 := \u03bb x, (s + x) * t,\n  have h : t + u = u + t, apply add_comm,\n  from congr_arg f h,\n/- hint\nlet f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,\n-/", "proof_hint": "let f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "let f : \u2115 \u2192 \u2115 := \u03bb x, sorry,\nsorry,", "lineOffset": 57, "name": "congr_intro", "statement": "(s + (t + u)) * t = (s + (u + t)) * t"}, {"type": "lean", "content": "85", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "text", "content": "87"}, {"type": "lean", "content": "88", "hidden": true}, {"type": "text", "content": "89"}, {"type": "lean", "content": "90", "hidden": true}, {"type": "lean", "content": "91", "hidden": true}, {"type": "theorem", "text": "92", "lean": "theorem congr_arg (f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b) :=\n", "sideBar": false, "firstProofLineNumber": 31, "firstProofHintLineNumber": 35, "lastProofHintLineNumber": 37, "lastProofLineNumber": 40, "textBefore": "import equations.congruence -- hide\n\n/-\n# Equations\n\n## Level 7: Congruence of arguments - proof\n-/\n\n\nnamespace exlean -- hide\n\n\n/-\n## Task \n\nYou've used the `congr_arg` theorem. In this level, you'll *prove* it. Naturally, I've disabled\nthe ordinary `congr_arg` theorem so you can't cheat!\n-/\n\nnamespace hidden -- hide\n\nvariables {\u03b1 : Type*} {\u03b2 : Type*} {a b : \u03b1} -- hide\n\n/- Theorem : no-side-bar\nLet $f$ be a function from a type $\\alpha$ to a type $\\beta$. \nLet $a$ and $b$ be terms of type $\\alpha$ and suppose $h : a = b$.\nThen $f(a) = f(b)$. \n-/\ntheorem congr_arg (f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b) :=\nbegin\n", "proof": "  let P : \u03b1 \u2192 Prop := \u03bb x, f(a) = f(x),\n  have h\u2082 : P(a), from rfl,\n  from eq.sub P h h\u2082,\n/- hint\nlet P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,\n-/\n\n", "proof_hint": "let P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,", "textAfter": "\nend\n\nend hidden -- hide\n\nend exlean -- hide\n\n\n", "height": 10, "editorText": "let P : \u03b1 \u2192 Prop := \u03bb x, _,\nhave h\u2082 : P(a), from sorry,\nfrom eq.sub P h h\u2082,", "lineOffset": 30, "name": "congr_arg", "statement": "(f : \u03b1 \u2192 \u03b2) (h : a = b) : f(a) = f(b)"}, {"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "lean", "content": "97", "hidden": true}, {"type": "lean", "content": "98", "hidden": true}, {"type": "text", "content": "99"}, {"type": "axiom", "content": "100", "name": "add_assoc (a b c : \u2115) :", "sideBar": true}, {"type": "lean", "content": "101", "hidden": true}, {"type": "lean", "content": "102", "hidden": true}, {"type": "text", "content": "103"}, {"type": "lean", "content": "104", "hidden": false}, {"type": "text", "content": "105"}, {"type": "lean", "content": "106", "hidden": false}, {"type": "lean", "content": "107", "hidden": true}, {"type": "theorem", "text": "108", "lean": "theorem add_assoc_symm : a + (b + c) = (a + b) + c :=\n", "sideBar": true, "firstProofLineNumber": 56, "lastProofLineNumber": 62, "textBefore": "import equations.congruence -- hide\n\n/-\n# Equations\n\n## Level 8: Associativity\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nAdditional of natural numbers satisfy the *associative* property. That is,\nfor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\nIn Lean, `add_assoc` is the name of this theorem. Thus, `add_assoc a b c` is a proof that\n`(a + b) + c = a + (b + c)`.\n-/\n\n/- Axiom : add_assoc (a b c : \u2115) :\n(a + b) + c = a + (b + c)\n-/\ntheorem add_assoc (a b c : \u2115) : (a + b) + c = a + (b + c) := mynat.add_assoc' a b c -- hide\n\nvariables (s t u v : \u2115) -- hide\n\n/-\nThus, `add_assoc (s + t) u v` is a proof that $((s + t) + u) + v = (s + t) + (u + v)$.\n-/\n\nexample : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  from add_assoc (s + t) u v,\nend\n\n/-\nWe can let Lean do the chore of determining the arguments to `add_assoc` by using the `apply`\ntactic.\n-/\n\n\nexample : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  apply add_assoc,\nend\n\n\nvariables (a b c : \u2115) -- hide\n\n/- Theorem :\n$a + (b + c) = (a + b) + c$, for all natural numbers $a$, $b$, and $c$.\n-/\ntheorem add_assoc_symm : a + (b + c) = (a + b) + c :=\nbegin\n", "proof": "  have h\u2081 : (a + b) + c = a + (b + c), apply add_assoc,\n  have h\u2082 : (a + b) + c = (a + b) + c, from rfl,\n  from eq.sub _ h\u2081 h\u2082\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 7, "editorText": "sorry", "lineOffset": 55, "name": "add_assoc_symm", "statement": "a + (b + c) = (a + b) + c"}, {"type": "lean", "content": "109", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "text", "content": "114"}, {"type": "axiom", "content": "115", "name": "eq.symm (h : a = b) :", "sideBar": true}, {"type": "text", "content": "116"}, {"type": "lean", "content": "117", "hidden": true}, {"type": "lean", "content": "118", "hidden": false}, {"type": "text", "content": "119"}, {"type": "lean", "content": "120", "hidden": false}, {"type": "lean", "content": "121", "hidden": true}, {"type": "text", "content": "122"}, {"type": "theorem", "text": "123", "lean": "theorem add_right_left_comm : s + (t + u) = (t + s) + u :=\n", "sideBar": false, "firstProofLineNumber": 61, "firstProofHintLineNumber": 65, "lastProofHintLineNumber": 67, "lastProofLineNumber": 71, "textBefore": "import equations.associativity -- hide\n\n/- \n# Equations\n\n## Level 9: Symmetry\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThe symmetry property of $=$ states that if $a = b$, then $b = a$. In Lean, if $h : a = b$,\nthen `eq.symm h` is a proof that `b = a`. This can also be written `h.symm`.\n-/\n\n/- Axiom : eq.symm (h : a = b) :\nb = a\n-/\n\n/-\nUsing `eq.symm`, we'll reprove the result from the previous level.\n-/\n\nvariables (a b c : \u2115) -- hide\n\nexample : a + (b + c) = (a + b) + c :=\nbegin\n  have h : (a + b) + c = a + (b + c), apply add_assoc,\n  show a + (b + c) = (a + b) + c, from eq.symm h,\nend\n\n\n/-\nOr, more simply:\n-/\n\nexample : a + (b + c) = (a + b) + c :=\nbegin\n  from (add_assoc a b c).symm\nend\n\n\nvariables (s t u : \u2115) -- hide\n\n/-\n## Task\n\nComplete the proof below, replacing each underscore `_` with a statement and\neach `sorry` with a proof.\n-/\n\n\n/- Theorem : no-side-bar\n$s + (t + u) = (t + s) + u$, for all natural numbers $s$, $t$, and $u$.\n-/\ntheorem add_right_left_comm : s + (t + u) = (t + s) + u :=\nbegin\n", "proof": "  have h\u2081 : s + t = t + s, from add_comm s t,\n  have h\u2082 : s + (t + u) = (s + t) + u, apply add_assoc_symm,\n  show s + (t + u) = (t + s) + u, from eq.sub _ h\u2081 h\u2082,\n/- hint\nhave h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,\n-/\n\n\n", "proof_hint": "have h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 11, "editorText": "have h\u2081 : _, from add_comm s t,\nhave h\u2082 : s + (t + u) = (s + t) + u, sorry,\nshow _, sorry,", "lineOffset": 60, "name": "add_right_left_comm", "statement": "s + (t + u) = (t + s) + u"}, {"type": "lean", "content": "124", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "lean", "content": "127", "hidden": true}, {"type": "lean", "content": "128", "hidden": true}, {"type": "text", "content": "129"}, {"type": "axiom", "content": "130", "name": "eq.trans (h\u2081 : a = b) (h\u2082 : b = c):", "sideBar": true}, {"type": "text", "content": "131"}, {"type": "lean", "content": "132", "hidden": true}, {"type": "lean", "content": "133", "hidden": false}, {"type": "text", "content": "134"}, {"type": "theorem", "text": "135", "lean": "theorem add_right_comm : (x + y) + z = (x + z) + y :=\n", "sideBar": true, "firstProofLineNumber": 50, "firstProofHintLineNumber": 56, "lastProofHintLineNumber": 59, "lastProofLineNumber": 61, "textBefore": "import equations.symmetry -- hide\n\n/- \n# Equations\n\n## Level 10 : Transitivity\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nGiven `h\u2081 : a = b` and `h\u2082 : b = c`, we have `a = c`. This is called *transitivity*. Specifically,\nthe Lean result `eq.trans h\u2081 h\u2082` is a  proof of `a = c`.\n-/\n\n/- Axiom : eq.trans (h\u2081 : a = b) (h\u2082 : b = c):\na = c\n-/\n\n\n/-\nWe'll prove a result using `eq.trans` and two other results we've seen.\n-/\n\nvariables (x y z : \u2115) -- hide\n\nexample : (x + y) + z = x + (z + y) :=\nbegin\n  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  show (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nend\n\n/-\n## Task\n\nComplete the proof below. You may need to replace `sorry` with two lines. The last\nline should invoke `eq.trans`.\n-/\n\n\n/- Theorem :\n$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem add_right_comm : (x + y) + z = (x + z) + y :=\nbegin\n", "proof": "  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  have k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\n  have h\u2083 : x + (z + y) = (x + z) + y, apply add_assoc_symm,\n  from eq.trans k h\u2083,\n/- hint\nhave h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,\n-/\n", "proof_hint": "have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,", "textAfter": "\nend\n\n\n\nend exlean -- hide\n\n\n", "height": 12, "editorText": "have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\nhave h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\nhave k : (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nsorry,", "lineOffset": 49, "name": "add_right_comm", "statement": "(x + y) + z = (x + z) + y"}, {"type": "lean", "content": "136", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "137", "hidden": true}, {"type": "text", "content": "138"}, {"type": "lean", "content": "139", "hidden": true}, {"type": "lean", "content": "140", "hidden": true}, {"type": "text", "content": "141"}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": false}, {"type": "text", "content": "144"}, {"type": "theorem", "text": "145", "lean": "theorem shift_vars : (x + y) + z = (z + x) + y :=\n", "sideBar": false, "firstProofLineNumber": 58, "firstProofHintLineNumber": 62, "lastProofHintLineNumber": 64, "lastProofLineNumber": 65, "textBefore": "import equations.transitivity -- hide\n\n/- \n# Equations\n\n## Level 11 : Proof by calculation\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nIf you did the exericse from the previous level, you may have found it overly complicated for\nsuch a simple result. The proof required showing three equations of the form `h\u2081 : a = b`,\n`h\u2082 : b = c`, and `h\u2083 : c = d` and combining them by two applications of transitivity.\n\nThis technique is so common, that we have a special notation for proofs that combine several\nequations via transitivity. First, we present the handwritten version.\n\n**Proof**:\n$$\n\\begin{align}\n(x + y) + z &= x + (y + z) & & \\text{[by associativity of addition]} \\\\\\\\\n&= x + (z + y) & &\\text{[by Theorem add_comm_congr_left]} \\\\\\\\\n&= (x + z) + y. & & \\text{[by associativity of addition (backward)]}\n\\end{align}\n$$\n\nThe same proof can be presented in Lean as follows. Here, I use underscores `_` to ask Lean\nto fill in the missing arguments.\n-/\n\nvariables (x y z : \u2115) -- hide\n\nexample : (x + y) + z = (x + z) + y :=\nbegin\n  calc  \n  (x + y) + z = x + (y + z) : add_assoc _ _ _\n          ... = x + (z + y) : add_comm_congr_left _ _ _\n          ... = (x + z) + y : add_assoc_symm _ _ _,\nend\n\n\n/-\n## Task\n\nComplete the proof below. As usual, you will find it helpful to use the results already proved.\n-/\n\n\n/- Theorem : no-side-bar\n$(x + y) + z = (z + x) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem shift_vars : (x + y) + z = (z + x) + y :=\nbegin\n", "proof": "  calc\n  (x + y) + z = (x + z) + y : add_right_comm _ _ _\n          ... = (z + x) + y : add_comm_congr_right _ _ _,\n/- hint\ncalc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,\n-/", "proof_hint": "calc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,", "textAfter": "\nend\n\n\nend exlean -- hide\n\n\n", "height": 8, "editorText": "calc\n(x + y) + z = (x + z) + y : sorry\n        ... = (z + x) + y : sorry,", "lineOffset": 57, "name": "shift_vars", "statement": "(x + y) + z = (z + x) + y"}, {"type": "lean", "content": "146", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "text", "content": "151"}, {"type": "hint", "content": "152", "title": "153"}, {"type": "hint", "content": "154", "title": "155"}, {"type": "lean", "content": "156", "hidden": true}, {"type": "theorem", "text": "157", "lean": "theorem challenge_comm_assoc : (x + y) + (s + t) = (y + (t + s)) + x :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 45, "textBefore": "import equations.calculation -- hide\n\n/- \n# Equations\n\n## Level 12 : Challenge level\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nWrite a proof by calculation (or by any other method) of the result below.\n-/\n\n/- Hint : Required results\nYou can do this entirely using `congr_arg`, `add_assoc`, and `add_comm`.\n-/\n\n/- Hint : A proof template\nTry the following proof template. For the first `sorry`, you'll need `congr_arg`.\n```\ncalc (x + y) + (s + t) = (x + y) + (t + s) : sorry\n... = x + (y + (t + s)) : sorry\n... = (y + (t + s)) + x : sorry,\n```\n-/\n\nvariables (x y z s t : \u2115) -- hide\n\n/- Theorem : no-side-bar\n$(x + y) + (s + t) = (y + (t + s)) + x$, for all natural numbers $x$, $y$, $s$, and $t$.\n-/\ntheorem challenge_comm_assoc : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n", "proof": "  calc (x + y) + (s + t) = (x + y) + (t + s) : congr_arg _ (add_comm s t)\n  ... = x + (y + (t + s)) : add_assoc _ _ _\n  ... = (y + (t + s)) + x : add_comm _ _,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide\n\n\n", "height": 8, "editorText": "sorry", "lineOffset": 37, "name": "challenge_comm_assoc", "statement": "(x + y) + (s + t) = (y + (t + s)) + x"}, {"type": "lean", "content": "158", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "159", "hidden": true}, {"type": "text", "content": "160"}, {"type": "lean", "content": "161", "hidden": true}, {"type": "lean", "content": "162", "hidden": true}, {"type": "text", "content": "163"}, {"type": "text", "content": "164"}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lean", "content": "166", "hidden": false}, {"type": "tactic", "content": "167", "name": "rw", "sideBar": true}, {"type": "text", "content": "168"}, {"type": "lean", "content": "169", "hidden": false}, {"type": "text", "content": "170"}, {"type": "lean", "content": "171", "hidden": false}, {"type": "text", "content": "172"}, {"type": "text", "content": "173"}, {"type": "lean", "content": "174", "hidden": true}, {"type": "theorem", "text": "175", "lean": "theorem add_right_comm : (x + y) + z = (x + z) + y :=\n", "sideBar": false, "firstProofLineNumber": 101, "firstProofHintLineNumber": 107, "lastProofHintLineNumber": 108, "lastProofLineNumber": 110, "textBefore": "import equations.challenge tactic.pure_maths -- hide\n\n/- \n# Equations\n\n## Level 13 : Backward proof and the `rw` tactic\n-/\n\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nLet's give a backward proof of $x + (y + z) = (z + y) + x$.\n\n**Proof**:\n$$\n\\begin{align}\n&& x + (y + z) & = (z + y) + x & &  \\\\\\\\\n&\\iff & x + (z + y)& = (z + y) + x & & \\text{[by commutativity of addition on $y$ and $z$]} \\\\\\\\\n&\\iff & (z + y) + x&= (z + y) + x. & & \\text{[by commutativity of addition on $x$ and $z + y$]}\n\\end{align}\n$$\nThe last line follows by reflexivity. \u220e\n-/\n\n/-\nHere is a Lean proof of this result.\n-/\nvariables (x y z : \u2115) -- hide\n\nexample : x + (y + z) = (z + y) + x :=\nbegin [pure_maths]\n  show x + (y + z) = (z + y) + x,   rw add_comm y z,\n  show x + (z + y) = (z + y) + x,   rw add_comm x (z + y),\n  show (z + y) + x = (z + y) + x,   from rfl,\nend\n\n/- Tactic : rw\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\nIn this proof, `rw` is short for `rewrite` and the expression `rw add_comm y z` is the Lean\nversion of the handwritten, 'by commutativity of addition on $y$ and $z$'. The only difference\nis that each `rw` appears one line above where it would in a handwritten proof.\n\nIn general, if you use `rw h` where `h : a = b`, then Lean\nwill look for every instance of `a` in the target and replace it with `b`.\n\n\n\n## Task\nThere are many ways to prove a given theorem. Below is a different backward proof of our result.\nConvert this Lean proof into a handwritten proof.\n-/\n\n\nexample : x + (y + z) = (z + y) + x :=\nbegin [pure_maths] \n  show x + (y + z) = (z + y) + x,   rw add_comm (z + y) x,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\nend\n\n/-\nThe use of `show` isn't required by Lean. Moreover, multiple applications of `rw` can\nbe combined on one line, as shown below. However, this translates poorly to handwritten proofs.\n-/\n\nexample : x + (y + z) = (z + y) + x:=\nbegin [pure_maths]\n  rw [add_comm y z, add_comm], from rfl,\nend\n/-\n\n-/\n\n/-\n## Task \nGiven a backward of the theorem `add_right_comm` that you first encounterd in the transitivity level.\nI've provided you with a suggested first line.\n\nThe old `add_right_comm` result is unavailable for use in your proof!\n-/\n\nnamespace hidden -- hide\n\n/- Theorem : no-side-bar\n$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem add_right_comm : (x + y) + z = (x + z) + y :=\nbegin[pure_maths]\n", "proof": "  show (x + y) + z = (x + z) + y,   rw add_assoc,\n  show x + (y + z) = (x + z) + y,   rw add_assoc,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\n\n/- hint\nshow (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,\n-/\n  ", "proof_hint": "show (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,", "textAfter": "\nend\n\nend hidden -- hide\n\n\nend exlean -- hide\n\n\n", "height": 10, "editorText": "show (x + y) + z = (x + z) + y,   rw add_assoc,\nsorry,", "lineOffset": 100, "name": "add_right_comm", "statement": "(x + y) + z = (x + z) + y"}, {"type": "lean", "content": "176", "hidden": true}, {"type": "lean", "content": "177", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "text", "content": "179"}, {"type": "lean", "content": "180", "hidden": true}, {"type": "lean", "content": "181", "hidden": true}, {"type": "text", "content": "182"}, {"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": false}, {"type": "text", "content": "185"}, {"type": "text", "content": "186"}, {"type": "hint", "content": "187", "title": "188"}, {"type": "theorem", "text": "189", "lean": "theorem challenge2 : x + ((y + z) + z) = ((z + z) + x) + y:=\n", "sideBar": false, "firstProofLineNumber": 56, "firstProofHintLineNumber": 63, "lastProofHintLineNumber": 65, "lastProofLineNumber": 68, "textBefore": "import equations.challenge tactic.pure_maths -- hide\n\n/- \n# Equations\n\n## Level 14 : Easy calculation proofs using `rw`\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThe idea of 'replacing equals with equals' can lead to simpler proofs. Using this idea,\nwe present a proof of the result from the challenge level.\n-/\n\nvariables (x y z s t: \u2115) -- hide\n\nexample : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n  calc\n  (x + y) + (s + t) = (x + y) + (t + s) : by rw add_comm s t\n                ... = x + (y + (t + s)) : by rw add_assoc\n                ... = (y + (t + s)) + x : by rw add_comm,\nend\n\n/-\nIn each line of justification above, the word `by` announces that we are to provide Lean with a \ntactic proof.\n\nThus, `rw add_comm s t` is a tactic proof of `(x + y) + (s + t) = (x + y) + (t + s)`.\n-/\n\n/-\n## Task\n\nComplete the proof below. To do this, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n-/\n\n/- Hint : Problems with applying `add_assoc` or `add_comm`?\nIf you try `add_comm` (or `add_assoc`) and Lean doesn't do what you expect, you may need\nto be more precise about what you want to add `add_comm` to.\n\nFor example, to justify the line `a + (b + c) = a + (c + b)` requires `rw add_comm b c`\n(or `rw add_comm b`). The problem is that `rw add_comm` by itself transforms \n`a + (b + c)` into `(b + c) + a`.\n-/\n\n/- Theorem : no-side-bar\n$x + ((y + z) + z) = ((z + z) + x) + y$, for all natural numbers $x$, $y$, and $z$.\n-/\ntheorem challenge2 : x + ((y + z) + z) = ((z + z) + x) + y:=\nbegin[pure_maths]\n", "proof": "  calc\n  x + ((y + z) + z) = ((y + z) + z) + x : by rw add_comm\n                ... = (y + (z + z)) + x : by rw add_assoc y\n                ... = y + ((z + z) + x) : by rw add_assoc\n                ... = (z + z) + x + y   : by rw add_comm,\n\n/- hint\ncalc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,\n-/\n\n  ", "proof_hint": "calc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,", "textAfter": "\nend\n\nend exlean -- hide\n\n\n", "height": 13, "editorText": "calc\nx + ((y + z) + z) = _                 : by rw add_comm\n              ... = (z + z) + x + y   : sorry,", "lineOffset": 55, "name": "challenge2", "statement": "x + ((y + z) + z) = ((z + z) + x) + y"}, {"type": "lean", "content": "190", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "191", "hidden": true}, {"type": "text", "content": "192"}, {"type": "lean", "content": "193", "hidden": true}, {"type": "lean", "content": "194", "hidden": true}, {"type": "text", "content": "195"}, {"type": "lean", "content": "196", "hidden": false}, {"type": "text", "content": "197"}, {"type": "theorem", "text": "198", "lean": "theorem ymca (x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 57, "textBefore": "import equations.rewrite_calc-- hide\n\n/- \n# Equations\n\n## Level 15 : The simplifier\n-/\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\n/-\nThis level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n-/\n\nexample (x y z : \u2115) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n\n/-\n## Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply two theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n-/\n\n/- Theorem : no-side-bar\nLet `x`, `y`, and `z` be natural numbers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`.\n-/\ntheorem ymca (x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x)) :=\nbegin\n", "proof": "  --simp [add_assoc, add_comm x z, add_zero, zero_add],\n  rw [add_zero, add_zero, zero_add, zero_add, add_assoc y x z, add_assoc,\n    add_right_comm, add_comm _ z],\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : simp\nThe `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n-/\n\n\nend exlean -- hide\n\n\n", "height": 15, "editorText": "sorry", "lineOffset": 42, "name": "ymca", "statement": "(x y z : \u2115)\n  : (y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))"}, {"type": "tactic", "content": "199", "name": "simp", "sideBar": true}, {"type": "lean", "content": "200", "hidden": true}]}]}, {"name": "201", "levels": [{"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "202", "hidden": true}, {"type": "lean", "content": "203", "hidden": true}, {"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "text", "content": "207"}, {"type": "lean", "content": "208", "hidden": false}, {"type": "text", "content": "209"}, {"type": "lean", "content": "210", "hidden": false}, {"type": "text", "content": "211"}, {"type": "axiom", "content": "212", "name": "evenb_O :", "sideBar": true}, {"type": "lean", "content": "213", "hidden": false}, {"type": "axiom", "content": "214", "name": "evenb_S (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "215", "hidden": false}, {"type": "text", "content": "216"}, {"type": "lean", "content": "217", "hidden": false}, {"type": "text", "content": "218"}, {"type": "lean", "content": "219", "hidden": false}, {"type": "text", "content": "220"}, {"type": "theorem", "text": "221", "lean": "theorem evenb_two : evenb(S(S(O))) = tt :=\n", "sideBar": false, "firstProofLineNumber": 102, "firstProofHintLineNumber": 108, "lastProofHintLineNumber": 110, "lastProofLineNumber": 111, "textBefore": "import mynat.basic tactic.pure_maths -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 1: A boolen evenness function\n\nIn this world, a natural number is either `O` (the capital letter `O`) or\n`S(k)`, where `k` is a natural number. The successor function `S` can be thought of\nas 'returning' the number `S(k)` that comes after `k`.\n\nThe number we call $2$ can be written with this definition as `S(S(O))` or `S(S O)`.\n-/\n\nexample : \u2115 := O \n\nexample : \u2115 := S O \n\nexample : \u2115 := S(S(O))\n\nexample : \u2115 := S(S(S O))\n\n/-\n\nTo define a function on `\u2115` is to give its value at `O` and to specify how its\nvalue at `S(k)` depends on its value at `k`.\n\nWe define a function `evenb` such that `evenb(n)` is `tt` (true) if `n` is even and is\n`ff` (false) otherwise. In the following recursive definition of `evenb`, the symbol `!`\nrepresents the Boolean 'not' function, defined so that `!(tt) := ff` and `!(ff) := tt`.\n-/\n\n\ndef evenb : \u2115 \u2192 bool\n| O     := tt\n| (S k) := !(evenb k)\n\n/-\nBy definition of `evenb`, we extract two lemmas. The first, `evenb_O`, asserts\n`evenbO = tt`. The second, `evenb_S`, asserts that `evenb(S(n)) = !(evenb(n))`.\n-/\n\n/- Axiom : evenb_O :\nevenb(O) = tt\n-/\nlemma evenb_O : evenb O = tt := rfl\n\n/- Axiom : evenb_S (n : \u2115) :\nevenb (S(n)) = !(evenb n)\n-/\nlemma evenb_S (n : \u2115) : evenb (S n) = !(evenb n) := rfl\n\n/-\nUsing these two lemmas, we give a proof by calculation that 3 is not even. More precisely,\nthat `evenb(S(S(S(O)))) = ff`.\n-/\n\nexample : evenb(S(S(S(O)))) = ff :=\nbegin\n  calc\n  evenb(S(S(S(O)))) = !evenb((S(S(O)))) : by rw evenb_S\n                ... = !!evenb(S O)      : by rw evenb_S\n                ... = !!!evenb(O)       : by rw evenb_S\n                ... = !!!tt             : by rw evenb_O\n                ... = ff                : rfl,\nend\n\n/-\nIn fact, as each step of the proof above involves an application of a definition, the\nresult holds by reflexivity.\n-/\n\nexample : evenb(S(S(S(O)))) = ff :=\nbegin\n  from rfl,\nend\n\n/-\n## Task\n\nComplete the proof by calculation that 2 is even. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n-/\n\n\n/- Theorem : no-side-bar\nThat $2$ is even has value 'true'.\n-/\ntheorem evenb_two : evenb(S(S(O))) = tt :=\nbegin [pure_maths]\n", "proof": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : by rw evenb_S\n              ... = !!evenb(O)    : by rw evenb_S\n              ... = !!tt          : by rw evenb_O\n              ... = tt            : rfl,\n/- hint\n  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,\n-/", "proof_hint": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "  calc\n  evenb(S(S(O)))  = !evenb(S(O))  : sorry\n              ... = tt            : sorry,", "lineOffset": 101, "name": "evenb_two", "statement": "evenb(S(S(O))) = tt"}, {"type": "lean", "content": "222", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "223", "hidden": true}, {"type": "lean", "content": "224", "hidden": true}, {"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "lean", "content": "227", "hidden": true}, {"type": "text", "content": "228"}, {"type": "axiom", "content": "229", "name": "add_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "230", "name": "add_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "231"}, {"type": "lean", "content": "232", "hidden": false}, {"type": "text", "content": "233"}, {"type": "lean", "content": "234", "hidden": false}, {"type": "text", "content": "235"}, {"type": "axiom", "content": "236", "name": "S_eq_add_one (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "237", "hidden": false}, {"type": "text", "content": "238"}, {"type": "theorem", "text": "239", "lean": "theorem one_add_two : (S O) + (S(S(O))) = S(S(S(O))) :=\n", "sideBar": false, "firstProofLineNumber": 87, "firstProofHintLineNumber": 92, "lastProofHintLineNumber": 94, "lastProofLineNumber": 95, "textBefore": "import natural_numbers.evenb -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 2: The definition of addition\n\nOur addition function is defined so that for every natural number `m`, we have\n`m + O = m` and `m + (S n) = S(m + n)`, for every natural number `n`.\n\nThese definitions are available as the theorems `add_O` and `add_S`:\n\n`add_O (m : \u2115) : m + O = m`\n\n`add_S (m n : \u2115) : m + (S n) = S(m + n)`\n-/\n\n/- Axiom : add_O (n : \u2115) :\nn + O = n\n-/\n\n/- Axiom : add_S (m n : \u2115) :\nm + (S n) = S(m + n)\n-/\n\n/-\nUsing these two lemmas, we give a proof by calculation that `(S O) + (S O) = S(S(O))`,\nthat is, that $1 + 1 = 2$.\n-/\n\nexample : (S O) + (S O) = S(S(O)) :=\nbegin\n  calc\n  (S O) + (S O) = S((S O) + O)  : by rw add_S\n            ... = S(S(O))       : by rw add_O\nend\n\n/-\nAs in the previous level, both sides are *definitionally* equal to `S(S(O))`, thus\nthe result could, more easily, be proved by reflexivity.\n-/\n\nexample : (S O) + (S O) = S(S(O)) :=\nbegin\n  from rfl,\nend\n\n/-\nAs another example, we prove that `S(n) = n + (S O)`, effectively that\n$\\mathsf{S}(n) = n + 1$.\n-/\n\n/- Axiom : S_eq_add_one (n : \u2115) :\nS n = n + (S O)\n-/\nlemma S_eq_add_one (n : \u2115) : S n = n + (S O) :=\nbegin [pure_maths]\n  show S n = n + (S O), rw add_S,\n  show S n = S(n + O),  rw add_O,\n  show S n = S n, from rfl,\nend\n\n/-\n## Task\n\nComplete the proof by calculation that $1 + 2 = 3$. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n-/\n\n\n/- Theorem : no-side-bar\n$1 + 2 = 3$.\n-/\ntheorem one_add_two : (S O) + (S(S(O))) = S(S(S(O))) :=\nbegin [pure_maths]\n", "proof": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : by rw add_S\n                ... = S(S((S O) + O)) : by rw add_S\n                ... = S(S(S(O)))      : by rw add_O\n/- hint\n  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,\n-/", "proof_hint": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "  calc\n  (S O) + (S(S(O))) = S((S O) + S(O)) : sorry\n                ... = S(S(S(O)))      : sorry,", "lineOffset": 86, "name": "one_add_two", "statement": "(S O) + (S(S(O))) = S(S(S(O)))"}, {"type": "lean", "content": "240", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "241", "hidden": true}, {"type": "lean", "content": "242", "hidden": true}, {"type": "lean", "content": "243", "hidden": true}, {"type": "lean", "content": "244", "hidden": true}, {"type": "lean", "content": "245", "hidden": true}, {"type": "text", "content": "246"}, {"type": "text", "content": "247"}, {"type": "text", "content": "248"}, {"type": "tactic", "content": "249", "name": "induction", "sideBar": true}, {"type": "axiom", "content": "250", "name": "O_add (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "251", "hidden": false}, {"type": "lean", "content": "252", "hidden": true}, {"type": "lean", "content": "253", "hidden": false}, {"type": "lean", "content": "254", "hidden": true}, {"type": "lean", "content": "255", "hidden": false}, {"type": "text", "content": "256"}, {"type": "lean", "content": "257", "hidden": false}, {"type": "text", "content": "258"}, {"type": "hint", "content": "259", "title": "260"}, {"type": "theorem", "text": "261", "lean": "theorem S_eq_one_add (n : \u2115) : S(n) = S(O) + n :=\n", "sideBar": true, "firstProofLineNumber": 128, "firstProofHintLineNumber": 140, "lastProofHintLineNumber": 146, "lastProofLineNumber": 147, "textBefore": "import natural_numbers.addition -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 3: Induction and `S_eq_one_add`\n\nLet $P$ be a predicate on $\\mathbb N$. To prove that $P(n)$ holds for every natural number $n$\nis to:\n1. [base case] prove $P(\\mathsf{O})$ and\n2. [inductive step] prove that for every $k : \\mathbb N$, $P(\\mathsf S(k))$ follows from the *induction hypothesis*,\nthe assumption of $P(k)$.\n\nThis is called *proof by induction*.\n-/\n\n/-\nVia proof by induction, one may prove $\\mathsf O + n = n$, for every $n : \\mathbb N$. Here, the\npredicate $P$ is given by $P(n) := \\mathsf O + n = n$.\n\n**Proof**:\n1. [Base case] We must show $P(\\mathsf O)$. That is, $\\mathsf O + \\mathsf O = \\mathsf O$. This follows by definition of\naddition.\n\n2. [Inductive step] Let $k$ be a natural number. Assume the induction hypothesis $h : P(k)$, which is\n$\\mathsf O + k = k$. We must show $P(\\mathsf S(k))$, i.e. $\\mathsf O + \\mathsf S(k) = \\mathsf S(k)$.\nBut\n$$\n\\begin{align}\n\\mathsf O + \\mathsf S(k) & = \\mathsf S(\\mathsf O + k) && \\text{[by definition of addition]} \\\\\\\\\n&= \\mathsf S(k). & & \\text{[by  $h$]}\n\\end{align}\n$$\n\nThe result follows by induction. \u220e \n-/\n\n/-\nThe same result is proved in Lean below. Here, `induction n` marks the start of the proof. The base case is\nindicated with `case O` and the inductive step with `case S`.\n\nThe base case is the proof of `P(O)`. That is, the proof of `O + O = O`. This holds by\ndefinition of addition, and hence by reflexivity.\n\nIn the inductive step, the quantities `k` and `h` in `case S : k h` are the induction variable\nand induction hypothesis, respectively. We must show `P(S(k))`, i.e. `O + S(k) = S(k)`,\ngiven the induction hypothesis: the assumption of `P(k)`, i.e.\nof `O + k = k`.\n-/\n\n/- Tactic : induction\nTo prove `P(n)` holds for all `n : \u2115`, use the `induction n`. This opens up two new goals:\n(1) to prove `P(O)` and (2) to prove `P(S(k))` on the assumption of `P(k)`.\n\nTo specify the names of the induction variable (say `k`) and induction hypothesis (say `h`)\nyou can either use the form `induction with k h` or you can tag the induction step with\n`case S : k h`.\n-/\n\n\n/- Axiom : O_add (n : \u2115) :\nO + n = n\n-/\n@[simp] lemma O_add (n : \u2115) : O + n = n :=\nbegin\n  induction n,\n  -- hide\n  case O :\n  { show O + O = O, from rfl, },\n  -- hide\n  case S : k h\n  { show O + S(k) = S(k),\n    given h : O + k = k,\n    calc\n    O + S(k)  = S(O + k)  : by rw add_S\n          ... = S(k)      : by rw h, },\nend\n\n/-\nAs an aside, note that I've tagged the theorem above with `@[simp]`. This\nmeans that the `simp` tactic will automatically call on `O_add` whenever applicable, as in\nthe proof below.\n-/\n\nexample (n : \u2115) : (O + (O + n)) + O  = n :=\nbegin\n  simp,\nend\n\n/-\n## Task\n\nComplete the following proof by induction, following the template given by the proof of `O_add`\nabove. Note you have to separately proof the base case and the inductive step.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S(O) = S(O) + O, sorry, },\n\ncase S : k h\n{ show S(S(k)) = S(O) + S(k),\n  given h : S(k) = S(O) + k,\n  sorry, },\n```\n\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf S(n) = \\mathsf S(\\mathsf O) + n$. That is,\n$\\mathsf S(n) = 1 + n$.\n-/\ntheorem S_eq_one_add (n : \u2115) : S(n) = S(O) + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S(O) = S(O) + O, from rfl, },\n\n  case S : k h\n  { show S(S(k)) = S(O) + S(k),\n    given h : S(k) = S(O) + k,\n    calc\n    S(S(k)) = S(S(O) + k) : by rw h\n        ... = S(O) + S(k) : rfl, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 127, "name": "S_eq_one_add", "statement": "(n : \u2115) : S(n) = S(O) + n"}, {"type": "lean", "content": "262", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "263", "hidden": true}, {"type": "lean", "content": "264", "hidden": true}, {"type": "lean", "content": "265", "hidden": true}, {"type": "lean", "content": "266", "hidden": true}, {"type": "lean", "content": "267", "hidden": true}, {"type": "text", "content": "268"}, {"type": "hint", "content": "269", "title": "270"}, {"type": "hint", "content": "271", "title": "272"}, {"type": "theorem", "text": "273", "lean": "theorem S_add (m n : \u2115) : S(m) + n = S(m + n) :=\n", "sideBar": true, "firstProofLineNumber": 59, "firstProofHintLineNumber": 72, "lastProofHintLineNumber": 78, "lastProofLineNumber": 79, "textBefore": "import natural_numbers.S_eq_one_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 4: `S_add`\n\nIn this level, you'll prove a result that depends on two variables $m$ and $n$ by fixing $m$\nand performing induction on $n$.\n\n## Task\n\nComplete the following proof by induction.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S m + O = S(m + O), sorry, },\n\ncase S : k h\n{ show S(m) + S(k) = S(m + S(k)),\n  given h : S(m) + k = S(m + k),\n  sorry, },\n```\n-/\n\n/- Hint : A cheap proof using `simp`\nIf you used the proof template above, the goal of the inductive step is\n```\n m k : \u2115,\n h : S m + k = S (m + k)\n \u22a2 S m + S k = S (m + S k)\n```\nTo help you understand proof by induction, I recommend using a proof by calculation here.\nHowever, Lean can partially automate the construction of a proof using the `simp` tactic. Here,\n`simp [add_S, h]` proves the inductive step. It tells Lean to use `add_S` and the inductive\nhypothesis `h` (and any other lemma marked with the `simp` attribute) as many times as necesary\nand in whatever order until a proof is found or no further simplification is possible.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $\\mathsf S(m) + n = \\mathsf S(m + n)$.\n-/\ntheorem S_add (m n : \u2115) : S(m) + n = S(m + n) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S m + O = S(m + O), from rfl, },\n\n  case S : k h\n  { show S(m) + S(k) = S(m + S(k)), \n    given h : S(m) + k = S(m + k),\n    calc\n    S(m) + S(k) = S(S(m) + k) : by rw add_S\n            ... = S(S(m + k)) : by rw h\n            ... = S(m + S(k)) : by rw add_S, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 58, "name": "S_add", "statement": "(m n : \u2115) : S(m) + n = S(m + n)"}, {"type": "lean", "content": "274", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "275", "hidden": true}, {"type": "lean", "content": "276", "hidden": true}, {"type": "lean", "content": "277", "hidden": true}, {"type": "lean", "content": "278", "hidden": true}, {"type": "lean", "content": "279", "hidden": true}, {"type": "text", "content": "280"}, {"type": "lean", "content": "281", "hidden": false}, {"type": "text", "content": "282"}, {"type": "axiom", "content": "283", "name": "double_O :", "sideBar": true}, {"type": "lean", "content": "284", "hidden": false}, {"type": "axiom", "content": "285", "name": "double_S (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "286", "hidden": false}, {"type": "text", "content": "287"}, {"type": "theorem", "text": "288", "lean": "theorem double_eq_add_self (n : \u2115) : double(n) = n + n :=\n", "sideBar": true, "firstProofLineNumber": 53, "firstProofHintLineNumber": 67, "lastProofHintLineNumber": 73, "lastProofLineNumber": 74, "textBefore": "import natural_numbers.S_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 5: Doubling\n\nThe function `double` from `\u2115` to `\u2115` is defined so that `double(O) := O` and\n`double(S(k)) = S(S(double(k)))`. It corresponds to the ordinary notion of doubling a natural\nnumber.\n-/\n\ndef double : \u2115 \u2192 \u2115\n| O     := O\n| (S k) := S (S (double k))\n\n\n/-\nThe definition equations of `double` give two results, by reflexivity.\n-/\n\n/- Axiom : double_O :\ndouble(O) = O\n-/\nlemma double_O : double(O) = O := rfl\n\n/- Axiom : double_S (n : \u2115) :\ndouble(S(n)) = S(S(double(n)))\n-/\n\nlemma double_S (n : \u2115) : double(S(n)) = S(S(double(n))) := rfl\n\n/-\n## Task\n\nComplete the following proof by induction. Use the results `double_O` and `double_S` above\ntogether with any relevant results from previous levels in this world.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf{double}(n) = n + n$.\n-/\ntheorem double_eq_add_self (n : \u2115) : double(n) = n + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show double(O) = O + O, from rfl, },\n\n  case S : k h\n  { show double(S(k)) = S(k) + S(k),\n    given h : double k = k + k,\n    calc\n    double(S(k))  = S(S(double(k))) : by rw double_S\n              ... = S(S(k + k))     : by rw h\n              ... = S(k + S(k))     : by rw add_S\n              ... = S(k) + S(k)     : by rw S_add },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 22, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 52, "name": "double_eq_add_self", "statement": "(n : \u2115) : double(n) = n + n"}, {"type": "lean", "content": "289", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "290", "hidden": true}, {"type": "lean", "content": "291", "hidden": true}, {"type": "lean", "content": "292", "hidden": true}, {"type": "lean", "content": "293", "hidden": true}, {"type": "lean", "content": "294", "hidden": true}, {"type": "text", "content": "295"}, {"type": "text", "content": "296"}, {"type": "hint", "content": "297", "title": "298"}, {"type": "theorem", "text": "299", "lean": "theorem add_comm (m n : \u2115) : m + n = n + m :=\n", "sideBar": true, "firstProofLineNumber": 34, "firstProofHintLineNumber": 49, "lastProofHintLineNumber": 55, "lastProofLineNumber": 56, "textBefore": "import natural_numbers.double_eq_add_self -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 6: Commutativity of addition\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that $m + n = n + m$\nfor all natural numbers $n$.\n-/\n\n/- Hint : Proving the base case\nThis is the first level where the base case cannot be proved by reflexivity. Previously proved\nresults will come in handy here. See the 'Theorem statements' side bar on the left for inspiration.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $m + n = n + m$.\n-/\ntheorem add_comm (m n : \u2115) : m + n = n + m :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show m + O = O + m, calc\n    m + O = m     : by rw add_O\n      ... = O + m : by rw O_add, },\n\n  case S : k h\n  { show m + S(k) = S(k) + m,\n    given h : m + k = k + m,\n    calc\n    m + S(k)  = S(m + k) : by rw add_S\n          ... = S(k + m) : by rw h\n          ... = S(k) + m : by rw S_add, },\n/- hint\n  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 23, "editorText": "  induction n,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 33, "name": "add_comm", "statement": "(m n : \u2115) : m + n = n + m"}, {"type": "lean", "content": "300", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "301", "hidden": true}, {"type": "lean", "content": "302", "hidden": true}, {"type": "lean", "content": "303", "hidden": true}, {"type": "lean", "content": "304", "hidden": true}, {"type": "lean", "content": "305", "hidden": true}, {"type": "text", "content": "306"}, {"type": "text", "content": "307"}, {"type": "theorem", "text": "308", "lean": "theorem add_assoc (x y z : \u2115) : (x + y) + z = x + (y + z) :=\n", "sideBar": true, "firstProofLineNumber": 29, "firstProofHintLineNumber": 41, "lastProofHintLineNumber": 47, "lastProofLineNumber": 48, "textBefore": "import natural_numbers.add_comm -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 7: Associativity of addition\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be a natural numbers. By induction on $z$, prove that $(x + y) + z = x + (y + z)$\nfor all natural numbers $z$.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\n-/\ntheorem add_assoc (x y z : \u2115) : (x + y) + z = x + (y + z) :=\nbegin [pure_maths]\n", "proof": "  induction z with k h,\n\n  case O :\n  { refl, },\n\n  case S : k h\n  { given h : (x + y) + k = x + (y + k),\n    show (x + y) + S(k) = x + (y + S(k)), calc\n    (x + y) + S(k)  = S((x + y) + k)    : by rw add_S\n                ... = S(x + (y + k))    : by rw h\n                ... = x + (y + (S(k)))  : rfl },\n/- hint\n  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },\n-/", "proof_hint": "  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "  induction z,\n\n  case O :\n  { sorry, },\n\n  case S : k h\n  { sorry, },", "lineOffset": 28, "name": "add_assoc", "statement": "(x y z : \u2115) : (x + y) + z = x + (y + z)"}, {"type": "lean", "content": "309", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "310", "hidden": true}, {"type": "lean", "content": "311", "hidden": true}, {"type": "lean", "content": "312", "hidden": true}, {"type": "lean", "content": "313", "hidden": true}, {"type": "lean", "content": "314", "hidden": true}, {"type": "text", "content": "315"}, {"type": "text", "content": "316"}, {"type": "lean", "content": "317", "hidden": true}, {"type": "lean", "content": "318", "hidden": true}, {"type": "lean", "content": "319", "hidden": false}, {"type": "tactic", "content": "320", "name": "ac_refl", "sideBar": true}, {"type": "text", "content": "321"}, {"type": "theorem", "text": "322", "lean": "theorem easy_add :\n(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)  :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 65, "textBefore": "import natural_numbers.add_assoc algebra.group.defs -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 8: Easy addition with `ac_refl`\n-/\n\n/-\nIf you were asked to prove $(a + b) + (c + (b + a)) = (c + (b + b)) + (a + a)$ for all natural \nnumbers $a$, $b$, and $c$, you might say that the statement is clearly true, by rearranging.\n\nIf you were required to prove this step-by-step using the laws of commutativity and associativity\nof addition, it would be a pain.\n\nFortunately, Lean comes with a clever tactic called `ac_refl` that can creates proofs of any\nresult that can be justified solely by associativity, commutativity, and reflexivity.\n\nSince we've shown `+` is associative and commutative, we may use `ac_refl`.\n-/\n\n-- begin hide\ninstance : add_comm_monoid mynat :=\n{ add_assoc := add_assoc,\n  add_comm := add_comm,\n  zero_add := O_add,\n  add_zero := add_O,\n  .. }\n\n-- end hide\n\nvariables (a b c v i o l e t : \u2115) -- hide\n\nexample : (a + b) + (c + (b + a)) = (c + (b + b)) + (a + a) :=\nbegin\n  ac_refl,\nend\n\n/- Tactic : ac_refl\nThis tactic closes any goal that can be proved only by associativity, commutativity, and\nreflexivity.\n-/\n\n\n/-\n## Task\n\nUse `ac_refl` to prove the following.\n-/\n\n/- Theorem : no-side-bar\n$(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)$.\n-/\ntheorem easy_add :\n(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)  :=\nbegin [pure_maths]\n", "proof": "  ac_refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 1, "editorText": "sorry", "lineOffset": 64, "name": "easy_add", "statement": "(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)"}, {"type": "lean", "content": "323", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "324", "hidden": true}, {"type": "lean", "content": "325", "hidden": true}, {"type": "lean", "content": "326", "hidden": true}, {"type": "lean", "content": "327", "hidden": true}, {"type": "lean", "content": "328", "hidden": true}, {"type": "text", "content": "329"}, {"type": "axiom", "content": "330", "name": "mul_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "331", "name": "mul_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "332"}, {"type": "axiom", "content": "333", "name": "mul_one (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "334", "hidden": false}, {"type": "text", "content": "335"}, {"type": "theorem", "text": "336", "lean": "theorem mul_two (n : \u2115) : n * S(S(O)) = n + n :=\n", "sideBar": true, "firstProofLineNumber": 67, "firstProofHintLineNumber": 73, "lastProofHintLineNumber": 75, "lastProofLineNumber": 76, "textBefore": "import natural_numbers.easy_addition -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 9: Multiplication and `mul_two`\n\nThe multiplication function is defined so that for every natural number `m`, we have\n`m * O = O` and `m * (S n) = m * n + m`, for every natural number `n`.\n\nThese definitions are available as the theorems `mul_O` and `mul_S`:\n\n`mul_O (m : \u2115) : m * O = O`\n\n`mul_S (m n : \u2115) : m * (S n) = m * n + m`\n-/\n\n/- Axiom : mul_O (n : \u2115) :\nn * O = O\n-/\n\n/- Axiom : mul_S (m n : \u2115) :\nm * (S n) = m * n + m\n-/\n\n/-\nUsing these 'definitional' results, we'll prove $n \\times 1 = n$.\n-/\n\n/- Axiom : mul_one (n : \u2115) :\nn * S(O) = n\n-/\n@[simp] lemma mul_one (n : \u2115) : n * S(O) = n :=\nbegin\n  calc\n  n * S(O)  = n * O + n : by rw mul_S\n        ... = O + n     : by rw mul_O\n        ... = n         : by rw O_add,\nend\n\n/-\n## Task\n\nProve that $n \\times \\mathsf S(\\mathsf S(\\mathsf O)) = n + n$, for every natural number $n$.\nYou *do not* require induction for this proof. Give a proof by calculation using previously\nproved results.\n\nTo complete the proof, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $n \\times 2 = n + n$.\n-/\n\n\ntheorem mul_two (n : \u2115) : n * S(S(O)) = n + n :=\nbegin [pure_maths]\n", "proof": "  calc\n  n * S(S(O)) = n * S(O) + n    : by rw mul_S\n          ... = (n * O + n) + n : by rw mul_S\n          ... = (O + n) + n     : by rw mul_O\n          ... = n + n           : by rw O_add,\n/- hint\n  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,\n-/", "proof_hint": "  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "  calc\n  n * S(S(O)) = _               : by rw mul_S\n          ... = n + n           : by sorry,", "lineOffset": 66, "name": "mul_two", "statement": "(n : \u2115) : n * S(S(O)) = n + n"}, {"type": "lean", "content": "337", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "338", "hidden": true}, {"type": "lean", "content": "339", "hidden": true}, {"type": "lean", "content": "340", "hidden": true}, {"type": "lean", "content": "341", "hidden": true}, {"type": "lean", "content": "342", "hidden": true}, {"type": "text", "content": "343"}, {"type": "text", "content": "344"}, {"type": "theorem", "text": "345", "lean": "theorem O_mul (n : \u2115) : O * n = O :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 45, "textBefore": "import natural_numbers.mul_two -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 10: Multiply by O on the left\n-/\n\n/-\n## Task\n\nBy induction on $n$, prove that $\\mathsf O \\times n = \\mathsf O$,\nfor every natural number $n$.\n-/\n\n/- Theorem :\nFor every natural number $n$, we have $\\mathsf O \\times n = \\mathsf O$.\n-/\ntheorem O_mul (n : \u2115) : O * n = O :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show O * O = O, from rfl, },\n\n  case S : k h\n  { show O * S(k) = O,\n    given h : O * k = O,\n    calc\n    O * S(k)  = O * k + O : by rw mul_S\n          ... = O + O     : by rw h\n          ... = O         : by rw add_O, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nattribute [simp] O_mul -- hide\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 28, "name": "O_mul", "statement": "(n : \u2115) : O * n = O"}, {"type": "lean", "content": "346", "hidden": true}, {"type": "lean", "content": "347", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "348", "hidden": true}, {"type": "lean", "content": "349", "hidden": true}, {"type": "lean", "content": "350", "hidden": true}, {"type": "lean", "content": "351", "hidden": true}, {"type": "lean", "content": "352", "hidden": true}, {"type": "text", "content": "353"}, {"type": "text", "content": "354"}, {"type": "theorem", "text": "355", "lean": "theorem mul_add (x y z : \u2115) : x * (y + z) = x * y + x * z :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 51, "textBefore": "import natural_numbers.zero_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 11: Left distributivity of multiplication\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$x(y + z) = x y + xz$, for every natural number $z$.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $x(y + z) = xy + xz$.\n-/\ntheorem mul_add (x y z : \u2115) : x * (y + z) = x * y + x * z :=\nbegin [pure_maths]\n", "proof": "  induction z,\n\n  case O :\n  { show x * (y + O) = x * y + x * O, calc\n    x * (y + O) = x * y           : by rw add_O\n            ... = x * y + O       : by rw add_O\n            ... = x * y + (x * O) : by rw mul_O },\n\n  case S : k h\n  { show x * (y + S(k)) = x * y + x * S(k),\n    given h : x * (y + k) = x * y + x * k,\n    calc\n    x * (y + S(k))  = x * (S(y + k))        : by rw add_S\n                ... = x * (y + k) + x       : by rw mul_S\n                ... = (x * y + x * k) + x   : by rw h\n                ... = x * y + (x * k + x)   : by rw add_assoc\n                ... = x * y + x * S(k)      : by rw mul_S, },\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 23, "editorText": "sorry", "lineOffset": 28, "name": "mul_add", "statement": "(x y z : \u2115) : x * (y + z) = x * y + x * z"}, {"type": "lean", "content": "356", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "357", "hidden": true}, {"type": "lean", "content": "358", "hidden": true}, {"type": "lean", "content": "359", "hidden": true}, {"type": "lean", "content": "360", "hidden": true}, {"type": "lean", "content": "361", "hidden": true}, {"type": "text", "content": "362"}, {"type": "text", "content": "363"}, {"type": "hint", "content": "364", "title": "365"}, {"type": "theorem", "text": "366", "lean": "theorem mul_assoc (x y z : \u2115) : (x * y) * z = x * (y * z) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 53, "textBefore": "import natural_numbers.mul_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 12: Associativity of multiplication\n-/\n\n/-\n## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$(xy)z = x(yz)$, for every natural number $z$.\n-/\n\n/- Hint : A helpful result\nAt some point in your proof, it will be helpful to use `mul_add`, the\nleft distributivity of multiplication result.\n-/\n\n/- Theorem :\nFor all natural numbers $x$, $y$, and $z$, we have $(xy)z = x(yz)$.\n-/\ntheorem mul_assoc (x y z : \u2115) : (x * y) * z = x * (y * z) :=\nbegin [pure_maths]\n", "proof": "  induction z,\n\n  case O :\n  { show (x * y) * O = x * (y * O), from rfl, },\n\n  case S : k h\n  { show (x * y) * S(k) = x * (y * S(k)),\n    given h : (x * y) * k = x * (y * k),\n    calc\n    (x * y) * S(k)  = (x * y) * k + (x * y)   : by rw mul_S\n                ... = x * (y * k) + x * y     : by rw h\n                ... = x * (y * k + y)         : by rw mul_add\n                ... = x * (y * S(k))          : by rw mul_S, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 33, "name": "mul_assoc", "statement": "(x y z : \u2115) : (x * y) * z = x * (y * z)"}, {"type": "lean", "content": "367", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "368", "hidden": true}, {"type": "lean", "content": "369", "hidden": true}, {"type": "lean", "content": "370", "hidden": true}, {"type": "lean", "content": "371", "hidden": true}, {"type": "lean", "content": "372", "hidden": true}, {"type": "text", "content": "373"}, {"type": "text", "content": "374"}, {"type": "hint", "content": "375", "title": "376"}, {"type": "theorem", "text": "377", "lean": "theorem S_mul (m n : \u2115) : S(m) * n = m * n + n :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 59, "textBefore": "import natural_numbers.mul_assoc -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 13: `S_mul`\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$\\mathsf S(m) n = mn + n$, for every natural number $n$.\n\nThis is the hardest induction so far.\n-/\n\n/- Hint : Helpful results\nAt some point in your proof of the inductive step, it will be\nhelpful to use `mul_S`, `add_S`, `add_assoc`, and `add_comm`.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $\\mathsf S(m) n = mn + n$.\n-/\ntheorem S_mul (m n : \u2115) : S(m) * n = m * n + n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show S(m) * O = m * O + O, from rfl, },\n\n  case S : k h\n  { show S(m) * S(k) = m * S(k) + S(k),\n    given h : S(m) * k = m * k + k,\n    calc\n    S(m) * S(k) = S(m) * k + S(m)       : by rw mul_S\n            ... = (m * k + k) + S(m)    : by rw h\n            ... = S((m * k + k) + m)    : by rw add_S\n            ... = S(m * k + (k + m))    : by rw add_assoc\n            ... = S(m * k + (m + k))    : by rw add_comm k\n            ... = S((m * k + m) + k)    : by rw add_assoc\n            ... = ((m * k) + m) + S(k)  : by rw add_S\n            ... = m * S(k) + S(k)       : by rw mul_S, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 35, "name": "S_mul", "statement": "(m n : \u2115) : S(m) * n = m * n + n"}, {"type": "lean", "content": "378", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "379", "hidden": true}, {"type": "lean", "content": "380", "hidden": true}, {"type": "lean", "content": "381", "hidden": true}, {"type": "lean", "content": "382", "hidden": true}, {"type": "lean", "content": "383", "hidden": true}, {"type": "text", "content": "384"}, {"type": "text", "content": "385"}, {"type": "theorem", "text": "386", "lean": "theorem mul_comm (m n : \u2115) : m * n = n * m :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 51, "textBefore": "import natural_numbers.S_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 14: Commutativity of multiplication\n-/\n\n/-\n## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$mn = nm$, for every natural number $n$.\n\nYou've done all the hard work in the previous level, `S_mul`.\n-/\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $mn = nm$.\n-/\ntheorem mul_comm (m n : \u2115) : m * n = n * m :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { show m * O = O * m,\n    calc\n    m * O = O     : by rw mul_O\n      ... = O * m : by rw O_mul, },\n\n  case S : k h\n  { show m * S(k) = S(k) * m,\n    given h : m * k = k * m,\n    calc\n    m * S(k)  = m * k + m   : by rw mul_S\n          ... = k * m + m   : by rw h\n          ... = S(k) * m    : by rw S_mul, }\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 30, "name": "mul_comm", "statement": "(m n : \u2115) : m * n = n * m"}, {"type": "lean", "content": "387", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "388", "hidden": true}, {"type": "lean", "content": "389", "hidden": true}, {"type": "lean", "content": "390", "hidden": true}, {"type": "lean", "content": "391", "hidden": true}, {"type": "lean", "content": "392", "hidden": true}, {"type": "text", "content": "393"}, {"type": "axiom", "content": "394", "name": "one_mul (m : \u2115) :", "sideBar": true}, {"type": "lean", "content": "395", "hidden": true}, {"type": "text", "content": "396"}, {"type": "lean", "content": "397", "hidden": false}, {"type": "text", "content": "398"}, {"type": "tactic", "content": "399", "name": "ring", "sideBar": true}, {"type": "lean", "content": "400", "hidden": false}, {"type": "text", "content": "401"}, {"type": "theorem", "text": "402", "lean": "theorem easy_mul (a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2  :=\n", "sideBar": false, "firstProofLineNumber": 104, "lastProofLineNumber": 105, "textBefore": "import natural_numbers.mul_comm tactic.ring -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 15: Easy arithmetic\n\nWe've proved a significant set of theorems about natural number arithmetic. We know addition\nand multiplication are associative and commutative. We know that multiplication is distributive.\nWe know special facts about adding and multiplying by zero and multiplying by one.\n\nPut together, these facts mean that `\u2115` is something called a 'commutative semiring'. You don't\nneed to know what that means for the moment. What's important is that Lean has powerful tactics\nfor proving results in commutative semirings.\n-/\n\n/- Axiom : one_mul (m : \u2115) :\nS(O) * m = m\n-/\n-- begin hide\n@[simp] lemma one_mul (n : \u2115) : S(O) * n = n := by rw [mul_comm, mul_one]\n\ninstance : comm_monoid mynat :=\n{ mul_assoc := mul_assoc,\n  mul_comm := mul_comm,\n  one_mul := one_mul,\n  mul_one := mul_one,\n  .. }\n\ninstance : has_coe nat mynat := \u27e8\u03bb n, nat.rec_on n O (\u03bb a b, S b)\u27e9\n\nlemma coe_succ (n : nat) : \u2191(nat.succ n) = S n := rfl\n\nlemma nsmul_succ' (n : nat) (x : mynat) : \u2191(n.succ) * x = x + \u2191n * x :=\nby rw [coe_succ, S_mul, add_comm]\n\nlemma add_mul (a b c : \u2115) : (a + b) * c = a * c + b * c :=\nby rw [mul_comm, mul_add, mul_comm c, mul_comm c]\n\ninstance : comm_semiring mynat :=\n{ nsmul := \u03bb m n, m * n,\n  nsmul_zero' := O_mul,\n  nsmul_succ' := nsmul_succ',\n  left_distrib := mul_add,\n  right_distrib := add_mul,\n  zero_mul := O_mul,\n  mul_zero := mul_O,\n  ..mynat.add_comm_monoid, ..mynat.comm_monoid, .. }\n\n-- end hide\n\n/-\nFor example, the `ring` tactic can prove $(a + b)^2 = a^2 + 2ab + b^2$.\n-/\n\nexample (a b c : \u2115) :\n(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 :=\nbegin\n  ring,\nend\n\n/-\nTo make things interesting, we can pose the proof above as a question. Find $x$ such that\n$(a + b)^2 = a^2 + xab + b^2$, for all $a$ and $b$.\n\nThe answer is $2$ (of course!). You tell Lean to use $2$ by typing `use 2`. Then `ring`\nfinishes the proof.\n-/\n\n/- Tactic : ring\nProves equations in commutative semirings (such as \u2115).\n-/\n\nexample (a b c : \u2115) : \u2203 (x : \u2115),\n(a + b) ^ 2 = a ^ 2 + x * a * b + b ^ 2 :=\nbegin\n  use 2,\n  ring,\nend\n\n/-\n## Task\n\nAdapting the proof above, prove the following result by finding $x$ such that\n$(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$.\n-/\n\n/- Theorem : no-side-bar\nThere exists a natural number $x$ such that $(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$, for all\nnatural numbers $a$ and $b$.\n-/\n\ntheorem easy_mul (a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2  :=\nbegin\n", "proof": "  use 5,\n  ring,", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 2, "editorText": "sorry", "lineOffset": 103, "name": "easy_mul", "statement": "(a b : \u2115) : \u2203 (x : \u2115),\n(a + 2 * b) * (2 * a + b) = 2 * a ^ 2 + x * a * b + 2 * b ^ 2"}, {"type": "lean", "content": "403", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "404", "hidden": true}, {"type": "lean", "content": "405", "hidden": true}, {"type": "lean", "content": "406", "hidden": true}, {"type": "lean", "content": "407", "hidden": true}, {"type": "lean", "content": "408", "hidden": true}, {"type": "text", "content": "409"}, {"type": "text", "content": "410"}, {"type": "axiom", "content": "411", "name": "pow_O (n : \u2115) :", "sideBar": true}, {"type": "axiom", "content": "412", "name": "pow_S (m n : \u2115) :", "sideBar": true}, {"type": "text", "content": "413"}, {"type": "theorem", "text": "414", "lean": "theorem pow_one (m : \u2115) : m ^ S(O) = m :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 58, "textBefore": "import natural_numbers.easy_multiplication -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 16: Exponentiation. Raising to the first power\n-/\n\n/-\nLet $m$ be a natural number. We'll define raising $m$ to the (natural number) power $n$\nrecursively on $n$ so that $m^{\\mathsf O} := 1$ and $m^{\\mathsf S(n)} := (m ^ n) \\times m$.\n\nIn Lean, we write `m ^ n` for $m ^ n$. The defining equations of exponentiation are represented\nby the following theorems.\n\n`pow_O (n : \u2115) : n ^ O = S(O)`\n\n`pow_S (m n : \u2115) : m ^ S(n) = (m ^ n) * m`\n-/\n\n/- Axiom : pow_O (n : \u2115) :\nn ^ O = S(O)\n-/\n\n/- Axiom : pow_S (m n : \u2115) :\nm ^ S(n) = (m ^ n) * m\n-/\n\n\n/-\n## Task\n\nProve that $m ^ 1 = m$, for every natural number $m$. You *don't* need\ninduction.\n-/\n\n\n/- Theorem :\nFor all natural numbers $m$ and $n$, we have $mn = nm$.\n-/\ntheorem pow_one (m : \u2115) : m ^ S(O) = m :=\nbegin [pure_maths]\n", "proof": "  calc\n  m ^ S(O)  = m ^ O * m : by rw pow_S\n        ... = S(O) * m  : by rw pow_O\n        ... = m         : by rw one_mul,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 50, "name": "pow_one", "statement": "(m : \u2115) : m ^ S(O) = m"}, {"type": "lean", "content": "415", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "416", "hidden": true}, {"type": "lean", "content": "417", "hidden": true}, {"type": "lean", "content": "418", "hidden": true}, {"type": "lean", "content": "419", "hidden": true}, {"type": "lean", "content": "420", "hidden": true}, {"type": "text", "content": "421"}, {"type": "theorem", "text": "422", "lean": "theorem one_pow (m : \u2115) : S(O) ^ m = S(O) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 41, "textBefore": "import natural_numbers.pow_one -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 17: Powers of 1\n\n## Task\n\nProve that $1 ^ m = 1$, for every natural number $m$.\n-/\n\n/- Theorem :\n$1 ^ m = 1$, for every natural number $m$.\n-/\ntheorem one_pow (m : \u2115) : S(O) ^ m = S(O) :=\nbegin [pure_maths]\n", "proof": "  induction m,\n\n  case O :\n  { show S(O) ^ O = S(O), from rfl, },\n\n  case S : k h\n  { show S(O) ^ S(k) = S(O),\n    given h : S(O) ^ k = S(O),\n    calc\n    S(O) ^ S(k) = S(O) ^ k * S(O) : by rw pow_S\n            ... = S(O) * S(O)     : by rw h\n            ... = S(O)            : by rw mul_one, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 25, "name": "one_pow", "statement": "(m : \u2115) : S(O) ^ m = S(O)"}, {"type": "lean", "content": "423", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "424", "hidden": true}, {"type": "lean", "content": "425", "hidden": true}, {"type": "lean", "content": "426", "hidden": true}, {"type": "lean", "content": "427", "hidden": true}, {"type": "lean", "content": "428", "hidden": true}, {"type": "text", "content": "429"}, {"type": "theorem", "text": "430", "lean": "theorem pow_add (m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 48, "textBefore": "import natural_numbers.one_pow -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 18: Raising to a power $a + b$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a + b} = m ^ a m ^ b$, for all natural numbers $b$.\n-/\n\n/- Theorem :\nFor all natural numbers $m$, $a$, and $b$, we have $m ^ {a + b} = m ^ a m ^ b$.\n-/\ntheorem pow_add (m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b :=\nbegin [pure_maths]\n", "proof": "  induction b,\n\n  case O :\n  { show m ^ (a + O) = m ^ a * m ^ O, calc\n    m ^ (a + O) = m ^ a             : by rw add_O\n            ... = (m ^ a) * (S O)   : by rw mul_one\n            ... = m ^ a * m ^ O     : by rw pow_O, },\n\n  case S : k h\n  { show m ^ (a + S(k)) = m ^ a * m ^ S(k),\n    given h : m ^ (a + k) = m ^ a * m ^ k,\n    calc\n    m ^ (a + S(k))  = m ^ (S(a + k))        : by rw add_S\n                ... = m ^ (a + k) * m       : by rw pow_S\n                ... = (m ^ a * m ^ k) * m   : by rw h\n                ... = m ^ a * (m ^ k * m)   : by rw mul_assoc\n                ... = m ^ a * (m ^ S(k))    : by rw pow_S, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 22, "editorText": "sorry", "lineOffset": 26, "name": "pow_add", "statement": "(m a b : \u2115) : m ^ (a + b) = m ^ a * m ^ b"}, {"type": "lean", "content": "431", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "432", "hidden": true}, {"type": "lean", "content": "433", "hidden": true}, {"type": "lean", "content": "434", "hidden": true}, {"type": "lean", "content": "435", "hidden": true}, {"type": "lean", "content": "436", "hidden": true}, {"type": "text", "content": "437"}, {"type": "theorem", "text": "438", "lean": "theorem pow_mul (m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 44, "textBefore": "import natural_numbers.pow_add -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 19: Raising to a power $ab$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a b} = (m ^ a) ^ b$, for all natural numbers $b$.\n-/\n\n/- Theorem :\nFor all natural numbers $m$, $a$, and $b$, we have $m ^ {a b} = (m ^ a) ^ b$.\n-/\ntheorem pow_mul (m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b :=\nbegin [pure_maths]\n", "proof": "  induction b,\n\n  case O :\n  { refl, },\n\n  case S : k h\n  { show m ^ (a * S(k)) = (m ^ a) ^ S(k),\n    given h : m ^ (a * k) = (m ^ a) ^ k,\n    calc\n    m ^ (a * S(k))  = m ^ (a * k + a)           : by rw mul_S\n                ... = m ^ (a * k) * m ^ a       : by rw pow_add\n                ... = (m ^ a) ^ k * m ^ a       : by rw h\n                ... = (m ^ a) ^ S(k)            : by rw pow_S, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 26, "name": "pow_mul", "statement": "(m a b : \u2115) : m ^ (a * b) = (m ^ a) ^ b"}, {"type": "lean", "content": "439", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "440", "hidden": true}, {"type": "lean", "content": "441", "hidden": true}, {"type": "lean", "content": "442", "hidden": true}, {"type": "lean", "content": "443", "hidden": true}, {"type": "lean", "content": "444", "hidden": true}, {"type": "text", "content": "445"}, {"type": "hint", "content": "446", "title": "447"}, {"type": "theorem", "text": "448", "lean": "theorem mul_pow (a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m) :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 53, "textBefore": "import natural_numbers.pow_mul -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 20: Powers of products\n\n## Task\n\nLet $a$ and $b$ be natural numbers. Prove that $(ab)^m = (a^m)(b^m)$,\nfor every natural number $m$.\n-/\n\n/- Hint : A time-saving tactic\nAt some point in the proof, you may find it helpful to use the `ac_refl` tactic \nor the `ring` tactic to easily show\na result that depends on commutativity and associativity of multiplication.\n-/\n\n/- Theorem :\nFor all natural numbers $a$, $b$, and $m$, we have $(ab)^m = (a^m)(b^m)$.\n-/\ntheorem mul_pow (a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m) :=\nbegin [pure_maths]\n", "proof": "  induction m,\n\n  case O :\n  { show (a * b) ^ O = (a ^ O) * (b ^ O), from rfl, },\n\n  case S : k h\n  { show (a * b) ^ S(k) = (a ^ S(k)) * (b ^ S(k)),\n    given h : (a * b) ^ k = (a ^ k) * (b ^ k),\n    calc\n    (a * b) ^ S(k) = (a * b) ^ k * (a * b)  : by rw pow_S\n    ... = (a ^ k) * (b ^ k) * (a * b)       : by rw h\n    ... = ((a ^ k) * a) * ((b ^ k) * b)     : by ac_refl\n    ... = (a ^ S(k)) * (b ^ S(k))           : rfl },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 32, "name": "mul_pow", "statement": "(a b m: \u2115) : (a * b) ^ m = (a ^ m) * (b ^ m)"}, {"type": "lean", "content": "449", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "450", "hidden": true}, {"type": "lean", "content": "451", "hidden": true}, {"type": "lean", "content": "452", "hidden": true}, {"type": "lean", "content": "453", "hidden": true}, {"type": "lean", "content": "454", "hidden": true}, {"type": "text", "content": "455"}, {"type": "lean", "content": "456", "hidden": true}, {"type": "lean", "content": "457", "hidden": false}, {"type": "text", "content": "458"}, {"type": "text", "content": "459"}, {"type": "axiom", "content": "460", "name": "fsum_O (f : \u2115 \u2192 \u2115) :", "sideBar": true}, {"type": "axiom", "content": "461", "name": "fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) :", "sideBar": true}, {"type": "text", "content": "462"}, {"type": "axiom", "content": "463", "name": "fsum_zero (n : \u2115) :", "sideBar": true}, {"type": "lean", "content": "464", "hidden": false}, {"type": "text", "content": "465"}, {"type": "theorem", "text": "466", "lean": "theorem fsum_const (c n : \u2115) : \u2211 i \u227a n, c = c * n :=\n", "sideBar": true, "firstProofLineNumber": 101, "lastProofLineNumber": 116, "textBefore": "import natural_numbers.mul_pow -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 21: Finite sums\n\nIn mathematics, the 'sigma' notation is used to represent sums. We may write\n$$\n\\sum_{i=0}^{10} i\n$$\nto represent the sum $0 + 1 + \\dots + 9 + 10$. Henceforth, as all our numbers are non-negative,\nwe'll omit the lower summation bound $0$.\n\nIn this book, we represent the same quantity as\n`\u2211 i \u227c 10, i`. Here, `\u2211` is typed `\\sum`, and `\u227c` is typed `\\preceq`.\n\nLikewise, the sum $\\sum_{i < 10} i$ is represented as `\u2211 i \u227a 10, i`, where `\u227a` is typed `\\prec`.\n\nFor example, one can prove (by reflexivity), that\n$$\\sum_{i \\le 4} i ^ 2 = 30.$$\n-/\n\nopen_locale fsum -- hide\n\nexample : \u2211 i \u227c 4, i ^ 2 = 30 :=\nbegin\n  from rfl,\nend\n\n/-\nMore generally, one can consider $\\sum_{i < n} f(i)$, for some function $f$. We'll define this by\ntwo principles: (1) $\\sum_{i < 0} f(i) := 0$ and (2)\n$\\sum_{i < \\mathsf S(n)} f(i) := \\sum_{i < n} f(i) + f(n)$.\n\nNote (2) may also be written as $\\sum_{i \\le n} f(i) := \\sum_{i < n} f(i) + f(n)$.\n-/\n\n\n/-\nThese definitions are available as the theorems `fsum_O` and `fsum_S`:\n\n`fsum_O (f : \u2115 \u2192 \u2115) : \u2211 i \u227a O, f(i) = O`\n\n`fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) : \u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)`\n-/\n\n/- Axiom : fsum_O (f : \u2115 \u2192 \u2115) :\n\u2211 i \u227a O, f(i) = O\n-/\n\n/- Axiom : fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)\n-/\n\n/-\nUsing these theorems, we can prove $\\sum_{i < n} 0 = 0$, for all natural numbers $n$.\n-/\n\n\n/- Axiom : fsum_zero (n : \u2115) :\n\u2211 i \u227a n, 0 = 0\n-/\nlemma fsum_zero (n : \u2115) : \u2211 i \u227a n, 0 = 0 :=\nbegin [pure_maths]\n  induction n,\n\n  case O :\n  { show \u2211 i \u227a 0, 0 = 0, from rfl, },\n\n  case S : k h\n  { show \u2211 i \u227c k, 0 = 0,\n    given h : \u2211 i \u227a k, 0 = 0,\n    calc\n    \u2211 i \u227c k, 0  = \u2211 i \u227a k, 0 + 0 : by rw fsum_S\n            ... = 0 + 0           : by rw h\n            ... = 0               : rfl, },\nend\n\n/-\n\n## Task\n\nLet $c : \\mathbb N$ be a constant.\nBy induction on $n$, prove that $\\sum_{i < n} c = cn$, for every natural number $n$.\n-/\n\n/- Theorem :\n$\\sum_{i < n} c = cn$, for all natural numbers $c$ and $n$.\n-/\ntheorem fsum_const (c n : \u2115) : \u2211 i \u227a n, c = c * n :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show \u2211 i \u227c k, c = c * S(k),\n    given h : \u2211 i \u227a k, c = c * k,\n    calc\n    \u2211 i \u227c k, c  = \u2211 i \u227a k, c + c : by rw fsum_S\n            ... = c * k + c       : by rw h\n            ... = c * S(k)        : by rw mul_S  },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nattribute [simp] fsum_const -- hide\n\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 100, "name": "fsum_const", "statement": "(c n : \u2115) : \u2211 i \u227a n, c = c * n"}, {"type": "lean", "content": "467", "hidden": true}, {"type": "lean", "content": "468", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "469", "hidden": true}, {"type": "lean", "content": "470", "hidden": true}, {"type": "lean", "content": "471", "hidden": true}, {"type": "lean", "content": "472", "hidden": true}, {"type": "lean", "content": "473", "hidden": true}, {"type": "text", "content": "474"}, {"type": "lean", "content": "475", "hidden": true}, {"type": "text", "content": "476"}, {"type": "hint", "content": "477", "title": "478"}, {"type": "hint", "content": "479", "title": "480"}, {"type": "hint", "content": "481", "title": "482"}, {"type": "theorem", "text": "483", "lean": "theorem triangle_sum (n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1) :=\n", "sideBar": true, "firstProofLineNumber": 66, "lastProofLineNumber": 84, "textBefore": "import natural_numbers.finite_sum -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 22: Triangular numbers\n-/\n\nopen_locale fsum -- hide\n\n\n/-\n\n## Task\n\nProve the formula for triangular numbers, that\n$$\n2\\left(\\sum_{i \\le n} i\\right) = n(n + 1),\n$$\nfor every natural number $n$.\n-/\n\n/- Hint : Cheap algebra\nRemember that the `ring` tactic can prove most equations.\n-/\n\n/- Hint : Converting from `S(k)` to `k + 1`\nThe equation `S(k) = k + 1` holds from `rfl`. Use this before\napplying the `ring` tactic.\n-/\n\n/- Hint : A proof template\nIf you're not sure how to get going, try the following proof template.\nFill in the `_` with an expression, add extra calculation lines and\ncomplete the final `sorry`.\n```\ninduction n,\n\ncase O :\n{ from rfl, },\n\ncase S : k h\n{ show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n  given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n  calc\n  2 * (\u2211 i \u227c S(k), i)\n      = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n  ... = (k + 1) * ((k + 1) + 1)        : sorry, }\n```\n\n-/\n\n/- Theorem :\n$2(\\sum_{i \\le n} i) = n(n + 1)$, for every natural number $n$.\n-/\ntheorem triangle_sum (n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n    given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n    calc\n    2 * (\u2211 i \u227c S(k), i)\n        = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n    ... = 2 * (\u2211 i \u227c k, i) + 2 * S(k)    : by rw mul_add\n    ... = k * (k + 1) + 2 * S(k)         : by rw h\n    ... = k * (k + 1) + 2 * (k + 1)      : rfl\n    ... = (k + 1) * ((k + 1) + 1)        : by ring, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 65, "name": "triangle_sum", "statement": "(n : \u2115) : 2 * (\u2211 i \u227c n, i) = n * (n + 1)"}, {"type": "lean", "content": "484", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "485", "hidden": true}, {"type": "lean", "content": "486", "hidden": true}, {"type": "lean", "content": "487", "hidden": true}, {"type": "lean", "content": "488", "hidden": true}, {"type": "lean", "content": "489", "hidden": true}, {"type": "text", "content": "490"}, {"type": "lean", "content": "491", "hidden": true}, {"type": "text", "content": "492"}, {"type": "theorem", "text": "493", "lean": "theorem sums_of_squares (n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1) :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 60, "textBefore": "import natural_numbers.triangle_numbers -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 23: Sums of squares\n-/\n\nopen_locale fsum -- hide\n\n\n/-\n\n## Task\n\nProve the formula for sums of squares, that\n$$\n6\\left(\\sum_{i \\le n} i^2\\right) = n(n + 1)(2n + 1),\n$$\nfor every natural number $n$.\n-/\n\n/- Theorem : no-side-bar\n$6(\\sum_{i \\le n} i^2) = n(n + 1)(2n + 1)$, for every natural number $n$.\n-/\ntheorem sums_of_squares (n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1) :=\nbegin [pure_maths]\n", "proof": "  induction n,\n\n  case O :\n  { from rfl, },\n\n  case S : k h\n  { show 6 * (\u2211 i \u227c S(k), i ^ 2) = S(k) * (S(k) + 1) * (2 * S(k) + 1),\n    given h : 6 * (\u2211 i \u227c k, i ^ 2) = k * (k + 1) * (2 * k + 1),\n    calc\n    6 * (\u2211 i \u227c S(k), i ^ 2) \n        =  6 * (\u2211 i \u227c k, i ^ 2 + (S(k)) ^ 2)            : by rw fsum_S\n    ... = 6 * (\u2211 i \u227c k, i ^ 2) + 6 * (S(k) ^ 2)         : by rw mul_add\n    ... = k * (k + 1) * (2 * k + 1) + 6 * (S(k) ^ 2)    : by rw h\n    ... = k * (k + 1) * (2 * k + 1) + 6 * ((k + 1) ^ 2) : rfl\n    ... = (k + 1) * ((k + 1) + 1) * (2 * (k + 1) + 1)   : by ring }\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 36, "name": "sums_of_squares", "statement": "(n : \u2115) :\n6 * (\u2211 i \u227c n, i ^ 2) = n * (n + 1) * (2 * n + 1)"}, {"type": "lean", "content": "494", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "495", "hidden": true}, {"type": "lean", "content": "496", "hidden": true}, {"type": "lean", "content": "497", "hidden": true}, {"type": "lean", "content": "498", "hidden": true}, {"type": "lean", "content": "499", "hidden": true}, {"type": "text", "content": "500"}, {"type": "lean", "content": "501", "hidden": true}, {"type": "text", "content": "502"}, {"type": "text", "content": "503"}, {"type": "hint", "content": "504", "title": "505"}, {"type": "theorem", "text": "506", "lean": "theorem fsum_S' (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O) :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 92, "textBefore": "import natural_numbers.sums_of_squares -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 24: Change of index in a sum\n-/\n\nopen_locale fsum -- hide\n\n/-\nBy *definition*, we have\n$$\n\\sum_{i \\le n} f(i) = \\left(\\sum_{i < n} f(i)\\right) + f(n),\n$$\ncorresponding to the intuition\n$$\nf(0) + f(1) + \\dots + f(n) = (f(0) + \\dots + f(n-1)) + f(n).\n$$\nOne should expect also that\n$$\nf(0) + f(1) + \\dots + f(n)  = f(0) + (f(1) \\dots  + f(n)),\n$$\nwhich can be written as\n$$\n\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0).\n$$\n\n\n\n-/\n\n/-\n\n## Task\n\nProve the claim above.\n-/\n\n/- Hint: A helpful result\nAt some point, you'll need to use a result of the form $(a + b) + c = (a + c) + b$.\nYou've proved a result that states exactly this earlier. Either use this theorem or use\none of the `ac_refl` or `ring` tactics.\n-/\n\n/- Theorem :\nFor any function $f : \\mathbb N \\to \\mathbb N$, we have \n$\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0)$,\nfor every natural number $n$.\n-/\ntheorem fsum_S' (f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O) :=\nbegin\n", "proof": "  induction n with k h,\n  { calc\n    \u2211 i \u227c O, f(i)\n        = \u2211 i \u227a O, f(i) + f(O)    : by rw fsum_S\n    ... = O + f(O)                : by rw fsum_O\n    ... = \u2211 i \u227a O, f(S(i)) + f(O) : by rw fsum_O,  },\n  { show \u2211 i \u227c S(k), f(i) = \u2211 i \u227a S(k), f(S(i)) + f(O),\n    given h : \u2211 i \u227c k, f(i) = \u2211 i \u227a k, f(S(i)) + f(O),\n    calc \n    \u2211 i \u227c S(k), f(i)\n        = \u2211 i \u227a S(k), f(i) + f(S(k))          : by rw fsum_S\n    ... = \u2211 i \u227a k, f(S(i)) + f(O) + f(S(k))   : by rw h\n    ... = (\u2211 i \u227a k, f(S(i)) + f(S(k))) + f(O) : by rw add_right_comm\n    ... = \u2211 i \u227a S(k), f(S(i)) + f(O)          : by rw fsum_S, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 31, "editorText": "sorry", "lineOffset": 61, "name": "fsum_S'", "statement": "(f : \u2115 \u2192 \u2115) (n : \u2115) :\n\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(S(i)) + f(O)"}, {"type": "lean", "content": "507", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "508", "hidden": true}, {"type": "lean", "content": "509", "hidden": true}, {"type": "lean", "content": "510", "hidden": true}, {"type": "lean", "content": "511", "hidden": true}, {"type": "lean", "content": "512", "hidden": true}, {"type": "text", "content": "513"}, {"type": "lean", "content": "514", "hidden": true}, {"type": "text", "content": "515"}, {"type": "theorem", "text": "516", "lean": "theorem mul_fsum (f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i) :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 56, "textBefore": "import natural_numbers.fsum_S_prime -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 25: Multiplying each term by a constant\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor any function $f : \\mathbb N \\to \\mathbb N$, for all natural numbers $x$ and $n$,\nprove that \n$$\nx\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i).\n$$\n-/\n\n/- Theorem :\nFor any function $f : \\mathbb N \\to \\mathbb N$, we have \n$x\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i)$,\nfor all natural numbers $x$ and $n$.\n-/\ntheorem mul_fsum (f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i) :=\nbegin\n", "proof": "  induction n with k h,\n  { show x * \u2211 i \u227a O, f(i) = \u2211 i \u227a O, x * f(i), from rfl, },\n  { show x * \u2211 i \u227a S(k), f(i) = \u2211 i \u227a S(k), x * f(i),\n    given h : x * \u2211 i \u227a k, f(i) = \u2211 i \u227a k, x * f(i),\n    calc\n    x * \u2211 i \u227a S(k), f(i)\n        = x * (\u2211 i \u227a k, f(i) + f(k))        : by rw fsum_S\n    ... = x * \u2211 i \u227a k, f(i) + x * f(k)      : by rw mul_add\n    ... = \u2211 i \u227a k, x * f(i) + x * f(k)      : by rw h\n    ... = \u2211 i \u227a S(k), x * f(i)              : by rw fsum_S, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 37, "name": "mul_fsum", "statement": "(f : \u2115 \u2192 \u2115) (x n : \u2115)  :\nx * \u2211 i \u227a n, f(i) = \u2211 i \u227a n, x * f(i)"}, {"type": "lean", "content": "517", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "518", "hidden": true}, {"type": "lean", "content": "519", "hidden": true}, {"type": "lean", "content": "520", "hidden": true}, {"type": "lean", "content": "521", "hidden": true}, {"type": "lean", "content": "522", "hidden": true}, {"type": "text", "content": "523"}, {"type": "lean", "content": "524", "hidden": true}, {"type": "text", "content": "525"}, {"type": "theorem", "text": "526", "lean": "theorem fsum_add_distrib (f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i) :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 71, "textBefore": "import natural_numbers.mul_fsum -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 26: Summing over sums\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),\n$$\nfor every natural number $n$.\n-/\n\n/- Theorem :\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),$\nfor all natural numbers $n$.\n-/\ntheorem fsum_add_distrib (f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i) :=\nbegin\n", "proof": "  induction n with k h,\n\n  case O :\n  { show \u2211 i \u227a 0, (f(i) + g(i)) = \u2211 i \u227a 0, f(i) + \u2211 i \u227a 0, g(i), from rfl },\n\n  case S : k h\n  { show \u2211 i \u227a S(k), (f(i) + g(i)) = \u2211 i \u227a S(k), f(i) + \u2211 i \u227a S(k), g(i),\n    given h : \u2211 i \u227a k, (f(i) + g(i)) = \u2211 i \u227a k, f(i) + \u2211 i \u227a k, g(i),\n    calc\n    \u2211 i \u227a S(k), (f(i) + g(i))\n        = \u2211 i \u227a k, (f(i) + g(i)) + (f(k) + g(k))            : rfl\n    ... = (\u2211 i \u227a k, f(i) + \u2211 i \u227a k, g(i)) + (f(k) + g(k))   : by rw h\n    ... = (\u2211 i \u227a k, f(i) + f(k)) + (\u2211 i \u227a k, g(i) + g(k))   : by ac_refl\n    ... = \u2211 i \u227a S(k), f(i) + \u2211 i \u227a S(k), g(i)               : by rw [fsum_S, fsum_S], },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 32, "editorText": "sorry", "lineOffset": 39, "name": "fsum_add_distrib", "statement": "(f g : \u2115 \u2192 \u2115) (n : \u2115)  :\n\u2211 i \u227a n, (f(i) + g(i)) = \u2211 i \u227a n, f(i) + \u2211 i \u227a n, g(i)"}, {"type": "lean", "content": "527", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "528", "hidden": true}, {"type": "lean", "content": "529", "hidden": true}, {"type": "lean", "content": "530", "hidden": true}, {"type": "lean", "content": "531", "hidden": true}, {"type": "lean", "content": "532", "hidden": true}, {"type": "text", "content": "533"}, {"type": "lean", "content": "534", "hidden": true}, {"type": "text", "content": "535"}, {"type": "hint", "content": "536", "title": "537"}, {"type": "hint", "content": "538", "title": "539"}, {"type": "theorem", "text": "540", "lean": "theorem fsum_mul_fsum (f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j) :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 77, "textBefore": "import natural_numbers.fsum_add_distrib -- hide\n\nset_option pp.structure_projections false -- hide\n\nnamespace exlean -- hide\n\nopen_locale mynum -- hide\n\nopen mynat -- hide\n\n/-\n# Natural numbers\n\n## Level 27: Multiplying sums\n-/\n\nopen_locale fsum -- hide\n\n/-\n\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)\n$$\nfor all natural numbers $m$ and $n$.\n-/\n\n/- Hint : Having trouble with the induction?\nThere's a painful way and an easy (or easier) way to prove this result. The \neasier way is to try induction on `m`, rather than induction on `n`.`\n-/\n\n/- Hint : A useful result\nAt some point in the proof, you'll need to use the results `mul_fsum` and `add_mul`.\n-/\n\n/- Theorem :\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)$,\nfor all natural numbers $n$.\n-/\ntheorem fsum_mul_fsum (f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j) :=\nbegin\n", "proof": "  induction m with k h,\n\n  case O :\n  { show (\u2211 (i : \u2115) \u227a O, f i) * \u2211 (j : \u2115) \u227a n, g j = \u2211 (i : \u2115) \u227a O, \u2211 (j : \u2115) \u227a n, f i * g j,\n    rw [fsum_O, fsum_O, O_mul], },\n\n  case S : k h\n  { show (\u2211 i \u227a S(k), f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a S(k), \u2211 j \u227a n, f(i) * g(j),\n    given h : (\u2211 i \u227a k, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j),\n    calc\n    (\u2211 i \u227a S(k), f(i)) * (\u2211 j \u227a n, g(j))\n        = (\u2211 i \u227a k, f(i) + f(k)) * (\u2211 j \u227a n, g(j))                      : by rw fsum_S\n    ... = (\u2211i \u227a k, f(i)) * (\u2211 j \u227a n, g(j)) + f(k) * (\u2211 j \u227a n, g(j))   : by rw add_mul\n    ... = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j) + f(k) * (\u2211 j \u227a n, g(j))      : by rw h\n    ... = \u2211 i \u227a k, \u2211 j \u227a n, f(i) * g(j) + \u2211 j \u227a n, f(k) * g(j)        : by rw mul_fsum\n    ... =  \u2211 i \u227a S(k), \u2211 j \u227a n, f(i) * g(j)                             : rfl, },\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 27, "editorText": "sorry", "lineOffset": 50, "name": "fsum_mul_fsum", "statement": "(f g : \u2115 \u2192 \u2115) (m n : \u2115)  :\n(\u2211 i \u227a m, f(i)) * (\u2211 j \u227a n, g(j)) = \u2211 i \u227a m, \u2211 j \u227a n, f(i) * g(j)"}, {"type": "lean", "content": "541", "hidden": true}]}], "parents": [0]}, {"name": "542", "levels": [{"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "543", "hidden": true}, {"type": "text", "content": "544"}, {"type": "axiom", "content": "545", "name": "and.elim_left (h : p \u2227 q) :", "sideBar": true}, {"type": "axiom", "content": "546", "name": "and.elim_right (h : p \u2227 q) :", "sideBar": true}, {"type": "lean", "content": "547", "hidden": false}, {"type": "text", "content": "548"}, {"type": "lean", "content": "549", "hidden": false}, {"type": "text", "content": "550"}, {"type": "lean", "content": "551", "hidden": false}, {"type": "tactic", "content": "552", "name": "cases", "sideBar": true}, {"type": "lean", "content": "553", "hidden": true}, {"type": "text", "content": "554"}, {"type": "theorem", "text": "555", "lean": "theorem decomposing_and (p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq :=\n", "sideBar": false, "firstProofLineNumber": 109, "lastProofLineNumber": 116, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\nHere, `h.left` is an abbreviation for `and.elim_left h`. Likewise for `h.right`.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n\nThe Lean proof is below.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n-/\n\n\n/- Axiom : and.elim_left (h : p \u2227 q) :\np\n-/\n\n/- Axiom : and.elim_right (h : p \u2227 q) :\nq\n-/\n\n\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  from h.right,\nend\n\n/-\nAlternatively, the `cases` tactic will decompose the `\u2227` into both the left and right sides.\nBelow `cases h with h\u2081 h\u2082` decomposes `h` into `h\u2081 : x > 0` and `h\u2082 : x * x = 16`.\n-/\n\nexample (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16  :=\nbegin\n  cases h with h\u2081 h\u2082,  \n  show x * x = 16, from h\u2082,\nend\n\n\n\n/-\nFrequently, we consider the conjunction of several statements. \nWe can, for instance, derive $q$ given the assumption $p \\land (q \\land r)$.\n-/\n\nexample (p q r : Prop) (h : p \u2227 (q \u2227 r)) : q :=\nbegin\n  have h\u2082 : q \u2227 r, from h.right,\n  show q, from h\u2082.left,\nend\n\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\nAdapt the proof of the example above.\n2. Write another Lean proof using `cases`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h : (r \\land (p \\land q)) \\land r$,\nwe have $q$.\n-/\ntheorem decomposing_and (p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq :=\nbegin\n", "proof": "  have h\u2082 : r \u2227 (p \u2227 q), from h.left,\n  have h\u2083 : p \u2227 q, from h\u2082.right,\n  show q, from h\u2083.right,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 108, "name": "decomposing_and", "statement": "(p q r : Prop) (h : (r \u2227 (p \u2227 q)) \u2227 r) :\nq"}, {"type": "lean", "content": "556", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "557", "hidden": true}, {"type": "text", "content": "558"}, {"type": "lean", "content": "559", "hidden": false}, {"type": "text", "content": "560"}, {"type": "lean", "content": "561", "hidden": false}, {"type": "lean", "content": "562", "hidden": true}, {"type": "text", "content": "563"}, {"type": "tactic", "content": "564", "name": "split", "sideBar": true}, {"type": "axiom", "content": "565", "name": "and.intro (h\u2081 : p) (h\u2082 : q) :", "sideBar": true}, {"type": "lean", "content": "566", "hidden": true}, {"type": "theorem", "text": "567", "lean": "theorem and_intro_thm (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\n", "sideBar": false, "firstProofLineNumber": 70, "lastProofLineNumber": 74, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 2: And introduction\n\n## And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and to prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n-/\n\nexample (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n\n/-\nThe `split` tactic is an alternative (backward) proof technique. If the target is to prove `p \u2227 q`,\nthen `split` replaces the goal with two new goals: (1) to prove `p` and (2) to prove `q`.\n-/\n\nexample (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  split,\n  { show p, from h\u2081, }, -- The first goal.\n  { show q, from h\u2082, }, -- The second goal.\nend\n\n\nnamespace exlean -- hide\n/-\n## Tasks\n\n1. Replace `sorry` below with a Lean proof using `and.intro`.\n2. Write another Lean proof using `split`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n-/\n\n/- Tactic : split\n\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n-/\n\n\n/- Axiom: and.intro (h\u2081 : p) (h\u2082 : q) :\np \u2227 q\n-/\n\nvariables (p q r : Prop) -- hide\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : r \\land q$.\n-/\ntheorem and_intro_thm (h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q :=\nbegin\n", "proof": "  split,\n  { show r, from h\u2083, },\n  { show q, from h\u2082, },\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 69, "name": "and_intro_thm", "statement": "(h\u2081 : p) (h\u2082 : q) (h\u2083 : r) : r \u2227 q"}, {"type": "lean", "content": "568", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "569", "hidden": true}, {"type": "text", "content": "570"}, {"type": "lean", "content": "571", "hidden": true}, {"type": "lean", "content": "572", "hidden": true}, {"type": "text", "content": "573"}, {"type": "theorem", "text": "574", "lean": "theorem and.swap (h : p \u2227 q) : q \u2227 p :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 38, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 3: And swap\n\n-/\n\nnamespace exlean -- hide\n\nvariables {p q : Prop} -- hide\n\n/-\n## Task\n\nIntuitively, you'd expect that if you have $h : p \\land q$, then you can derive $q \\land p$.\nIn this level, you'll do just that!\n\nRecall you can:\n* use `cases`, or `.left` and `.right` for and elimination and\n* use `split` or `and.intro` for and introduction.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Assuming $h : p \\land q$, we have $h : q \\land p$.\n-/\ntheorem and.swap (h : p \u2227 q) : q \u2227 p :=\nbegin\n", "proof": "  split,\n  { show q, from h.right, },\n  { show p, from h.left, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 28, "name": "and.swap", "statement": "(h : p \u2227 q) : q \u2227 p"}, {"type": "lean", "content": "575", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "576", "hidden": true}, {"type": "text", "content": "577"}, {"type": "lean", "content": "578", "hidden": true}, {"type": "lean", "content": "579", "hidden": false}, {"type": "text", "content": "580"}, {"type": "lean", "content": "581", "hidden": false}, {"type": "text", "content": "582"}, {"type": "lean", "content": "583", "hidden": false}, {"type": "lean", "content": "584", "hidden": true}, {"type": "text", "content": "585"}, {"type": "theorem", "text": "586", "lean": "theorem imp_elim_example (h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 70, "textBefore": "import propositional_logic.and_swap -- hide\n\n/-\n# Propositional logic\n## Level 4: Implication elimination\n\nGiven proofs of $p \\to q$ ($p$ implies $q$) and $p$, you know $q$. This is *implication elimination*,\nsometimes called *modus ponens*.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : p` is a proof of `p`, then `h\u2081 h\u2082` is a proof\nof `q`.\n\n**Notation**: The symbol `\u2192` is typed `\\r`.\n-/\n\nvariables (p q r : Prop) -- hide\n\nexample (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  from h\u2081 h\u2082\nend\n\n/-\nThe `apply` tactic permits us to do implication elimination backward.\nThat is, if the target is to prove `q` and if we have a hypothesis `h : p \u2192 q`, then\n`apply h` replaced the target with one of proving `q`.\n\nThis corresponds to the idea that if we know $p \\to q$ then to prove $q$, it suffices to prove $p$.\n-/\n\n\nexample (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  apply h\u2081, -- The target now becomes \u22a2 q,\n  from h\u2082\nend\n\n/-\nAs another example, we'll prove $r$ on the assumptions $h_1 : p \\to (q \\land r)$ and $h_2 : p$.\n-/\n\nexample (h\u2081 : p \u2192 (q \u2227 r)) (h\u2082 : p) : r :=\nbegin\n  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show r, from h\u2083.right,\nend\n\nnamespace exlean -- hide\n/-\n## Task\n\nProve the following result in Lean.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h_1 : p \\to q \\land r$ and $h_2 : p$, we have $q$.\n-/\ntheorem imp_elim_example (h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q :=\nbegin\n", "proof": "  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show q, from h\u2083.left,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 60, "name": "imp_elim_example", "statement": "(h\u2081 : p \u2192 q \u2227 r) (h\u2082 : p) : q"}, {"type": "lean", "content": "587", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "588", "hidden": true}, {"type": "text", "content": "589"}, {"type": "lean", "content": "590", "hidden": true}, {"type": "lean", "content": "591", "hidden": false}, {"type": "lean", "content": "592", "hidden": true}, {"type": "text", "content": "593"}, {"type": "axiom", "content": "594", "name": "id {p} :", "sideBar": true}, {"type": "lean", "content": "595", "hidden": true}, {"type": "lean", "content": "596", "hidden": false}, {"type": "lean", "content": "597", "hidden": true}, {"type": "lean", "content": "598", "hidden": true}, {"type": "text", "content": "599"}, {"type": "lean", "content": "600", "hidden": false}, {"type": "text", "content": "601"}, {"type": "theorem", "text": "602", "lean": "theorem imp_intro_example : (p \u2227 q) \u2192 p :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Propositional logic\n## Level 5: Implication introduction\n\nTo prove $p \\to q$ is to assume $p$ and derive $q$.\n\nIn Lean, if the target is `p \u2192 q`, typing `assume h : p` introduces `h : p` into the context\nand replaces the target with one of proving `q`.\n\nHere, we prove $(p \\land q) \\to p$.\n-/\n\nvariables (p q : Prop) -- hide\n\nexample : (p \u2227 q) \u2192 p :=\nbegin\n  assume h : p \u2227 q,\n  show p, from h.left,\nend\n\nnamespace hidden -- hide\n\n/-\nA useful result, `id` asserts that `s \u2192 s`, for any `s`.\n-/\n\n/- Axiom : id {p} :\np \u2192 p\n-/\n\nvariable (s : Prop) -- hide\n\nlemma id : s \u2192 s :=\nbegin\n  assume h : s,\n  show s, from h,\nend\n\n\nend hidden -- hide\n\nnamespace exlean -- hide\n\n/-\nIn the fun example below, we prove $p \\to (q \\to p)$.\n-/\n\nexample : p \u2192 (q \u2192 p) :=\nbegin\n  assume h\u2081 : p,\n  show q \u2192 p,\n  assume h\u2082 : q,\n  show p, from h\u2081,\nend\n\n\n/-\n## Task\n\nProve the following result in Lean.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $(p \\land q) \\to p$.\n-/\ntheorem imp_intro_example : (p \u2227 q) \u2192 p :=\nbegin\n", "proof": "  assume h : p \u2227 q,\n  show p, from h.left,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 70, "name": "imp_intro_example", "statement": "(p \u2227 q) \u2192 p"}, {"type": "lean", "content": "603", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "604", "hidden": true}, {"type": "text", "content": "605"}, {"type": "lean", "content": "606", "hidden": true}, {"type": "lean", "content": "607", "hidden": true}, {"type": "axiom", "content": "608", "name": "not_not_intro (p : Prop)", "sideBar": true}, {"type": "lean", "content": "609", "hidden": false}, {"type": "text", "content": "610"}, {"type": "lean", "content": "611", "hidden": false}, {"type": "text", "content": "612"}, {"type": "theorem", "text": "613", "lean": "theorem mt : (p \u2192 q) \u2192 (\u00acq \u2192 \u00acp) :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 82, "textBefore": "import propositional_logic.imp_intro -- hide\n\n/-\n# Propositional logic\n## Level 6: Proving negations\n\nGiven a proposition $p$, we write $\\neg p$ to mean 'not $p$'. Thus, $\\neg (x = 5)$ is the same as\n$x \\ne 5$. Formally, $\\neg p$ is an abbreviation for $p\\to\\bot$, where $\\bot$ is read 'false'\nor 'contradiction'.\n\nWe've seen that to prove $p \\to q$ is to assume $p$ and derive $q$. Thus, to prove $\\neg p$ is to\nassume $p$ and derive $\\bot$.\n\n**Notation**: The symbol `\u00ac` is typed `\\n` or `\\not`. The mathematical symbol $\\bot$ is written\n`false` in Lean.\n\nUsing these ideas, we'll prove $p \\to \\neg\\neg p$.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/- Axiom : not_not_intro (p : Prop)\np \u2192 \u00ac\u00acp\n-/\nlemma not_not_intro : p \u2192 \u00ac\u00acp :=\nbegin \n  assume h\u2081 : p,\n  show \u00ac\u00acp,\n  show \u00acp \u2192 false,\n  assume h\u2082 : \u00acp, -- So h\u2082 : p \u2192 false\n  show false, from h\u2082 h\u2081,\nend\n\n/-\nImplication elimination is used in the last line of the proof above. Lean permits *backward*\nimplication elimination via the `apply` tactic.\nIf the target is to prove `q` and if `h : p \u2192 q`, then typing `apply h`, transforms\nthe target to one of proving `p`.\n\nBelow, we prove $r$ on the assumptions $h_1 : (p \\land q) \\to r)$, $h_2 : p$ and $h_3 : q$.\nThe first step is to realise that $r$ is the 'conclusion' of $h_1$, whence `apply h\u2081` transforms\nthe goal to one of proving $p \\land q$.\n-/\n\nexample (h\u2081 : (p \u2227 q) \u2192 r) (h\u2082 : p) (h\u2083 : q) : r :=\nbegin\n  apply h\u2081,\n  show p \u2227 q, from and.intro h\u2082 h\u2083,\nend\n\n/-\n## Task\n\nProve the logical principle that $\\neg q \\to \\neg p$ follows from $p \\to q$. This is\nsometimes called *modus tollens*.\n\nYou'll need to perform implication introduction three times and implication elimination twice.\nFor fun, try both formward and backward implication elimination.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg q \\to \\neg p)$.\n-/\ntheorem mt : (p \u2192 q) \u2192 (\u00acq \u2192 \u00acp) :=\nbegin\n", "proof": "  assume h\u2081 : p \u2192 q,\n  show \u00acq \u2192 \u00ac p,\n  assume h\u2082 : \u00acq, -- So h\u2082 : q \u2192 false\n  show \u00acp,\n  show p \u2192 false,\n  assume h\u2083 : p,\n  show false,\n  have h\u2084 : q, from h\u2081 h\u2083,\n  show false, from h\u2082 h\u2084,\n/-   apply h\u2082,\n  show q, from h\u2081 h\u2083,\n -/\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 68, "name": "mt", "statement": "(p \u2192 q) \u2192 (\u00acq \u2192 \u00acp)"}, {"type": "lean", "content": "614", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "615", "hidden": true}, {"type": "text", "content": "616"}, {"type": "lean", "content": "617", "hidden": true}, {"type": "lean", "content": "618", "hidden": true}, {"type": "lean", "content": "619", "hidden": false}, {"type": "lean", "content": "620", "hidden": true}, {"type": "lean", "content": "621", "hidden": false}, {"type": "text", "content": "622"}, {"type": "lean", "content": "623", "hidden": false}, {"type": "axiom", "content": "624", "name": "or.inl", "sideBar": true}, {"type": "axiom", "content": "625", "name": "or.inr", "sideBar": true}, {"type": "tactic", "content": "626", "name": "left", "sideBar": true}, {"type": "tactic", "content": "627", "name": "right", "sideBar": true}, {"type": "text", "content": "628"}, {"type": "lean", "content": "629", "hidden": false}, {"type": "text", "content": "630"}, {"type": "lean", "content": "631", "hidden": false}, {"type": "text", "content": "632"}, {"type": "theorem", "text": "633", "lean": "theorem or_intro_example (h : q) : (p \u2228 q) \u2228 r :=\n", "sideBar": false, "firstProofLineNumber": 99, "lastProofLineNumber": 104, "textBefore": "import propositional_logic.proving_negation -- hide\n\n/-\n# Propositional logic\n## Level 7: Or introduction\n\nThe proposition $p \\lor q$ has the informal meaning '$p$ or $q$'. To prove $p \\lor q$ is:\n1. [left or introduction] to prove $p$ or`\n2. [right or introduction] to prove $q$.\n\nIn Lean, suppose `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`. Then\n`or.inl h\u2081` is a proof of `p \u2228 q` and `or.inr h\u2082` is a proof of `p \u2228 q`.\n\n**Notation**: `\u2228` is typed `\\or`.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\nexample (h\u2081 : p) : p \u2228 q :=\nbegin\n  from or.inl h\u2081,\nend\n\n-- hide\n\nexample (h\u2082 : q) : p \u2228 q :=\nbegin\n  from or.inr h\u2082,\nend\n\n\n/-\nFor example, we'll prove `p \u2228 (q \u2227 r)` given `h : p`.\n-/\nexample (h : p) : p \u2228 (q \u2227 r) :=\nbegin\n  from or.inl h,\nend\n\n/- Axiom: or.inl\n  (h : p) : p \u2228 q\n-/\n\n/- Axiom: or.inr\n  (h : q) : p \u2228 q\n-/\n\n\n/- Tactic : left\n`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n-/\n\n/- Tactic : right\n`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n-/\n\n/-\nAs a backward alternative, if the target is to prove `p \u2228 q`, the `left` tactic replaces the target\nwith one of proving `p`. Likewise for the `right` tactic.\n\nHere is a backward proof that $q \\lor (p \\lor r)$ follows from $h : p$.\n-/\n\nexample (h : p) : q \u2228 (p \u2228 r) :=\nbegin \n  show q \u2228 (p \u2228 r),\n  right,\n  show p \u2228 r,\n  left,\n  show p, from h,\nend\n\n/-\nTo prove the same result forward involves the introduction of hypotheses.\n-/\n\nexample (h : p) : q \u2228 (p \u2228 r) :=\nbegin\n  have h\u2082 : p \u2228 r, from or.inl h,\n  show q \u2228 (p \u2228 r), from or.inr h\u2082,\nend\n\n\n/-\n## Task\n\nProve the following in Lean and by hand.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $(p \\lor q) \\lor r$ follows from the assumption\n$h : q$.\n-/\ntheorem or_intro_example (h : q) : (p \u2228 q) \u2228 r :=\nbegin\n", "proof": "  have h\u2082 : p \u2228 q, from or.inr h,\n  show (p \u2228 q) \u2228 r, from or.inl h\u2082,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 98, "name": "or_intro_example", "statement": "(h : q) : (p \u2228 q) \u2228 r"}, {"type": "lean", "content": "634", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "635", "hidden": true}, {"type": "text", "content": "636"}, {"type": "lean", "content": "637", "hidden": true}, {"type": "lean", "content": "638", "hidden": true}, {"type": "axiom", "content": "639", "name": "or.swap (h : p \u2228 q)", "sideBar": true}, {"type": "lean", "content": "640", "hidden": false}, {"type": "text", "content": "641"}, {"type": "theorem", "text": "642", "lean": "theorem or_elim_example (h : (p \u2227 q) \u2228 (r \u2227 p)) : p :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 72, "textBefore": "import propositional_logic.or_introduction -- hide\n\n/-\n# Propositional logic\n## Level 8: Or elimination\n\nSuppose you are given $h : p \\lor q$. To prove $r$ is to\n1. Assume $p$ and derive $r$ and (separately) to\n2. assume $q$ and derive $r$.\n\nThis is (backward) *or elimination*.\n\nFor example, we prove $q \\lor p$ on the assumption $h : p \\lor q$.\n\n**Proof**:\n1. Assume $h_2 : p$. We must show $q \\lor p$. This follows from right or introduction on $h_2$.\n2. Assume $h_3 : q$. We must show $q \\lor p$. This follows from left or introduction on $h_3$.\n\n\nIn Lean, the `cases` tactic performs backward or elimination. With hypotheses as above,\n`cases h with h\u2082 h\u2083` creates two new goals:\n1. to prove `r` under the assumption `h\u2082 : p` and, separately\n2. to prove `r` under the assumption `h\u2083 : q`.\n\nHere is a Lean proof of the result above.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/- Axiom : or.swap (h : p \u2228 q)\nq \u2228 p\n-/\nlemma or.swap (h : p \u2228 q) : q \u2228 p :=\nbegin\n  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p,\n    show q \u2228 p, from or.inr h\u2082, },\n  { given h\u2083 : q,\n    show q \u2228 p, from or.inl h\u2083, },\nend\n\n\n/-\n## Task\n\nProve the following in Lean and by hand. For the adventurous, see the end of this level for discussion\nof *forward* or elimination. Come back and try a forward argument of this result.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $p$ follows from the assumption\n$h : (p \\land q) \\lor (r \\land p)$.\n-/\ntheorem or_elim_example (h : (p \u2227 q) \u2228 (r \u2227 p)) : p :=\nbegin\n", "proof": "  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p \u2227 q,\n    show p, from h\u2082.left, },\n  { given h\u2083 : r \u2227 p,\n    show p, from h\u2083.right, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\n## Forward or elimination\n\nI find it simplest to use or elimination in its backward form. For the sake of completeness, I\ninclude the forward version.\n\nLet $h : p \\lor q$ be a proof of $p \\lor q$, $h_1 : p \\to r$ a proof of $p \\to r$ and let $h_2 : q \\to r$ be a proof of $q \\to r$.\nThen (forward) *or elimination* applied to $h$, $h_1$, and $h_2$ is a proof of $r$.\n\nThe Lean name of the formard or elimination result is `or.elim`. Below, we use it to re-prove `or.swap`.\n-/\n\n/- Axiom : or.elim (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) :\nr\n-/\n\nexample  (h : p \u2228 q) : q \u2228 p :=\nbegin\n  have h\u2081 : p \u2192 (q \u2228 p),\n  { assume k : p,\n    show q \u2228 p, from or.inr k, },\n  -- hide\n  have h\u2082 : q \u2192 (q \u2228 p),\n  { assume k : q,\n    show q \u2228 p, from or.inl k,  },\n  -- hide\n  show q \u2228 p, from or.elim h h\u2081 h\u2082,\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 58, "name": "or_elim_example", "statement": "(h : (p \u2227 q) \u2228 (r \u2227 p)) : p"}, {"type": "text", "content": "643"}, {"type": "axiom", "content": "644", "name": "or.elim (h : p \u2228 q) (h\u2081 : p \u2192 r) (h\u2082 : q \u2192 r) :", "sideBar": true}, {"type": "lean", "content": "645", "hidden": false}, {"type": "lean", "content": "646", "hidden": true}, {"type": "lean", "content": "647", "hidden": false}, {"type": "lean", "content": "648", "hidden": true}, {"type": "lean", "content": "649", "hidden": false}, {"type": "lean", "content": "650", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "651", "hidden": true}, {"type": "text", "content": "652"}, {"type": "axiom", "content": "653", "name": "iff.elim_left (h : p \u2194 q) :", "sideBar": true}, {"type": "axiom", "content": "654", "name": "iff.elim_right (h : p \u2194 q) :", "sideBar": true}, {"type": "lean", "content": "655", "hidden": true}, {"type": "lean", "content": "656", "hidden": true}, {"type": "text", "content": "657"}, {"type": "lean", "content": "658", "hidden": false}, {"type": "text", "content": "659"}, {"type": "lean", "content": "660", "hidden": false}, {"type": "text", "content": "661"}, {"type": "theorem", "text": "662", "lean": "theorem iff_elim_example1 (h : p \u2194 (q \u2227 r)) (k : p) : q :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 82, "textBefore": "import propositional_logic.or_elimination -- hide\n\n/-\n# Propositional logic\n## Level 9: Iff elimination\n\nThe proposition $p \\leftrightarrow q$ represents the informal notation '$p$ if and only if $q$'.\n\nSuppose you are given `h : p \u2194 q` Then\n1. [left iff elimination] `h.mp` is a proof of `p \u2192 q` and\n2. [right iff elimination] `h.mpr` is a proof of `q \u2192 p`.\n\nHere, `h.mp` is an abbreviation of `iff.elim_left`. Likewise for `h.mpr`.\n\n**Notation**: `\u2194` is typed `\\iff`.\n\nUsing this, we'll prove $p$ on the assumptions $h_1 : p \\leftrightarrow q$ and $h_2 : q$.\n\n**Proof**:\nWe have $h_3 : q \\to p$ by right iff elimination on $h_1$.\nFrom $h_3$, it suffices to show $q$, which follows from $h_2$.\n-/\n\n/- Axiom : iff.elim_left (h : p \u2194 q) :\np \u2192 q\n-/\n\n/- Axiom : iff.elim_right (h : p \u2194 q) :\nq \u2192 p\n-/\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/-\nThe same result may be proved in Lean.\n-/\n\nexample (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  have h\u2083 : q \u2192 p, from iff.elim_right h\u2081,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n\n\n/-\nAlternatively, the `cases` tactic (much as for and elimination) decomposes `h : p \u2194 q` into proofs\nof `p \u2192 q` and `q \u2192 p`. We use this below and also \n-/\n\nexample (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  cases h\u2081 with k h\u2083,\n  given h\u2083 : q \u2192 p,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n\n/-\n## Task\n\nProve the following in Lean and by hand. Use either forward or backward iff elimination.\n-/\n\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Then $q$ follows from the assumptions\n$h : p \\leftrightarrow (q \\land r)$ and $k : p$.\n-/\ntheorem iff_elim_example1 (h : p \u2194 (q \u2227 r)) (k : p) : q :=\nbegin\n", "proof": "  cases h with h\u2081 h\u2082,\n  given h\u2081 : p \u2192 q \u2227 r,\n  have h\u2082 : q \u2227 r, from h\u2081 k,\n  show q, from h\u2082.left,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 72, "name": "iff_elim_example1", "statement": "(h : p \u2194 (q \u2227 r)) (k : p) : q"}, {"type": "lean", "content": "663", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "664", "hidden": true}, {"type": "text", "content": "665"}, {"type": "axiom", "content": "666", "name": "iff.intro (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) :", "sideBar": true}, {"type": "lean", "content": "667", "hidden": true}, {"type": "lean", "content": "668", "hidden": true}, {"type": "lean", "content": "669", "hidden": false}, {"type": "text", "content": "670"}, {"type": "axiom", "content": "671", "name": "and.comm :", "sideBar": true}, {"type": "lean", "content": "672", "hidden": false}, {"type": "text", "content": "673"}, {"type": "lean", "content": "674", "hidden": false}, {"type": "text", "content": "675"}, {"type": "theorem", "text": "676", "lean": "theorem or.comm {p q : Prop} : p \u2228 q \u2194 q \u2228 p :=\n", "sideBar": true, "firstProofLineNumber": 68, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.iff_elimination -- hide\n\n/-\n# Propositional logic\n## Level 10: Iff introduction\n\nTo *prove* $p\\leftrightarrow q$ is to prove $p \\to q$ and to prove $q \\to p$.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : q \u2192 p` is a proof of `q \u2192 p`, then\n`iff.intro h\u2081 h\u2082` is a proof of `p \u2194 q`.\n\nNote the similarities between `\u2227` and `\u2194`.\n-/\n\n/- Axiom : iff.intro (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) :\np \u2194 q\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\nexample (p q : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) : p \u2194 q :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\nRecall we earlier proved `and.swap` which gives `q \u2227 p` from `p \u2227 q`.\nWe'll use this to prove `(a \u2227 b) \u2194 (b \u2227 a)`.\n-/\n\n/- Axiom : and.comm :\na \u2227 b \u2194 b \u2227 a \n-/\nlemma and.comm {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  have h\u2081 : a \u2227 b \u2192 b \u2227 a, from and.swap,\n  have h\u2082 : b \u2227 a \u2192 a \u2227 b, from and.swap,\n  show a \u2227 b \u2194 b \u2227 a, from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\nAs with `\u2227` introduction, the `split` tactic changes a goal of proving `p \u2194 q` into two\nnew goals: (1) to prove `p \u2192 q` and (2) to prove `q \u2192 p`. This is backward iff introduction.\n-/\n\nexample {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  split,\n  { show (a \u2227 b) \u2192 (b \u2227 a), from and.swap, },\n  { show (b \u2227 a) \u2192 (a \u2227 b), from and.swap, }, \nend\n/-\n## Task\n\nProve the commutativity of `\u2228` in Lean and by hand.\n-/\n\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(p \\lor q) \\leftrightarrow (q \\lor p)$.\n-/\ntheorem or.comm {p q : Prop} : p \u2228 q \u2194 q \u2228 p :=\nbegin\n", "proof": "  split,\n  { show (p \u2228 q) \u2192 (q \u2228 p), from or.swap, },\n  { show (q \u2228 p) \u2192 (p \u2228 q), from or.swap, },\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 67, "name": "or.comm", "statement": "{p q : Prop} : p \u2228 q \u2194 q \u2228 p"}, {"type": "lean", "content": "677", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "678", "hidden": true}, {"type": "text", "content": "679"}, {"type": "axiom", "content": "680", "name": "trivial :", "sideBar": true}, {"type": "lean", "content": "681", "hidden": false}, {"type": "text", "content": "682"}, {"type": "axiom", "content": "683", "name": "false.elim (h : false) :", "sideBar": true}, {"type": "lean", "content": "684", "hidden": true}, {"type": "lean", "content": "685", "hidden": false}, {"type": "lean", "content": "686", "hidden": true}, {"type": "text", "content": "687"}, {"type": "theorem", "text": "688", "lean": "def absurd {p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 62, "textBefore": "import propositional_logic.iff_introduction -- hide\n\n/-\n# Propositional logic\n## Level 11: True and false\n\nWe have two propositional constants, $\\top$ and $\\bot$, written as \n`true` and `false` in Lean.\n\nThere's not much to say about $\\top$. It's always true. The proof of this is `trivial`, also called\n*true introduction*.\n-/\n\n/- Axiom : trivial :\ntrue\n-/\n\nexample : true :=\nbegin\n  from trivial,\nend\n\n/-\nFalse ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n-/\n\n/- Axiom : false.elim (h : false) :\np\n-/\n\nuniverse u -- hide\n\nexample (p : Sort u) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n\nnamespace exlean -- hide\n\n/-\n## Task\n\nRecall that $\\neg p$ is shorthand for $p \\to \\bot$ (or `p \u2192 false` in Lean notation).\n\nUse this to prove that anything follows from the assumptions of $p$ and $\\neg p$.\n-/\n\n/- Theorem : no-side-bar\nLet $p$ and $q$ be propositions. Then $q$ follows from $h_1 : p$ and\n$h_2 : \\neg p$.\n-/\ndef absurd {p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q :=\nbegin\n", "proof": "  have h : false, from h\u2082 h\u2081,\n  show q, from false.elim h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 57, "name": "absurd", "statement": "{p : Prop} {q : Sort u} (h\u2081 : p) (h\u2082 : \u00acp) : q"}, {"type": "lean", "content": "689", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "690", "hidden": true}, {"type": "text", "content": "691"}, {"type": "axiom", "content": "692", "name": "em (p : Prop):", "sideBar": true}, {"type": "lean", "content": "693", "hidden": true}, {"type": "lean", "content": "694", "hidden": false}, {"type": "lean", "content": "695", "hidden": true}, {"type": "lean", "content": "696", "hidden": true}, {"type": "text", "content": "697"}, {"type": "axiom", "content": "698", "name": "by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) :", "sideBar": true}, {"type": "lean", "content": "699", "hidden": false}, {"type": "tactic", "content": "700", "name": "by_cases", "sideBar": true}, {"type": "text", "content": "701"}, {"type": "lean", "content": "702", "hidden": false}, {"type": "text", "content": "703"}, {"type": "tactic", "content": "704", "name": "by_contra", "sideBar": true}, {"type": "theorem", "text": "705", "lean": "theorem by_contra (h : \u00acp \u2192 false) : p :=\n", "sideBar": true, "firstProofLineNumber": 104, "lastProofLineNumber": 114, "textBefore": "import propositional_logic.true_and_false tactic.localized -- hide\n\n/-\n# Propositional logic\n## Level 12: Law of the excluded middle, proof by cases, proof by contradiction\n\nGiven a proposition $p$, the law of the excluded middle is the assertion $p \\lor \\neg p$.\n\nIn Lean, if `p : Prop`, then `em p` is the assertion `p \u2228 \u00acp`.\n-/\n\n/- Axiom : em (p : Prop):\np \u2228 \u00acp\n-/\n\nopen_locale classical -- hide\n\nexample (p : Prop) : p \u2228 \u00acp :=\nbegin\n  from em p,\nend\n\nnamespace exlean -- hide\n\nvariables {p q : Prop} -- hide\n\n/-\nFrom the law of the excluded middle, we derive a proof method called 'proof by cases'.\nNamely, to prove $q$, it suffices to prove $p \\to q$ and $\\neg p \\to q$.\n\nThe first step of the proof is to deduce $h : p \\lor \\neg p$, by the law of the\nexcluded middle. The rest of the proof follows by or elimination on $h$.\n\n-/\n\n/- Axiom : by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) :\nq\n-/\n\ntheorem by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show q, from h\u2081 k\u2081, },\n  { given k\u2082 : \u00acp,\n    show q, from h\u2082 k\u2082, },\nend\n\n/- Tactic : by_cases\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses.\nFor example, if you write `by_cases h : p`, then Lean creates two new goals\n(1) to prove the target under the assumption\n`h : p` and (2) separately to prove the target under the assumption `h : \u00acp`.\n\n-/\n\n/-\nThis is such a useful theorem that Lean provides a `by_cases` tactic to help write\nbackward proofs by cases. It's best illustrated by example.\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses\n(here, we used `k`). The tactic creates two new goals (1) to prove the target under the assumption\n`k : p` and (2) separately to prove the target under the assumption `k : \u00acp`.\n-/\n\nexample (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  by_cases k : p,\n  { given k : p,\n    show q, from h\u2081 k, },\n  { given k : \u00acp,\n    show q, from h\u2082 k, },\nend\n\n/-\n## Tasks\n\nProof by contradiction asserts that to prove $p$, it suffices to show that $\\neg p$ leads to a\ncontradiction. Equally, to prove $(\\neg p \\to \\bot) \\to p$.\n\n1. Your first task is to complete the result below, the principle of 'proof by contradiction',\nusing any of the methods shown above (law of the excluded middle, the proof by cases theorem or the proof\nby cases tactic).\n2. Lean offers a `by_contra` tactic to help write backward proofs by contradiction.\nProve the theorem below by starting with `by_contra k`. This introduces the hypothesis `k : \u00acp`\nand makes proving `false` the target.\n\n-/\n\n/- Tactic : by_contra\n\nProof by contradiction. If the target is to prove `p`, using the tactic `by_contra h` will introduce the hypothesis `h : p`\nand change the target to one of proving `false`. \n-/\n\n\n/- Theorem :\nProof by contradiction. Given a proposition $p$, we have $\\neg \\neg p \\to \\bot$.\n-/\ntheorem by_contra (h : \u00acp \u2192 false) : p :=\nbegin\n", "proof": "  show p,\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show p, from k\u2081, },\n  { given k\u2082 : \u00acp,\n    show p, from absurd k\u2082 h, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 103, "name": "by_contra", "statement": "(h : \u00acp \u2192 false) : p"}, {"type": "lean", "content": "706", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "707", "hidden": true}, {"type": "text", "content": "708"}, {"type": "lean", "content": "709", "hidden": true}, {"type": "lean", "content": "710", "hidden": true}, {"type": "text", "content": "711"}, {"type": "text", "content": "712"}, {"type": "lean", "content": "713", "hidden": false}, {"type": "text", "content": "714"}, {"type": "axiom", "content": "715", "name": "not_not {p : Prop} :", "sideBar": true}, {"type": "lean", "content": "716", "hidden": false}, {"type": "text", "content": "717"}, {"type": "theorem", "text": "718", "lean": "theorem prop_ext_example : q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 91, "textBefore": "import propositional_logic.lem -- hide\n\n/-\n# Propositional logic\n## Level 13: Propositional extensionality\n\nLet $\\alpha$ and $\\beta$ be propositions. Suppose $\\alpha\\leftrightarrow\\beta$. Then anything that holds for $\\alpha$ holds for $\\beta$\nand vice-versa. This is called *propositional extensionality*.\n\nUsing propositional extensionality is similar to using `rw` to write backward proofs in the\nequation world.\n-/\n\nnamespace exlean -- hide\n\nvariables {p q r : Prop} -- hide\n\n/-\nWe prove $p \\lor (q\\land r) \\to p \\lor (r \\land q)$ by propositional extensionality.\n\n**Proof**:\n$$\n\\begin{align}\n&& p \\lor (q\\land r) \\to (r \\land q) \\lor p& &  \\\\\\\\\n&\\iff & p \\lor (r\\land q) \\to (r \\land q) \\lor p & & \\text{[by commutativity of $\\land$]} \\\\\\\\\n&\\iff & (r \\land q) \\lor p \\to (r \\land q) \\lor p. & & \\text{[by commutativity of $\\lor$]} \\\\\\\\\n\\end{align}\n$$\nThe last line follows by reflexivity of $\\to$. \u220e\n-/\n\n\n/-\nThe same proof is given below in Lean.\n-/\n\nexample : p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p :=\nbegin\n  show p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p, rw and.comm,\n  show p \u2228 (r \u2227 q) \u2192 (r \u2227 q) \u2228 p, rw or.comm,\n  show (r \u2227 q) \u2228 p \u2192 (r \u2227 q) \u2228 p, from id,\nend\n\n/-\nBefore moving on to the task for this level, we'll prove a helpful\nequivalence, that $\\neg\\neg p \\leftrightarrow p$.\n-/\n\n/- Axiom : not_not {p : Prop} :\n\u00ac\u00acp \u2194 p\n-/\n\nlemma not_not {p : Prop} : \u00ac\u00acp \u2194 p :=\nbegin\n  have h\u2081 : \u00ac\u00acp \u2192 p, from by_contra,\n  have h\u2082 : p \u2192 \u00ac\u00acp, from not_not_intro,\n  show \u00ac\u00acp \u2194 p, from iff.intro h\u2081 h\u2082,\nend\n\n\n/-\n## Tasks\n1. Prove the result below in Lean using propositional extensionality. Follow the idea\nof the proof above.\n2. If you're feeling adventurous, try proving the result *without* using propositional\nextensionality.\n\n-/\n\n\n/- Theorem :\nLet $p$, $q$, and $r$ be propositions. Then\n$q \\land \\neg\\neg(r \\lor p) \\to (p \\lor r) \\land q$.\n-/\ntheorem prop_ext_example : q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q :=\nbegin\n", "proof": "  show q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q, rw not_not,\n  show q \u2227 (r \u2228 p) \u2192 (p \u2228 r) \u2227 q,   rw and.comm,\n  show (r \u2228 p) \u2227 q \u2192 (p \u2228 r) \u2227 q,   rw or.comm,\n  show (p \u2228 r) \u2227 q \u2192 (p \u2228 r) \u2227 q,   from id,\n/-   assume h : q \u2227 \u00ac\u00ac(r \u2228 p),\n  split,\n  { cases h with h\u2081 h\u2082,\n    have h\u2083 : r \u2228 p, from by_contra h\u2082,\n    cases h\u2083 with k\u2081 k\u2082,\n    { from or.inr k\u2081, },\n    { from or.inl k\u2082, }, },\n  { from h.left,  }, -/\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 76, "name": "prop_ext_example", "statement": "q \u2227 \u00ac\u00ac(r \u2228 p) \u2192 (p \u2228 r) \u2227 q"}, {"type": "lean", "content": "719", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "720", "hidden": true}, {"type": "text", "content": "721"}, {"type": "lean", "content": "722", "hidden": true}, {"type": "text", "content": "723"}, {"type": "theorem", "text": "724", "lean": "theorem or.neg_resolve_left {p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 35, "textBefore": "import propositional_logic.prop_ext -- hide\n\n/-\n# Propositional logic\n## Level 14: Implication redux, part 1\n\nThe aim of this level and the next is to prove $p \\to q$ is equivalent to $\\neg p \\lor q$.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\lor q) \\to (p \\to q)$.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor q) \\to (p \\to q)$.\n-/\n\ntheorem or.neg_resolve_left {p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q) :=\nbegin\n", "proof": "  assume h : \u00acp \u2228 q,\n  show p \u2192 q,\n  assume k : p,\n  show q,  \n  cases h with h\u2081 h\u2082,\n  { given h\u2081 : \u00acp,\n    show q, from absurd k h\u2081, },\n  { given h\u2082 : q,\n    show q, from h\u2082, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 22, "name": "or.neg_resolve_left", "statement": "{p q : Prop} : (\u00acp \u2228 q) \u2192 (p \u2192 q)"}, {"type": "lean", "content": "725", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "726", "hidden": true}, {"type": "text", "content": "727"}, {"type": "lean", "content": "728", "hidden": true}, {"type": "text", "content": "729"}, {"type": "hint", "content": "730", "title": "731"}, {"type": "hint", "content": "732", "title": "733"}, {"type": "theorem", "text": "734", "lean": "theorem not_or_of_imp {p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q):=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 57, "textBefore": "import propositional_logic.implication_redux1 -- hide\n\n/-\n# Propositional logic\n## Level 15: Implication redux, part 2\n\nIn this level, we prove the converse of the result of the previous level.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(p \\to q) \\to (\\neg p \\lor q)$.\n-/\n\n/- Hint : Suggested approach\nFor this result, you'll need to use a non-constructive proof method\n(law of the excluded middle, proof by contradiction, proof by cases, and so forth).\nI suggest proof by cases on `p`.\n-/\n\n/- Hint : A proof template\nIf you get stuck, try the following template.\n```\nassume h : p \u2192 q,\nshow \u00acp \u2228 q,\nby_cases k : p,\n{ given k : p,\n  sorry, },\n{ given k : \u00acp,\n  sorry, },\n```\n\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg p \\lor q)$.\n-/\ntheorem not_or_of_imp {p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q):=\nbegin\n", "proof": "  assume h : p \u2192 q,\n  show \u00acp \u2228 q,\n  by_cases k : p,\n  { given k : p,\n    show \u00acp \u2228 q, right,\n    show q, from h k, },\n  { given k : \u00acp,\n    show \u00acp \u2228 q, from or.inl k, },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 41, "name": "not_or_of_imp", "statement": "{p q : Prop} : (p \u2192 q) \u2192 (\u00acp \u2228 q)"}, {"type": "lean", "content": "735", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "736", "hidden": true}, {"type": "text", "content": "737"}, {"type": "lean", "content": "738", "hidden": true}, {"type": "text", "content": "739"}, {"type": "hint", "content": "740", "title": "741"}, {"type": "theorem", "text": "742", "lean": "theorem not_and_of_not_or_not {p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.implication_redux2 -- hide\n\n/-\n# Propositional logic\n## Level 16: De Morgan's laws 1\n\nDe Morgan's laws state:\n* $\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$ and\n* $\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n\nIn this series of levels, you will prove the four implications that\ntogether constitute these laws.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_and_of_not_or_not {p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q) :=\nbegin\n", "proof": "  assume h\u2081 : \u00acp \u2228 \u00acq,\n  assume h\u2082 : p \u2227 q,\n  have k\u2081 : p, from h\u2082.left,\n  have k\u2082 : q, from h\u2082.right,\n  cases h\u2081 with h\u2083 h\u2084,\n  { given h\u2083 : \u00acp,\n    contradiction, },\n  { given h\u2084 : \u00acq,\n    contradiction, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 33, "name": "not_and_of_not_or_not", "statement": "{p q : Prop} : (\u00acp \u2228 \u00acq) \u2192 \u00ac(p \u2227 q)"}, {"type": "lean", "content": "743", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "744", "hidden": true}, {"type": "text", "content": "745"}, {"type": "lean", "content": "746", "hidden": true}, {"type": "text", "content": "747"}, {"type": "hint", "content": "748", "title": "749"}, {"type": "theorem", "text": "750", "lean": "theorem not_or_of_not_and_not {p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q) :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.de_morgan1 -- hide\n\n/-\n# Propositional logic\n## Level 17: De Morgan's laws 2\n\nWe continue our examination of De Morgan's laws by proving the\n'backward' direction of \n\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n-/\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $(\\neg p \\land \\neg q) \\to \\neg(p \\lor q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement and an\nand statement.\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_or_of_not_and_not {p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q) :=\nbegin\n", "proof": "  assume h\u2081 : \u00acp \u2227 \u00acq,\n  assume h\u2082 : p \u2228 q,\n  have k\u2081 : \u00acp, from h\u2081.left,\n  have k\u2082 : \u00acq, from h\u2081.right,\n  cases h\u2082 with h\u2083 h\u2084,\n  { given h\u2083 : p,\n    contradiction, },\n  { given h\u2084 : q,\n    contradiction, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 31, "name": "not_or_of_not_and_not", "statement": "{p q : Prop} : (\u00acp \u2227 \u00acq) \u2192 \u00ac(p \u2228 q)"}, {"type": "lean", "content": "751", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "752", "hidden": true}, {"type": "text", "content": "753"}, {"type": "lean", "content": "754", "hidden": true}, {"type": "text", "content": "755"}, {"type": "hint", "content": "756", "title": "757"}, {"type": "theorem", "text": "758", "lean": "theorem not_and_not_of_not_or {p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 49, "textBefore": "import propositional_logic.de_morgan2 -- hide\n\n/-\n# Propositional logic\n## Level 18: De Morgan's laws 3\n\nWe now prove the forward direction of:\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve in Lean that $\\neg(p \\lor q) \\to (\\neg p \\land \\neg q)$. \n-/\n\n/- Hint : Suggested approach\nYou need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nYou then have to prove an `\u2227` statement. What should you do?\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_and_not_of_not_or {p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq) :=\nbegin\n", "proof": "  assume h\u2081 : \u00ac(p \u2228 q),\n  split,\n  { show \u00acp,\n    assume h\u2082 : p,\n    apply h\u2081,\n    left,\n    from h\u2082,  },\n  { show \u00acq,\n    assume h\u2082 : q,\n    apply h\u2081,\n    right,\n    from h\u2082,  },\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 29, "name": "not_and_not_of_not_or", "statement": "{p q : Prop} : \u00ac(p \u2228 q) \u2192 (\u00acp \u2227 \u00acq)"}, {"type": "lean", "content": "759", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "760", "hidden": true}, {"type": "text", "content": "761"}, {"type": "lean", "content": "762", "hidden": true}, {"type": "axiom", "content": "763", "name": "imp_iff_not_or {p q : Prop}", "sideBar": true}, {"type": "lean", "content": "764", "hidden": false}, {"type": "text", "content": "765"}, {"type": "hint", "content": "766", "title": "767"}, {"type": "theorem", "text": "768", "lean": "theorem not_or_not_of_not_and_of {p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq) :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 76, "textBefore": "import propositional_logic.de_morgan3 -- hide\n\n/-\n# Propositional logic\n## Level 19: De Morgan's laws 4\n\nWe continue our examination of De Morgan's laws by proving the\n'forward' direction of \n\n$\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$.\n\n\nFor this level, it will be helpful to have a proof of\n$\\neg(p \\to q) \\leftrightarrow (\u00acp \\lor q)$.\n\nWe prove this by combining two results from previous levels:\n-/\n\nnamespace exlean -- hide\n\n/- Axiom : imp_iff_not_or {p q : Prop}\n(p \u2192 q) \u2194 (\u00acp \u2228 q)\n-/\nlemma imp_iff_not_or {p q : Prop} : (p \u2192 q) \u2194 (\u00acp \u2228 q) :=\nbegin\n  have h\u2081 : (p \u2192 q) \u2192 (\u00acp \u2228 q), from not_or_of_imp,\n  have h\u2082 : (\u00acp \u2228 q) \u2192 (p \u2192 q), from or.neg_resolve_left,\n  show (p \u2192 q) \u2194 (\u00acp \u2228 q), from iff.intro h\u2081 h\u2082,\nend\n\n/-\n## Task\nProve in Lean that $\\neg(p \\land q) \\to (\\neg p \\lor \\neg q)$. \n-/\n\n/- Hint : Suggested approach\n\nAt some point in your proof, you will have a target of the form `\u00aca \u2228 b`.\n\nTo prove this kind of statement requires 'classical reasoning'. That is,\nyou'll need to use something like the law of the excluded middle,\nproof by cases, proof by contradiction, or a result that uses one of\nthose principles.\n\nPerhaps the simplest approach is to use the lemma `imp_iff_not_or` above.\n\nUsing this lemma, you can turn the target (of the form `\u00aca \u2228 b`) into\na statement of the form `a \u2192 b`. To do this, rewrite\nfrom the left, typing\n\n`rw \u2190imp_iff_not_or`\n-/\n\n/- Theorem :\nLet $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n-/\ntheorem not_or_not_of_not_and_of {p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq) :=\nbegin\n", "proof": "  assume h\u2081 : \u00ac(p \u2227 q),\n  show \u00acp \u2228 \u00acq,\n  rw \u2190imp_iff_not_or,\n  assume h\u2082 : p,\n  assume h\u2083 : q,\n  apply h\u2081,\n  split,\n  { assumption, },\n  { assumption, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 58, "name": "not_or_not_of_not_and_of", "statement": "{p q : Prop} : \u00ac(p \u2227 q) \u2192 (\u00acp \u2228 \u00acq)"}, {"type": "lean", "content": "769", "hidden": true}]}], "parents": [0]}, {"name": "770", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "771", "hidden": true}, {"type": "text", "content": "772"}, {"type": "lean", "content": "773", "hidden": false}, {"type": "text", "content": "774"}, {"type": "lean", "content": "775", "hidden": false}, {"type": "tactic", "content": "776", "name": "specialize", "sideBar": true}, {"type": "lean", "content": "777", "hidden": true}, {"type": "text", "content": "778"}, {"type": "theorem", "text": "779", "lean": "theorem forall_elim_example (f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1) :=\n", "sideBar": false, "firstProofLineNumber": 82, "lastProofLineNumber": 85, "textBefore": "import data.nat.basic propositional_logic.de_morgan4 -- hide\n\n/-\n# Predicate logic\n## Level 1: For all elimination\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nGiven $h : \\forall (x : X),\\ P(x)$ and given $y : X$, the *for all\nelimination rule* applied to $h$ and $y$ gives a proof of $P(y)$.\n\nAs an example, let $h$ be a proof that\n$\\forall (n : \\mathbb N),\\ (n + 1)^2 = n ^ 2 + 2n + 1$.\n\nThen 'for all elimination', applied to $h$ and $ab$ (for natural \nnumbers $a$ and $b$) gives a proof of\n$(ab + 1)^2 = (ab)^2 + 2(ab) + 1$.\n\nIn Lean, if `h : \u2200 (x : X), P(x)` and if `y : X`, then the\nexpression `h(y)` is a proof of `P(y)`.\n\nThe symbol `\u2200` is typed `\\all`.\n\nHere follows a Lean translation of the above example.\n-/\n\nexample (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  from h (a * b),\nend\n\n\n/-\nAn alternative approach is to use the `specialize` tactic.\nGiven a hypothesis `h : \u2200 (x : X), P(x)` and given a term `y : X`,\ntyping `specialize h y` replaces `h` with `h : P(y)`.\n\nThat is, the general statment `\u2200 (x : X), P(x)` is replaced with\nits specialisation to `y`.\n\nHere is the same result as above, proved using the `specialize` tactic.\nAfter the first line, the hypothesis `h` changes to\n`h : (a * b + 1) ^ 2 = (a * b) ^ 2 + 2 * (a * b) + 1`\n\nIt is used directly in the last line to conclude the proof.\n-/\n\nexample (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  specialize h (a * b),\n  from h,\nend\n\n/- Tactic : specialize\n`specialize` changes a proof of a `\u2200` statement to its specialisation at a particular value.\n\n### Example\n\nGiven `h : \u2200 (x : \u2124), f(x) = 10`, typing `specialize h 3` replaces `h` with\n`h : f(3) = 10`.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below using for all elimination.\n2. Prove the result below using the `specialize` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (x : \\mathbb N),\\ f(x) = f(x + 1)$.\nThen $f(5) = f(5 + 1)$.\n-/\ntheorem forall_elim_example (f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1) :=\nbegin\n", "proof": "  from h 5,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 81, "name": "forall_elim_example", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2200 (x : \u2115), f(x) = f(x + 1)) : f(5) = f(5 + 1)"}, {"type": "lean", "content": "780", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "781", "hidden": true}, {"type": "text", "content": "782"}, {"type": "lean", "content": "783", "hidden": true}, {"type": "lean", "content": "784", "hidden": false}, {"type": "lean", "content": "785", "hidden": true}, {"type": "text", "content": "786"}, {"type": "theorem", "text": "787", "lean": "theorem forall_intro_example1\n(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b) :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 62, "textBefore": "import predicate_logic.forall_elimination -- hide\n\n/-\n# Predicate logic\n## Level 2: For all introduction\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo *prove* a statement $\\forall (x : X),\\ P(x)$ is to assume $y$\nis a term of type $X$ and to prove $P(y)$. This is the *for all\nintroduction* rule.\n\nIn this rule, there's nothing special about the name of the variable\n$y$ or the variable $x$.\n\n\n\nAs an example, suppose $P$ and $Q$ are predicates on a type $B$.\nWe'll prove $\\forall (b : B),\\ Q(b)$, given\n$h : \\forall (z : B),\\ P(z) \\land Q(z)$.\n\n**Proof** Assume $y : B$. We must show $Q(y)$.\nBy for all elimination on $h$ and $y$, we have $h_2 : P(y) \\land Q(y)$.\nWe show $Q(y)$ by right and elimination on $h_2$. \u220e\n\n*Note*: we don't explictly refer to the 'for all introduction' rule\nwhen proving a for all statement.\n-/\n\nvariables (B : Type*) (P Q : B \u2192 Prop) -- hide\n\nexample (h : \u2200 (z : B), P(z) \u2227 Q(z)) : \u2200 (b : B), Q(b) :=\nbegin\n  assume y : B,\n  show Q(y),\n  have h\u2082 : P(y) \u2227 Q(y), from h y,\n  show Q(y), from h\u2082.right,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\nLet $P$ and $Q$ be predicates on a type $B$. Suppose\n$h : \\forall (z : B),\\ P(z)$,\nthen $\\forall (b : B),\\ Q(b) \\lor P(b)$.\n-/\ntheorem forall_intro_example1\n(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b) :=\nbegin\n", "proof": "  assume y : B,\n  show Q(y) \u2228 P(y),\n  have h\u2082 : P(y), from h y,\n  show Q(y) \u2228 P(y), from or.inr h\u2082,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 6, "editorText": "sorry", "lineOffset": 56, "name": "forall_intro_example1", "statement": "(h : \u2200 (z : B), P(z)) : \u2200 (b : B), Q(b) \u2228 P(b)"}, {"type": "lean", "content": "788", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "789", "hidden": true}, {"type": "text", "content": "790"}, {"type": "text", "content": "791"}, {"type": "tactic", "content": "792", "name": "linarith", "sideBar": true}, {"type": "lean", "content": "793", "hidden": false}, {"type": "lean", "content": "794", "hidden": true}, {"type": "text", "content": "795"}, {"type": "theorem", "text": "796", "lean": "theorem forall_practice1 (f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3) :=\n", "sideBar": false, "firstProofLineNumber": 67, "lastProofLineNumber": 75, "textBefore": "import predicate_logic.forall_intro tactic.linarith -- hide\n\n/-\n# Predicate logic\n## Level 3: For all practice\n\n**Theorem**: Let $g : \\mathbb N \\to \\mathbb N$ be a function such\nthat $h : \\forall (n : \\mathbb N),\\ g(n + 1) = 2g(n)$. Then\n$\\forall (m : \\mathbb N),\\ g(m + 2) = 4g(m)$.\n\n**Proof**: Assume $m : \\mathbb N$. We must show $g(m + 2) = 4g(m)$.\nNow,\n$$\n\\begin{align}\ng(m + 2) &= g((m + 1) + 1) & & \\text{[by arithmetic]} \\\\\\\\\n&= 2 g(m + 1) & &\\text{[by $h$, specialised at $m + 1$]} \\\\\\\\\n&= 2 (2 g(m)) & &\\text{[by $h$, specialised at $m$]} \\\\\\\\\n&= 4g(m). & & \\text{[by arithmetic]}\n\\end{align}\n$$\n \u220e\n-/\n\n/-\nThe handwritten proof above can be written in Lean. \nThe `linarith` tactic roughly corresponds to the English phrase\n'by arithemtic'. In particular, `linarith` proves many linear\nequations and inequalities.\n-/\n\n/- Tactic : linarith\nProves many linear equations and inequalities.\n-/\n\nexample (g : \u2115 \u2192 \u2115)\n(h : \u2200 (n : \u2115), g(n + 1) = 2 * g(n)) :\n\u2200 (m : \u2115), g(m + 2) = 4 * g(m) :=\nbegin\n  assume m : \u2115,\n  show g(m + 2) = 4 * g(m),\n  calc\n  g(m + 2)  = g((m + 1) + 1)  : by linarith\n        ... = 2 * g(m + 1)    : by rw h (m + 1)\n        ... = 2 * (2 * g(m))  : by rw h m\n        ... = 4 * g(m)        : by linarith\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (a : \\mathbb N),\\ f(a) + f(a + 1) = f(a + 2)$. Then\n$\\forall (m : \\mathbb N),\\ 2 f(m + 2) = f(m) + f(m + 3)$.\n-/\ntheorem forall_practice1 (f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3) :=\nbegin\n", "proof": "  assume m : \u2115,\n  show 2 * f(m + 2) = f(m) + f(m + 3),\n  calc\n  2 * f(m + 2) =  f(m + 2) + f(m + 2)      : by linarith\n        ... = (f(m) + f(m + 1)) + f(m + 2) : by rw h m\n        ... = f(m) + (f(m + 1) + f(m + 2)) : by linarith\n        ... = f(m) + f(m + 3)              : by rw h (m + 1) \n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 66, "name": "forall_practice1", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2200 (a : \u2115), f(a) + f(a + 1) = f(a + 2)) :\n\u2200 (m : \u2115), 2 * f(m + 2) = f(m) + f(m + 3)"}, {"type": "lean", "content": "797", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "798", "hidden": true}, {"type": "text", "content": "799"}, {"type": "axiom", "content": "800", "name": "Exists.intro (y : X) (h : P(y)) :", "sideBar": true}, {"type": "lean", "content": "801", "hidden": false}, {"type": "text", "content": "802"}, {"type": "lean", "content": "803", "hidden": false}, {"type": "lean", "content": "804", "hidden": true}, {"type": "text", "content": "805"}, {"type": "theorem", "text": "806", "lean": "theorem exists_intro1 :\n\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m) :=\n", "sideBar": false, "firstProofLineNumber": 87, "lastProofLineNumber": 97, "textBefore": "import predicate_logic.forall_practice -- hide\n\n/-\n# Predicate logic\n## Level 4: Exists introduction 1\n\nThe symbol $\\exists$ is real 'there exists' and is called the\nexistential quantifier.\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo prove $\\exists (x : X),\\ P(x)$ is to exhibit a term $y : X$\nand a proof of $P(y)$. This is called *exists introduction*.\n\nAs an example, we'll prove an existentially quantified statement.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\nThe idea of the proof is to find an natural number $x$ together\nwith a proof that $x^2 + 2 = 3x$. How we *find* such a natural\nnumber is not relevant to the proof. In this case, you might\ntry to find an $x$ by rearranging the equation $x^2 + 2 = 3x$ into\n$(x - 2)(x - 1) = 0$, from which it is clear that $2$ or $1$ could\nbe taken as values for $x$.\n\n**Proof**: We have $h : 2^2 + 2 = 3 \\times 2$, by arithmetic.\nWe show $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$ by\nexists introduction on $2$ and $h$. \u220e\n\nIn Lean, `\u2203` is typed `\\exists`. The exists introduction rule is\ncalled `Exists.intro`. Given `y : X` and a proof `h : P(y)`,\n`Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n-/\n\n/- Axiom : Exists.intro (y : X) (h : P(y)) :\n\u2203 (x : X), P(x)\n-/\n\nexample : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  have h : 2 ^ 2 + 2 = 3 * 2, linarith,\n  from Exists.intro 2 h,\nend\n\n/-\nOur next example involves a more complicated predicate.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nWe have $h : (1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$ as\n1. $1 < 2$ by arithmetic and\n2. $1 ^ 2 + 2 = 3 \\times 1$ by arithmetic.\n\nWe show $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$\nfrom exists introduction on $1$ and $h$. \u220e\n\nIn the Lean proof below, we use the `split` tactic to prove the\n`\u2227` statement (recall this is backward and introduction).\n-/\n\nexample : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  have h : (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  { split,\n      show 1 < 2, linarith,\n      show 1 ^ 2 + 2 = 3 * 1, linarith, },\n  from Exists.intro 1 h,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n-/\n\n/- Theorem : no-side-bar\n$\\exists (m : \\mathbb N),\\ (m > 5) \u2227 (m ^ 2 + 40 = 14 m)$\n-/\ntheorem exists_intro1 :\n\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m) :=\nbegin\n", "proof": "  have h : (10 > 5) \u2227 (10 ^ 2 + 40 = 14 * 10),\n  { split,\n      show 10 > 5, linarith,\n      show 10 ^ 2 + 40 = 14 * 10, linarith, },\n  show \u2203 (x : \u2115), (x > 5) \u2227 (x ^ 2 + 40 = 14 * x),\n  from Exists.intro 10 h,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 86, "name": "exists_intro1", "statement": "\u2203 (m : \u2115), (m > 5) \u2227 (m ^ 2 + 40 = 14 * m)"}, {"type": "lean", "content": "807", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "808", "hidden": true}, {"type": "text", "content": "809"}, {"type": "tactic", "content": "810", "name": "use", "sideBar": true}, {"type": "lean", "content": "811", "hidden": false}, {"type": "text", "content": "812"}, {"type": "lean", "content": "813", "hidden": false}, {"type": "lean", "content": "814", "hidden": true}, {"type": "text", "content": "815"}, {"type": "theorem", "text": "816", "lean": "theorem exists_intro2 :\n\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m) :=\n", "sideBar": false, "firstProofLineNumber": 86, "lastProofLineNumber": 95, "textBefore": "import predicate_logic.exists_intro -- hide\n\n/-\n# Predicate logic\n## Level 5: Exists introduction 2\n\nIn the previous level, we saw that if `y : X` and if `h : P(y)`,\nthen `Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n\nThis is a 'forward' approach to the proof. Often, it is more\nnatural to give a 'backward' proof. Here a handwritten example.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\n**Proof**: Take $m$ to be $2$. It suffices to prove $2^2 + 2 = 3\\times 2$.\nBut this holds by arithmetic. \u220e\n\nIn Lean, we type `use 2` in place of the handwritten, 'Take $m$\nto be $2$'.\n-/\n\n/- Tactic : use\n\nThe `use` tactic is used to prove `\u2203` statements.\nIf the target is to prove `\u2203 (x : X), P(x)` and if `y : X`, then\n`use y` changes the target to one of proving `P(y)`.\n\n### Example\n\nThe tactic `use 2` can be employed in the first line of the\nproof of $\\exists (m : \\mathbb N) : m ^ 2 + 2 = 3m$. It\nchanges the target to one of proving $2^2 + 2 = 3 \\times 2$.\n\n```\nexample :\n\u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2,\n  linarith,\nend\n```\n-/\n\nexample : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2, linarith,\nend\n\n/-\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nLet $m$ be $1$. We'll show $(1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$.\nBut\n1. $1 < 2$ by arithmetic and\n2. $1 ^ 2 + 2 = 3 \\times 1$ by arithmetic. \u220e\n-/\n\nexample : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  use 1,\n  show (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  split,\n    show 1 < 2, linarith,\n    show 1 ^ 2 + 2 = 3 * 1, linarith, \nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean, via the `use` tactic.\n-/\n\n/- Theorem : no-side-bar\n$\\exists (m : \\mathbb N),\\ (m < 5) \\land\n((m ^ 2 + 18 = 9 m) \\lor (m ^ 2 + 35 = 12 m))$\n-/\ntheorem exists_intro2 :\n\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m) :=\nbegin\n", "proof": "  use 3,\n  split,\n  { show 3 < 5, linarith, },\n  { show 3 ^ 2 + 18 = 9 * 3 \u2228 3 ^ 2 + 35 = 12 * 3,\n    left,\n    show 3 ^ 2 + 18 = 9 * 3, linarith, }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 85, "name": "exists_intro2", "statement": "\u2203 (m : \u2115), (m < 5) \u2227 (m ^ 2 + 18 = 9 * m \u2228 m ^ 2 + 35 = 12 * m)"}, {"type": "lean", "content": "817", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "818", "hidden": true}, {"type": "text", "content": "819"}, {"type": "text", "content": "820"}, {"type": "axiom", "content": "821", "name": "exists.elim (h\u2081 : \u2203 (x : X), P x) (h\u2082 : \u2200 (y : X), (P y \u2192 q))", "sideBar": true}, {"type": "text", "content": "822"}, {"type": "text", "content": "823"}, {"type": "lean", "content": "824", "hidden": false}, {"type": "lean", "content": "825", "hidden": true}, {"type": "text", "content": "826"}, {"type": "theorem", "text": "827", "lean": "theorem exists_exlim1 (f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m :=\n", "sideBar": false, "firstProofLineNumber": 94, "lastProofLineNumber": 110, "textBefore": "import predicate_logic.exists_intro2 -- hide\n\n/-\n# Predicate logic\n## Level 6: Exists elimination 1\n\nWe've seen how to prove existentially-quantified statements.\nHow do we *use* an existentially-quantified statement?\n\nLet's begin with an informal argument.\n\n**Theorem**: Suppose\n$h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$.\nThen $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: From $h$, we have an integer $x$ such that\n$h_2 : 32 x ^ 5 + 160 x ^ 4$ = 5184$.\n\nTake $n$ to be $2x$. It suffices to prove $(2x)^5 + 10 (2x)^4 = 5184$,\nbut this follows by arithmetic.\n\u220e\n\n-/\n\n\n\n\n/-\nMore formally, the *exists elimination* rule produces a proof\nof a proposition $q$ if it is given a proof of\n$\\exists (x : X), P(x)$ and a proof of\n$\\forall (y : X), (P(y) \\to q)$.\n-/\n\n/- Axiom : exists.elim (h\u2081 : \u2203 (x : X), P x) (h\u2082 : \u2200 (y : X), (P y \u2192 q))\nq\n-/\n\n/-\nWe prove the result above using exists elimination. Recall we \nare given $h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$\nand we are to prove $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: We have $h_2 : \\forall (y : \\mathbb Z),\\\n  ( 32 y ^ 5 + 160 y ^ 4 = 5184  \\to\n    \\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184 )$ as follows:\n> Assume $y : \\mathbb Z$.\n> Assume $h : 32 y ^ 5 + 160 y ^ 4 = 5184$.\n> We must show $\\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184$. \n> Take $n$ to be $2y$.\n> We must show $(2y)^5 + 10(2y)^4 = 5184$. This follows by\n> arithmetic.\n\nThe result follows by exists elimination on $h$ and $h_2$. \u220e\n\n-/\n\n/-\nIn the proof below, `exists.elim` is the Lean version of the\nexists elimination rule.\n-/\n\nexample (h : \u2203 (m : \u2124), 32 * m ^ 5 + 160 * m ^ 4 = 5184) :\n\u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184  :=\nbegin\n  have h\u2082 : \u2200 (y : \u2124),\n  (32 * y ^ 5 + 160 * y ^ 4 = 5184 \u2192 \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184),\n  { assume y : \u2124,\n    assume h\u2083 : 32 * y ^ 5 + 160 * y ^ 4 = 5184,\n    show \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184,\n    use 2 * y,\n    show (2 * y) ^ 5 + 10 * (2 * y) ^ 4 = 5184, linarith, },\n  from exists.elim h h\u2082,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean using `exists.elim`.\n-/\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb N \\to \\mathbb N$ be a function.\nGiven $h : \\exists (x : \\mathbb N),\\ f(5x) = 10x$, prove\n$\\exists (m : \\mathbb N),\\ f(m) = 2m$.\n-/\ntheorem exists_exlim1 (f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m :=\nbegin\n", "proof": "  have h\u2082 : \u2200 (y : \u2115), \n  f(5 * y) = 10 * y \u2192 \u2203 (m : \u2115), f(m) = 2 * m,\n  { assume y : \u2115,\n    assume h\u2083 : f(5 * y) = 10 * y,\n    show \u2203 (m : \u2115), f(m) = 2 * m,\n    use 5 * y,\n    show f(5 * y) = 2 * (5 * y),\n    linarith, },\n  from exists.elim h h\u2082,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 93, "name": "exists_exlim1", "statement": "(f : \u2115 \u2192 \u2115)\n(h : \u2203 (x : \u2115), f(5 * x) = 10 * x) :\n\u2203 (m : \u2115), f(m) = 2 * m"}, {"type": "lean", "content": "828", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "829", "hidden": true}, {"type": "text", "content": "830"}, {"type": "text", "content": "831"}, {"type": "lean", "content": "832", "hidden": true}, {"type": "lean", "content": "833", "hidden": false}, {"type": "lean", "content": "834", "hidden": true}, {"type": "text", "content": "835"}, {"type": "theorem", "text": "836", "lean": "theorem exists_elim2 (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z) :=\n", "sideBar": false, "firstProofLineNumber": 63, "lastProofLineNumber": 76, "textBefore": "import predicate_logic.exists_elim1 -- hide\n\n/-\n# Predicate logic\n## Level 7: Exists elimination 2\n\nThe exists elimination rule can be tricky to use. In this level,\nwe introduce a Lean tactic that simulates the informal style\nof proof we showed at the beginning of the previous level.\n\nHere is a theorem statement and an informal proof.\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ Q(z)$.\n\n**Proof**: From $h$, we have a term $y : X$ such that\n$h_2 : P(y) \\land Q(y)$.\n\nTake $z$ to be $y$. We must show $Q(y)$. But this follows by\nright and elimination on $h_2$. \u220e\n\n-/\n\n/-\nIn Lean, we decompose a given `\u2203` statement using the `cases`\ntactic (much as we do for `\u2228` statements).\n\nIn the proof below `cases h with x h\u2082` introduces a new\nvariable `x : \u2124` together with a proof\n`h\u2082 : P(y) \u2227 Q(y)`. The optional `given`\nstatement is there to indicate to the reader what `h\u2082` asserts.\n-/\n\nvariable (X : Type) -- hide\n\nexample (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), Q(z) :=\nbegin\n  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show Q(y), from h\u2082.right,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n\nProve the result below in Lean, via the `cases` tactic.\n-/\n\n/- Theorem : no-side-bar\nLet $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ P(z) \\lor Q(z)$.\n-/\ntheorem exists_elim2 (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z) :=\nbegin\n", "proof": "  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show P(y) \u2228 Q(y),\n  right,\n  show Q(y),\n  from h\u2082.right,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 62, "name": "exists_elim2", "statement": "(P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), P(z) \u2228 Q(z)"}, {"type": "lean", "content": "837", "hidden": true}]}, {"name": "", "problemIndex": 21, "objects": [{"type": "lean", "content": "838", "hidden": true}, {"type": "text", "content": "839"}, {"type": "tactic", "content": "840", "name": "ext", "sideBar": true}, {"type": "text", "content": "841"}, {"type": "lean", "content": "842", "hidden": true}, {"type": "lean", "content": "843", "hidden": true}, {"type": "lean", "content": "844", "hidden": false}, {"type": "text", "content": "845"}, {"type": "lean", "content": "846", "hidden": false}, {"type": "lean", "content": "847", "hidden": true}, {"type": "text", "content": "848"}, {"type": "lean", "content": "849", "hidden": true}, {"type": "lean", "content": "850", "hidden": false}, {"type": "text", "content": "851"}, {"type": "lean", "content": "852", "hidden": false}, {"type": "lean", "content": "853", "hidden": true}, {"type": "text", "content": "854"}, {"type": "text", "content": "855"}, {"type": "hint", "content": "856", "title": "857"}, {"type": "lean", "content": "858", "hidden": true}, {"type": "lean", "content": "859", "hidden": false}, {"type": "theorem", "text": "860", "lean": "theorem pred_extensionality :\n(P = Q) \u2228 (P = R) :=\n", "sideBar": false, "firstProofLineNumber": 145, "lastProofLineNumber": 156, "textBefore": "import predicate_logic.exists_elim2 -- hide\n\n/-\n# Predicate logic\n## Level 8: Extensionality of predicates\n\nConsider the predicates $P$ and $Q$ on the type of natural numbers\ngiven by $P(x) := x < 5$ and $Q(y) := 2y < 10$.\n\nOn the one hand, $P$ and $Q$ are clearly different. They\nhave different meanings. The proposition\n$Q(y)$ involves a multiplication by $2$. The definition of $Q$\nseems to involve a variables $y$ whereas that of $P$ seems to\ninvolve a variable $x$.\n\nBut, on the other hand, $P$ and $Q$ are clearly the same predicate.\nIndeed, for every integer $m$, $P(m)$ holds if and only if\n$Q(m)$ holds.\n\nThe principle of extensionality of predicates asserts that\ntwo predicates $P$ and $Q$ on a type $X$ are equal given that\n$\\forall (x : X),\\ P(x) \\leftrightarrow Q(x)$.\n\nThis principle cannot be *proved*. It is something we accept as\nan axiom.\n-/\n\n/- Tactic : ext\n\nThe `ext` (short for 'extensionality') tactic is used to prove\ntwo mathematical objects are extensionally equal. This is typically\nused for sets, functions, and predicates.\n\n## Example\nSuppose `P` and `Q` are predicates on a type `B`. If the target is\nto prove `P = Q`, then using `ext b` changes the target to one of proving\n`P(b) \u2194 Q(b)`.\n-/\n\n/-\nBelow, we give a Lean proof of the statement above. Initially,\nthe target is to show equality of the predicates `P` and `Q`\n(defined as above).\n\nBy using the `ext` tactic, the target is changed to one of proving\n`(x < 5) \u2194 (2 * x < 10)`, for a newly introduced variable `x : \u2115`.\n-/\n\nnamespace exlean -- hide\n\nnamespace pred_ext1 -- hide\n\ndef P(m : \u2115) := m < 5\n\ndef Q(n : \u2115) := 2 * n < 10\n\n/-\n\n-/\n\nexample :\nP = Q :=\nbegin\n  ext x,\n  show (x < 5) \u2194 (2 * x < 10),\n  split,\n  { assume h : x < 5,\n    show 2 * x < 10, linarith, },\n  { assume h : 2 * x < 10,\n    show x < 5, linarith,  },\nend\n\nend pred_ext1 -- hide\n\n/-\nFor a more interesting example, let $f : \\mathbb Z \u2192 \\mathbb Z$ be \na function and let $P$ and $Q$ be predicates on $\\mathbb Z$ defined\nby $P(m) := f(m) = 5$ and $Q(n) := 2 = f(n) - 3$. We'll show $P = Q$.\n-/\n\nnamespace pred_ext2 -- hide\n\nconstant f : \u2124 \u2192 \u2124\n\ndef P(m : \u2124) := f(m) = 5\ndef Q(n : \u2124) := 2 = f(n) - 3\n\n/-\n\n-/\n\nexample : P = Q :=\nbegin\n  ext x,\n  show (f(x) = 5) \u2194 (2 = f(x) - 3),\n  split,\n  { assume h : f(x) = 5,\n    show 2 = f(x) - 3, linarith, },\n  { assume h : 2 = f(x) - 3,\n    show f(x) = 5, linarith,  },\nend\n\nend pred_ext2 -- hide\n\n/-\nExtensionality of predicates will feature heavily later in this\ngame when we explore equality of sets.\n\n-/\n\n/-\n## Tasks\n\nHere, you are given a function $f : \\mathbb N \\to \\mathbb N$ and\nthree predicates on $\\mathbb N$,\n* $P(m) := f(m) = 6$,\n* $Q(n) := f(3n) = 18$, and\n* $R(k) := 3f(k) = 18$.\n\nYou are asked to prove $(P = Q) \\lor (P = R)$.\n-/\n\n/- Hint: Starting the proof\nYou should first determine whether you think `P = Q` is true of\n`P = R` is true. Then either use the `left` tactic or the\n`right` tactic, respectively.\n-/\n\nnamespace pred_ext3 -- hide\n\nconstant f : \u2115 \u2192 \u2115\n\ndef P(m : \u2115) := f(m) = 6\n\ndef Q(n : \u2115) := f(3 * n) = 18\n\ndef R(k : \u2115) := 3 * f(k) = 18\n\n/- Theorem : no-side-bar\n$(P = Q) \\lor (P = R)$.\n-/\ntheorem pred_extensionality :\n(P = Q) \u2228 (P = R) :=\nbegin\n", "proof": "  right,\n  ext x,\n  show (f(x) = 6) \u2194 (3 * f(x) = 18),\n  split,\n  { assume h : f(x) = 6,\n    show 3 * f(x) = 18, linarith, },\n  { assume h : 3 * f(x) = 18,\n    show f(x) = 6, linarith, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend pred_ext3 -- hide\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 144, "name": "pred_extensionality", "statement": "(P = Q) \u2228 (P = R)"}, {"type": "lean", "content": "861", "hidden": true}, {"type": "lean", "content": "862", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "863", "hidden": true}, {"type": "text", "content": "864"}, {"type": "text", "content": "865"}, {"type": "lean", "content": "866", "hidden": true}, {"type": "lean", "content": "867", "hidden": false}, {"type": "text", "content": "868"}, {"type": "lean", "content": "869", "hidden": false}, {"type": "text", "content": "870"}, {"type": "lean", "content": "871", "hidden": false}, {"type": "text", "content": "872"}, {"type": "theorem", "text": "873", "lean": "theorem even1 :\n\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2) :=\n", "sideBar": false, "firstProofLineNumber": 80, "lastProofLineNumber": 94, "textBefore": "import tactic.modded predicate_logic.pred_extensionality -- hide\n\n/-\n# Predicate logic\n## Level 9: Even integers\n\nAs a practical example, define the predicate\n$\\mathsf{even}$ on $\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists (m : \\mathbb Z),\\ n = 2m$.\n\nTo prove $\\mathsf{even}(10)$ is to prove $\\exists (m : \\mathbb Z),\\ 10 = 2m$.\n\n**Proof**: take $m$ to be $5$. Then indeed $10 = 2 \\times 5$.\n-/\n\n/-\nHere is a Lean definition of the `even` predicate.\n-/\n\n\nnamespace exlean -- hide\n\ndef even (n : \u2124) := \u2203 (m : \u2124), n = 2 * m\n\n/-\nIn the Lean proof below, I use the slightly odd construction\n`(10 : \u2124) = 2 * 5` rather than `10 = 2 * 5`. This is to ensure\nLean inteprets the quantities as integers rather than as\nnatural numbers.\n-/\n\nexample : even(10) :=\nbegin\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n\n/-\n**Theorem**: for all integers $n$, if $n$ is even, then $4n$ is even.\n\nMore formally, we are to prove\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(4n)$.\n\n**Proof**: Assume $n : \\mathbb Z$. Assume $h : \\mathsf{even}(n)$.\nThat is, $h : \\exists (m : \\mathbb Z),\\ n = 2m$.\nDecomposing this we have $x : \\mathbb Z$ for which $h_2 : n = 2x$.\nWe must show $\\mathsf{even}(4n)$. That is, $\\exists (m : \\mathbb Z),\\ 4n = 2m$.\nTake $m$ to be $4x$. We must show $4n = 2(4x)$.\nBy $h_2$, we must show $4(2x) = 2(4x)$. This holds by arithmetic.\n-/\n\nexample : \u2200 (n : \u2124), even(n) \u2192 even(4 * n) :=\nbegin\n  assume n : \u2124,\n  assume h : even(n),\n  given h : \u2203 (m : \u2124), n = 2 * m,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), 4 * n = 2 * m, \n  use 4 * x,\n  rw h\u2082,\n  show 4 * (2 * x) = 2 * (4 * x), linarith,\nend\n\n\n/-\n## Task\n\nProve the result below in Lean, adapting the proof above.\n-/\n\n\n\n/- Theorem : no-side-bar\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(n ^ 2)$.\n-/\ntheorem even1 :\n\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2) :=\nbegin\n", "proof": "  assume n : \u2124,\n  assume h : even (n),\n  change \u2203 (m : \u2124), n = 2 * m at h,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), n ^ 2 = 2 * m,\n  use 2 * x ^ 2,\n  rw h\u2082,\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 79, "name": "even1", "statement": "\u2200 (n : \u2124), even(n) \u2192 even(n ^ 2)"}, {"type": "lean", "content": "874", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "875", "hidden": true}, {"type": "text", "content": "876"}, {"type": "text", "content": "877"}, {"type": "text", "content": "878"}, {"type": "lean", "content": "879", "hidden": false}, {"type": "text", "content": "880"}, {"type": "lean", "content": "881", "hidden": false}, {"type": "lean", "content": "882", "hidden": true}, {"type": "text", "content": "883"}, {"type": "theorem", "text": "884", "lean": "theorem multiple_quantifiers1 (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)  :=\n", "sideBar": false, "firstProofLineNumber": 94, "lastProofLineNumber": 104, "textBefore": "import predicate_logic.even1 -- hide\n\n/-\n# Predicate logic\n## Level 10: Multiple quantifiers 1\n\nMany statements in mathematics involve more than one quantifier.\nThe commutitivity of addition of natural numbers can be stated\nas\n$\\forall (m : \\mathbb N),\\ \\forall (n : \\mathbb N),\\ m + n = n + m$.\n-/\n\n/-\nStatements such as this are to be read from left-to-right.\nIf we let $P$ be the predicate on $\\mathbb N$ given by\n$P(m) := \\forall (n : \\mathbb N),\\ m + n = n + m$, then\nthe above statement can be shortened to\n$\\forall (m : \\mathbb N),\\ P(m)$.\n\n-/\n\n\n/-\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$. Suppose\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$.\n\n**Proof**: Assume $m : X$ and $n : X$.\nWe have $h_2 : P(m) \\land Q(n)$ by $h$ specialised at $m$ and $n$.\nWe must show $Q(n) \\land P(m)$. By commutativity of $\\land$, this\nis the same as proving $P(m) \\land Q(n)$, which follows from $h_2$. \u220e\n\n-/\n\nvariable (X : Type)\n\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  assume (m n : X),\n  have h\u2082 : (P m) \u2227 (Q n), from h m n,\n  show Q(n) \u2227 P(m),\n  rw and_comm,\n  show P(m) \u2227 Q(n), from h\u2082,\nend\n\n/-\nThe proof above uses for all introduction and for all elimination.\nA more natural proof uses propositional extensionality to rewrite\nthe commutativity of $\\land$ through the universal quantifier.\n\nAgain, we'll prove that\n$\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$ follows from\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\n\n**Proof**: By commutativity of $\\land$, it suffices to prove\n$\\forall (m : X), \\forall (n : X),\\ P(m) \\land Q(m)$. This follows\nfrom $h$. \u220e\n\nIn Lean, we use the `simp` tactic to rewrite through\nquantifiers, as below.\n-/\n\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  simp [and_comm],\n  show \u2200 (m : X), \u2200 (n : X), P(m) \u2227 Q(n), from h,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\n1. Prove the result below in the style of the first proof above.\n2. Prove the result below using `simp` to rewrite through\nthe quantifiers.\n\n-/\n\n\n/- Theorem : no-side-bar\nSuppose $P$ and $Q$ are predicates on a type $X$. \nSuppose $h : \\forall (x : X),\\ \\forall (y : X),\\ P(x) \\lor Q(y)$.\nThen $\\forall (m : X),\\ \\forall (n : X),\\ Q(n) \\lor P(m)$.\n-/\ntheorem multiple_quantifiers1 (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)  :=\nbegin\n", "proof": "  assume (m n : X),\n  have h\u2082 : P(m) \u2228 Q(n), from h m n,\n  show Q(n) \u2228 P(m),\n  rw or_comm,\n  show P(m) \u2228 Q(n), from h\u2082,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 93, "name": "multiple_quantifiers1", "statement": "(P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2228 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2228 P(m)"}, {"type": "lean", "content": "885", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "886", "hidden": true}, {"type": "text", "content": "887"}, {"type": "text", "content": "888"}, {"type": "lean", "content": "889", "hidden": false}, {"type": "lean", "content": "890", "hidden": true}, {"type": "text", "content": "891"}, {"type": "theorem", "text": "892", "lean": "theorem multiple_quantifiers2 :\n\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2) :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 53, "textBefore": "import predicate_logic.multiple_quantifiers1 -- hide\n\n/-\n# Predicate logic\n## Level 11: Multiple quantifiers 2\n\n-/\n\n\n/-\n**Theorem**: $\\forall (x : \\mathbb Z), \\exists (y : \\mathbb Z),\\ x = y + 5$.\n\n**Proof**: Assume $x : \\mathbb Z$. Take $y$ to be $x - 5$.\nIt remains to show $x = (x - 5) + 5$, but this holds by arithmetic. \u220e\n\nThe handwritten proof above translates easily to a Lean proof.\n-/\n\nexample : \u2200 (x : \u2124), \u2203 (y : \u2124), x = y + 5 :=\nbegin\n  assume x : \u2124,\n  use (x - 5),\n  show x = (x - 5) + 5, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\n\\forall (m : \\mathbb Z),\\ \\exists (n : \\mathbb Z),\\ m n + n - 1 = m (m + 2)\n$\n-/\ntheorem multiple_quantifiers2 :\n\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2) :=\nbegin\n", "proof": "  assume m : \u2124,\n  use m + 1,\n  show m * (m + 1) + (m + 1) - 1 = m * (m + 2),\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 43, "name": "multiple_quantifiers2", "statement": "\u2200 (m : \u2124), \u2203 (n : \u2124), m * n + n - 1 = m * (m + 2)"}, {"type": "lean", "content": "893", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "894", "hidden": true}, {"type": "text", "content": "895"}, {"type": "text", "content": "896"}, {"type": "hint", "content": "897", "title": "898"}, {"type": "text", "content": "899"}, {"type": "lean", "content": "900", "hidden": false}, {"type": "lean", "content": "901", "hidden": true}, {"type": "text", "content": "902"}, {"type": "theorem", "text": "903", "lean": "theorem multiple_quantifiers3 :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 74, "textBefore": "import predicate_logic.multiple_quantifiers2 -- hide\n\n/-\n# Predicate logic\n## Level 12: Multiple quantifiers 3\n\n-/\n\n\n/-\n**Theorem**: $\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x^2 + 3xy + 66 = 4 y ^2$.\n\nFor the proof below, it isn't relevant *how* you find $x$ and $y$\nsuch that the above equation is satisfied. \n-/\n\n\n/- Hint: But how do I find the solutions?\n\nThough it's not relevant at this stage of your mathematical journey,\none way to find solutions to this equation is to treat the\nequation as a quadratic in $x$ and to solve for $x$ in terms of $y$.\nAs we are looking for natural number solutions, we require the\ndiscriminant of the equation to be a perfect square. In this case,\nthat means you need $25y^2 - 264 = m^2$, for some integer $m$.\nThere are only finitely many solutions to this equation amongst\nthe integers.\n-/\n\n/-\n\n**Proof**: Take $x$ to be $2$. Take $y$ to be $5$. We must\nshow $2^2 + 3 \\times 2 \\times 4 + 66 = 4 \\times 5 ^2 $.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n-/\n\nexample :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x ^ 2 + 3 * x * y + 66 = 4 * y ^ 2 :=\nbegin\n  use 2,\n  use 5,\n  show 2 ^ 2 + 3 * 2 * 5 + 66 = 4 * 5 ^ 2, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. In this case, there are infinitely many\nsolutions for $x$ and $y$. You just need to find one solution.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x  y + 21 = 7  x + 3  y$.\n-/\ntheorem multiple_quantifiers3 :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y :=\nbegin\n", "proof": "  use 3,\n  use 0,\n  show 3 * 0 + 21 = 7 * 3 + 3 * 0, linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 65, "name": "multiple_quantifiers3", "statement": "\u2203 (x : \u2115), \u2203 (y : \u2115), x * y + 21 = 7 * x + 3 * y"}, {"type": "lean", "content": "904", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "905", "hidden": true}, {"type": "text", "content": "906"}, {"type": "text", "content": "907"}, {"type": "lean", "content": "908", "hidden": false}, {"type": "lean", "content": "909", "hidden": true}, {"type": "text", "content": "910"}, {"type": "theorem", "text": "911", "lean": "theorem multiple_quantifiers4 :\n\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1 :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 54, "textBefore": "import predicate_logic.multiple_quantifiers3 -- hide\n\n/-\n# Predicate logic\n## Level 13: Multiple quantifiers 4\n\n-/\n\n\n/-\n**Theorem**: $\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n x + y = y$.\n\n**Proof**: Take $x$ to be $0$. We must show\n$\\forall (y : \\mathbb Z),\\ 0 + y = y$.\nAssume $y : \\mathbb Z$. We must show $0 + y = y$.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n-/\n\nexample : \u2203 (x : \u2124), \u2200 (y : \u2124), x + y = y :=\nbegin\n  use 0,\n  assume y : \u2124,\n  show 0 + y = y, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n\n/- Theorem : no-side-bar\nShow that\n$\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n (y - 1)^2 = y^2 - xy + 1$.\n-/\ntheorem multiple_quantifiers4 :\n\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1 :=\nbegin\n", "proof": "  use 2,\n  assume y : \u2124,\n  show (y - 1) ^ 2 = y ^ 2 - 2 * y + 1, linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 45, "name": "multiple_quantifiers4", "statement": "\u2203 (x : \u2124), \u2200 (y : \u2124), (y - 1) ^ 2 = y ^ 2 - x * y + 1"}, {"type": "lean", "content": "912", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "913", "hidden": true}, {"type": "text", "content": "914"}, {"type": "text", "content": "915"}, {"type": "lean", "content": "916", "hidden": true}, {"type": "theorem", "text": "917", "lean": "theorem even2 :\n\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b) :=\n", "sideBar": false, "firstProofLineNumber": 25, "lastProofLineNumber": 35, "textBefore": "import tactic.modded predicate_logic.multiple_quantifiers4 -- hide\n\n/-\n# Predicate logic\n## Level 14: Even integers 2\n\n-/\n\n\n/-\n## Task\n\nProve the result below in Lean.\n-/\n\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\n$\\exists (a : \\mathbb Z),\\ \\forall (b : \\mathbb Z),\\ \\mathsf{even}(ab)$.\n-/\ntheorem even2 :\n\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b) :=\nbegin\n", "proof": "  use 0,\n  assume b : \u2124,\n  use 0,\n  show 0 * b = 2 * 0,\n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 24, "name": "even2", "statement": "\u2203 (a : \u2124), \u2200 (b : \u2124), even (a * b)"}, {"type": "lean", "content": "918", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "919", "hidden": true}, {"type": "text", "content": "920"}, {"type": "text", "content": "921"}, {"type": "text", "content": "922"}, {"type": "tactic", "content": "923", "name": "push_neg", "sideBar": true}, {"type": "lean", "content": "924", "hidden": false}, {"type": "lean", "content": "925", "hidden": true}, {"type": "text", "content": "926"}, {"type": "theorem", "text": "927", "lean": "theorem negating_quantifiers1 :\n\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x) :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 81, "textBefore": "import predicate_logic.multiple_quantifiers4 -- hide\n\n/-\n# Predicate logic\n## Level 15: Negating quantifiers 1\n\n-/\n\n\n/-\nAs we'll soon see, the proposition $\\neg (\\forall (x : X),\\ P(x))$\nis equal (materially equivalent to) the proposition\n$\\exists (x : X),\\ \\neg P(x)$.\n\nLikewise, the proposition $\\neg (\\exists (x : X),\\ P(x))$ is equal\nto the proposition $\\forall (x : X),\\ \\neg P(x)$.\n\n**Theorem**: Prove that $\\neg (\\forall (x : \\mathbb N),\\ x + 2 = 5)$.\n\nIn words, we'll prove it's not the case that for every natural\nnumber $x$, $x + 2 = 5$.\n\n**Proof**: We must show $\\exists (x : \\mathbb N),\\ \\neg(x + 2 = 5)$.\nThat is, to show $\\exists (x : \\mathbb N),\\ x + 2 \\ne 5$.\n\nTake $x$ to be $0$. We must show $0 + 2 \\ne 5$. This holds by\narithmetic. \u220e\n-/\n\n/-\nIn the Lean proof below, `push_neg` is the tactic that converts the\nnegation of a universally quantified statement into an \nexistentially quantified statement.\n\nThe symbol `\u2260` is typed `\\ne`.\n-/\n\n/- Tactic : push_neg\n\nThe `push_neg` tactic 'pushes' negations inside\nquantifiers. For example, it changes a target `\u2200 (x : X), P(x)`\ninto `\u2203 (x : X), \u00acP(x)`. If `P(x)` is itself a quantified\nstatement, then `push_neg` will recursively push the negation\ninto `P(x)`.\n\nThus, `push_neg` converts `\u00ac(\u2200 (x : X), \u2203 (y : Y), P x y)` into\n`\u2203 (x : X), \u2200 (y : Y), \u00ac(P x y)`.\n-/\n\nexample : \u00ac(\u2200 (x : \u2115), x + 2 = 5) :=\nbegin\n  push_neg,\n  show \u2203 (x : \u2115), x + 2 \u2260 5,\n  use 0,\n  show 0 + 2 \u2260 5, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n-/\n\n\n/- Theorem : no-side-bar\n$\\neg(\\forall (x : \\mathbb N),\\ x ^ 2 + 2  x = 3  x)$.\n-/\ntheorem negating_quantifiers1 :\n\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x) :=\nbegin\n", "proof": "  push_neg,\n  show \u2203 (x : \u2115), x ^ 2 + 2 * x \u2260 3 * x,\n  use 2,\n  linarith,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 72, "name": "negating_quantifiers1", "statement": "\u00ac(\u2200 (x : \u2115), x ^ 2 + 2 * x = 3 * x)"}, {"type": "lean", "content": "928", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "929", "hidden": true}, {"type": "text", "content": "930"}, {"type": "text", "content": "931"}, {"type": "lean", "content": "932", "hidden": false}, {"type": "lean", "content": "933", "hidden": true}, {"type": "text", "content": "934"}, {"type": "theorem", "text": "935", "lean": "theorem negating_quantifiers2 :\n\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1) :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 53, "textBefore": "import predicate_logic.negating_quantifiers -- hide\n\n/-\n# Predicate logic\n## Level 16: Negating quantifiers 2\n\n-/\n\n\n/-\n\n**Theorem**: Prove that $\\neg (\\exists (x : \\mathbb N),\\ x + 2 = 0)$.\n\nIn words, we'll prove it's not the case that there exists a natural\nnumber $x$ such that $x + 2 = 0$.\n\n**Proof**: We must show $\\forall (x : \\mathbb N),\\ x + 2 \\ne 0$.\nAssume $x : \\mathbb N$. We must show $x + 2 \\ne 0$. \nThis holds by arithmetic. \u220e\n-/\n\nexample : \u00ac(\u2203 (x : \u2115), x + 2 = 0) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), x + 2 \u2260 0,\n  assume x : \u2115,\n  show x + 2 \u2260 0, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n-/\n\n\n/- Theorem : no-side-bar\n$\\neg (\\exists (x : \\mathbb N),\\ 2x = 4x + 1)$.\n-/\ntheorem negating_quantifiers2 :\n\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1) :=\nbegin\n", "proof": "  push_neg,\n  show \u2200 (x : \u2115), 2 * x \u2260 4 * x + 1,\n  assume x : \u2115,\n  linarith,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 44, "name": "negating_quantifiers2", "statement": "\u00ac(\u2203 (x : \u2115), 2 * x = 4 * x + 1)"}, {"type": "lean", "content": "936", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "937", "hidden": true}, {"type": "text", "content": "938"}, {"type": "text", "content": "939"}, {"type": "lean", "content": "940", "hidden": false}, {"type": "lean", "content": "941", "hidden": true}, {"type": "text", "content": "942"}, {"type": "theorem", "text": "943", "lean": "theorem negating_quantifiers3 :\n\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 72, "textBefore": "import predicate_logic.negating_quantifiers2 -- hide\n\n/-\n# Predicate logic\n## Level 17: Negating quantifiers 3\n\n-/\n\n\n/-\n\n**Theorem**: Prove that\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ xy = x + y)$.\n\nIn proving this theorem, we need to push the negation through two\nquantifiers. After pushing the negation through the existential quantifier,\nthe target is to prove\n$\n\\forall (x : \\mathbb N),\\ \\neg(\\forall (y : \\mathbb N),\\ xy = x + y).\n$\n\nWe then push the negation through the inner quantifier, making the\ntarget\n$\n\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y).\n$\n\n**Proof**: We must show\n$\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y$.\nAssume $x : \\mathbb N$. We must show\n$\\exists (y : \\mathbb N),\\ xy \\ne x + y$. Take $y$ to be $1$. We\nmust show $x\\times 1 \u2260 x + 1$. This holds by arithmetic. \u220e\n-/\n\nexample : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), x * y = x + y) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), x * y \u2260 x + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), x * y \u2260 x + y,\n  use 1,\n  show x * 1 \u2260 x + 1, linarith,\nend\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below.\n\n-/\n\n/- Theorem : no-side-bar\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ 3xy = xy^2 + y)$.\n-/\ntheorem negating_quantifiers3 :\n\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y) :=\nbegin\n", "proof": "  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), 3 * x * y \u2260 x * (y ^ 2) + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), 3 * x * y \u2260 x * (y ^ 2) + y,\n  use 3,\n  show 3 * x * 3 \u2260 x * (3 ^ 2) + 3, linarith,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 58, "name": "negating_quantifiers3", "statement": "\u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), 3 * x * y = x * (y^2) + y)"}, {"type": "lean", "content": "944", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "945", "hidden": true}, {"type": "text", "content": "946"}, {"type": "lean", "content": "947", "hidden": true}, {"type": "text", "content": "948"}, {"type": "hint", "content": "949", "title": "950"}, {"type": "lean", "content": "951", "hidden": true}, {"type": "theorem", "text": "952", "lean": "theorem neg_exists_of_all_neg (P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x)):=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 53, "textBefore": "import tactic.no_push_neg --hide\n\n/-\n# Predicate logic\n## Level 18: Negating quantifiers theorem 1\n\nThe next few levels are for the experts. We'll prove the equivalences\n* $\\neg (\\forall (x : X),\\ P(x)) \\leftrightarrow \\exists (x : X),\\ \\neg P(x)$ and\n* $\\neg (\\exists (x : X),\\ P(x)) \\leftrightarrow \\forall (x : X),\\ \\neg P(x)$.\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n-/\n\n/- Hint : Proving `false`\nRecall that if `h\u2081 : p` and `h\u2082 : \u00acp`, then `h\u2082 h\u2081` is a proof of\n`false`.\n\nAlternatively, remember that `absurd h\u2081 h\u2082` gives a proof of anything.\n-/\n\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$(\\forall (x : X),\\ \\neg P(x)) \\to \\neg(\\exists (x : X),\\ P(x))$.\n-/\ntheorem neg_exists_of_all_neg (P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x)):=\nbegin\n", "proof": "  assume h : \u2200 (x : X), \u00acP(x),\n  assume h\u2082 : \u2203 (x : X), P(x),\n  cases h\u2082 with y h\u2083,\n  given h\u2083 : P(y),\n  have h\u2084 : \u00acP(y), from h y,\n  show false, from h\u2084 h\u2083,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 38, "name": "neg_exists_of_all_neg", "statement": "(P : X \u2192 Prop) :\n(\u2200 (x : X), \u00acP(x)) \u2192 \u00ac(\u2203 (x : X), P(x))"}, {"type": "lean", "content": "953", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "954", "hidden": true}, {"type": "text", "content": "955"}, {"type": "lean", "content": "956", "hidden": true}, {"type": "text", "content": "957"}, {"type": "hint", "content": "958", "title": "959"}, {"type": "lean", "content": "960", "hidden": true}, {"type": "theorem", "text": "961", "lean": "theorem all_neg_of_neg_exists (P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x)) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 54, "textBefore": "import predicate_logic.negating_quantifiers_thm1 --hide\n\n/-\n# Predicate logic\n## Level 19: Negating quantifiers theorem 2\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n-/\n\n/- Hint : Using negated hypotheses\n\nSuppose the context contains `h : \u00acp`, for some proposition `p`.\nSuppose also that the target is to prove `false`.\nAs `h : p \u2192 false`, it suffice to prove `p` and then use\nimplication elimination.\n\nRecall that Lean permits an (easier?) backward version of\nimplication elimination. By typing `apply h`, you change the\ntarget to one of proving `p`.\n-/\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$\\neg(\\exists (x : X),\\ P(x)) \\to (\\forall (x : X),\\ \\neg P(x))$.\n-/\ntheorem all_neg_of_neg_exists (P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x)) :=\nbegin\n", "proof": "  assume h : \u00ac(\u2203 (x : X), P(x)),\n  assume x : X,\n  assume h\u2082 : P(x),\n  apply h,\n  use x,\n  from h\u2082,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 38, "name": "all_neg_of_neg_exists", "statement": "(P : X \u2192 Prop) :\n\u00ac(\u2203 (x : X), P(x)) \u2192 (\u2200 (x : X), \u00acP(x))"}, {"type": "lean", "content": "962", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "963", "hidden": true}, {"type": "text", "content": "964"}, {"type": "lean", "content": "965", "hidden": true}, {"type": "text", "content": "966"}, {"type": "hint", "content": "967", "title": "968"}, {"type": "lean", "content": "969", "hidden": true}, {"type": "theorem", "text": "970", "lean": "theorem neg_all_of_exists_neg (P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x)) :=\n", "sideBar": false, "firstProofLineNumber": 34, "lastProofLineNumber": 45, "textBefore": "import predicate_logic.negating_quantifiers_thm2 -- hide\n\n/-\n# Predicate logic\n## Level 20: Negating quantifiers theorem 3\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` in this level.\n\n-/\n\n/- Hint : Dealing with the existentially-quantified statement\n\nAt some point in your proof, you will have introduced an\nexistentially-quantified statement into the context.\nRemember that you can decompose such a statement using the `cases`\ntactic.\n-/\n\nvariable (X : Type) -- hide\n\n/- Theorem : no-side-bar\n$\\exists (x : X),\\ \\neg P(x) \\to \\neg(\\forall (x : X),\\ P(x))$.\n-/\ntheorem neg_all_of_exists_neg (P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x)) :=\nbegin [no_push_neg]\n", "proof": "  assume h : \u2203 (x : X), \u00acP(x),\n  assume h\u2082 : \u2200 (x : X), P(x),\n  cases h with x h,\n  given h : \u00acP x,\n  have h\u2083 : P x, from h\u2082 x,\n  show false, from h h\u2083,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 33, "name": "neg_all_of_exists_neg", "statement": "(P : X \u2192 Prop) :\n(\u2203 (x : X), \u00acP(x)) \u2192 \u00ac(\u2200 (x : X), P(x))"}, {"type": "lean", "content": "971", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "972", "hidden": true}, {"type": "text", "content": "973"}, {"type": "lean", "content": "974", "hidden": true}, {"type": "text", "content": "975"}, {"type": "hint", "content": "976", "title": "977"}, {"type": "lean", "content": "978", "hidden": true}, {"type": "lean", "content": "979", "hidden": true}, {"type": "theorem", "text": "980", "lean": "theorem exists_neg_of_neg_all (P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x)) :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 56, "textBefore": "import predicate_logic.negating_quantifiers_thm3 tactic.localized --hide\n\n/-\n# Predicate logic\n## Level 21: Negating quantifiers theorem 4\n\n-/\n\n\n\nnamespace exlean -- hide\n\n/-\n## Tasks\nProve the result below. You cannot use `push_neg` for this level.\nThis level is somewhat challenging!\n\n-/\n\n/- Hint : The structure of the proof.\n\nAfter doing the natural first step when proving an implication, I\nsuggest doing a proof by contradiction using `by_contra h\u2082`.\nDo the obvious things until you get stuck. At some point, you'll\nneed to use contradiction again.\n-/\n\nvariable (X : Type) -- hide\n\n\n\nopen_locale classical -- hide\n\n/- Theorem : no-side-bar\n$\\neg(\\forall (x : X),\\ P(x)) \\to \\exists (x : X),\\ \\neg P(x)$.\n-/\ntheorem exists_neg_of_neg_all (P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x)) :=\nbegin\n", "proof": "  assume h : \u00ac(\u2200 (x : X), P(x)),\n  by_contra h\u2082,\n  apply h,\n  assume x : X,\n  by_contra h\u2083,\n  apply h\u2082,\n  use x,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 39, "name": "exists_neg_of_neg_all", "statement": "(P : X \u2192 Prop) :\n\u00ac(\u2200 (x : X), P(x)) \u2192 (\u2203 (x : X), \u00acP(x))"}, {"type": "lean", "content": "981", "hidden": true}]}], "parents": [2]}, {"name": "982", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "983", "hidden": true}, {"type": "text", "content": "984"}, {"type": "text", "content": "985"}, {"type": "lean", "content": "986", "hidden": true}, {"type": "lean", "content": "987", "hidden": true}, {"type": "lean", "content": "988", "hidden": false}, {"type": "lean", "content": "989", "hidden": true}, {"type": "lean", "content": "990", "hidden": false}, {"type": "text", "content": "991"}, {"type": "lean", "content": "992", "hidden": false}, {"type": "text", "content": "993"}, {"type": "theorem", "text": "994", "lean": "theorem ten_in_even' : (10 : \u2124) \u2208 even' :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 77, "textBefore": "import tactic.modded  tactic.linarith -- hide\n\n/-\n# Sets\n## Level 1: Set membership\n\nA set on a type $X$ is simply a predicate on that type.\n\nLet's define predicates $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nThen $\\mathsf{even}$ and $\\mathsf{even}'$ can be seen as sets\nof elements of type $\\mathbb Z$.\n\nWe write $10 \\in \\mathsf{even}$ (for instance) as a synonym for\n$\\mathsf{even}(10)$. More generally, $x \\in P$ is a synonym for\n$P(x)$ (given that $P$ is a predicate on a type $X$ and that $x : X$).\n\nHere's a proof of $10 \\in \\mathsf{even}$.\n\n**Proof**: We must show $\\mathsf{even}(10)$, namely that\n$\\exists(m : \\mathbb Z),\\ 10 = 2m$. Take $m$ to be $5$. Then\n$10 = 2 \\times 5$ follows by arithmetic.\n-/\n\n/-\nIn Lean, we define sets much as we define predicates. The only\ndifference between the following defintion and the definition of\na predicate is the use of `set \u2124` in place of `\u2124 \u2192 Prop`.\n-/\n\nnamespace exlean -- hide\n\nnamespace even_sets -- hide\n\ndef even : set \u2124 := \u03bb n, \u2203 (m : \u2124), n = 2 * m\n\n-- hide\n\ndef even' : set \u2124 := \u03bb n, \u2203 (m : \u2124), n + 4 = 2 * m\n\n/-\nIn Lean, `\u2208` is typed `\\in`. Here is a Lean proof that `10 \u2208 even`.\nNote that I have to type `(10 : \u2124)` so Lean knows I'm working with the\ninteger `10` rather than the natural number `10`.\n-/\n\nexample : (10 : \u2124) \u2208 even :=\nbegin\n  show \u2203 (m : \u2124), 10 = 2 * m,\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n\n/-\n## Task\nProve that $10 \\in \\mathsf{even}'$, with $\\mathsf{even}'$ defined\nas above.\n-/\n\n/- Theorem : no-side-bar\n$10 \\in \\mathsf{even}'$.\n-/\ntheorem ten_in_even' : (10 : \u2124) \u2208 even' :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 10 + 4 = 2 * m,\n  use 7,\n  show (10 : \u2124) + 4 = 2 * 7, linarith,\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend even_sets -- hide\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 67, "name": "ten_in_even'", "statement": "(10 : \u2124) \u2208 even'"}, {"type": "lean", "content": "995", "hidden": true}, {"type": "lean", "content": "996", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "997", "hidden": true}, {"type": "text", "content": "998"}, {"type": "lean", "content": "999", "hidden": true}, {"type": "lean", "content": "1000", "hidden": true}, {"type": "text", "content": "1001"}, {"type": "theorem", "text": "1002", "lean": "theorem even_eq_even' : even = even' :=\n", "sideBar": false, "firstProofLineNumber": 59, "firstProofHintLineNumber": 79, "lastProofHintLineNumber": 90, "lastProofLineNumber": 97, "textBefore": "import sets.set_membership -- hide\n\n/-\n# Sets\n## Level 2: Equality of sets\n\nFrom the previous level, recall the definitions of the \nsets $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nRecall that for two predicates $P$ and $Q$ on a type $X$ to be\nequal means that $\\forall(x : X),\\ P(x) \\leftrightarrow Q(x)$.\nThis is the principle of extensionality of predicates.\n\nViewed as sets, $P = Q$ means\n$\\forall(x : X),\\ x \\in P \\leftrightarrow x \\in Q$.\n\nI claim that $\\mathsf{even} = \\mathsf{even}'$.\n\nHere's a sketch proof of the result.\n\n**Proof**:\nBy extensionality, we must show\n$\n\\forall (x : \\mathbb Z),\\ x \\in \\mathsf{even} \\leftrightarrow x \\in \\mathsf{even}'.$\n\nAssume $x : \\mathbb Z$. It suffices to show\n$x \\in \\mathsf{even} \\to x \\in \\mathsf{even}'$ and\n$x \\in \\mathsf{even}' \\to x \\in \\mathsf{even}$.\n\nFor the first of these, assume $h : x \\in \\mathsf{even}$.\nThen we have $k : \\mathbb Z$ such that $h_2 : x = 2 k$.\nWe must show $x \\in \\mathsf{even}'$. That is, that\n$\\exists(m : \\mathbb Z),\\ x + 4 = 2m$. Takes $m$ to be $k + 2$.\nWe must show $x + 4 = 2(k + 2)$. This holds by arithmetic.\n\nThe remaining part of the proof is left to the reader.\n-/\n\n\nnamespace exlean -- hide\n\nnamespace even_sets -- hide\n\n/-\n## Task\nBelow, I have given one direction of the proof that `even = even'`.\nIn particular, I have proved `even x \u2192 even' x` (for a given `x : \u2124`).\nYour task is to replace `sorry` with a proof that `even' x \u2192 even x`.\n-/\n\n/- Theorem : no-side-bar\n$\\mathsf{even} = \\mathsf{even}'$.\n-/\ntheorem even_eq_even' : even = even' :=\nbegin\n", "proof": "  ext x, -- By the principle of extensionality, it suffices to ...\n  show (even x \u2194 even' x),\n  split,\n  { show even x \u2192 even' x,\n    assume h : even x,\n    given h : \u2203 (m : \u2124), x = 2 * m,\n    cases h with k h\u2082,\n    given h\u2082 : x = 2 * k,\n    show \u2203 (m : \u2124), x + 4 = 2 * m,\n    use k + 2,\n    linarith, },\n  { show even' x \u2192 even x,\n    assume h : even' x,\n    given h : \u2203 (m : \u2124), x + 4 = 2 * m,\n    cases h with k h\u2082,\n    given h\u2082 : x + 4 = 2 * k,\n    show \u2203 (m : \u2124), x = 2 * m,\n    use k - 2,\n    linarith, }\n/- hint\next x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }\n-/\n\n\n\n\n\n", "proof_hint": "ext x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }", "textAfter": "\nend\n\nend even_sets -- hide\n\nend exlean -- hide", "height": 39, "editorText": "ext x,\nshow (even x \u2194 even' x),\nsplit,\n{ show even x \u2192 even' x,\n  assume h : even x,\n  given h : \u2203 (m : \u2124), x = 2 * m,\n  cases h with k h\u2082,\n  given h\u2082 : x = 2 * k,\n  show \u2203 (m : \u2124), x + 4 = 2 * m,\n  use k + 2,\n  linarith, },\n{ sorry, }", "lineOffset": 58, "name": "even_eq_even'", "statement": "even = even'"}, {"type": "lean", "content": "1003", "hidden": true}, {"type": "lean", "content": "1004", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1005", "hidden": true}, {"type": "text", "content": "1006"}, {"type": "lean", "content": "1007", "hidden": true}, {"type": "text", "content": "1008"}, {"type": "text", "content": "1009"}, {"type": "lean", "content": "1010", "hidden": false}, {"type": "text", "content": "1011"}, {"type": "theorem", "text": "1012", "lean": "theorem seven_in_unusual_set :\n(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4} :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 64, "textBefore": "import sets.even_even -- hide\n\n/-\n# Sets\n## Level 3: Set constructor notation\n\nLet $S$ be a predicate on a type $X$. Thus $S$ can be viewed\nas a set of elements of type $X$. It is common to represent the\nset $S$ via the 'set constructor' notation as\n$\\\\{x : X \\mid S(x)\\\\}$. \n\nHere, for example, is an definition, using set constructor notation,\nof the set of even integers.\n$T := \\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n = 2m \\\\}$.\n-/\n\nnamespace exlean -- hide\n\n/-\nLet's show that $6 \\in T$.\n\n**Proof**: by definition, we must show $\\exists (m : \\mathbb Z),\\\n6 = 2m$. Take $m$ to be $3$. We show $2 = 2 \\times 3$ by \narithmetic. \u220e\n-/\n\n/-\nBelow is the proof of this result in Lean. Note the use\nof `(6 : \u2124)` to let Lean know we're working with the integer `6`\nand not the natural number `6`.\n-/\n\nexample : (6 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n = 2 * m} :=\nbegin\n  show \u2203 (m : \u2124), 6 = 2 * m,\n  use 3,\n  show (6 : \u2124) = 2 * 3, linarith,\nend\n\n\n\n\n/-\n## Task\nAdapt the proof above to show that the integer $7$ belongs to the set\n$\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n-/\n\n\n\n/- Theorem : no-side-bar\n$7\\in\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n-/\ntheorem seven_in_unusual_set :\n(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4} :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 7 + 1 = 2 * m + 4,\n  use 2,\n  show (7 + 1 : \u2124) = 2 * 2 + 4, linarith,\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 56, "name": "seven_in_unusual_set", "statement": "(7 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n + 1 = 2 * m + 4}"}, {"type": "lean", "content": "1013", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "1014", "hidden": true}, {"type": "text", "content": "1015"}, {"type": "lean", "content": "1016", "hidden": true}, {"type": "text", "content": "1017"}, {"type": "lean", "content": "1018", "hidden": true}, {"type": "lean", "content": "1019", "hidden": false}, {"type": "lean", "content": "1020", "hidden": true}, {"type": "lean", "content": "1021", "hidden": false}, {"type": "text", "content": "1022"}, {"type": "tactic", "content": "1023", "name": "dec_trivial", "sideBar": true}, {"type": "lean", "content": "1024", "hidden": false}, {"type": "lean", "content": "1025", "hidden": true}, {"type": "text", "content": "1026"}, {"type": "lean", "content": "1027", "hidden": true}, {"type": "lean", "content": "1028", "hidden": false}, {"type": "lean", "content": "1029", "hidden": true}, {"type": "lean", "content": "1030", "hidden": false}, {"type": "lean", "content": "1031", "hidden": true}, {"type": "lean", "content": "1032", "hidden": false}, {"type": "theorem", "text": "1033", "lean": "theorem which_set_equal :\n((S = T) \u2228 (S = U)) \u2228 (T = U) :=\n", "sideBar": false, "firstProofLineNumber": 78, "lastProofLineNumber": 81, "textBefore": "import sets.set_constructor  -- hide\n\n/-\n# Sets\n## Level 4: Finite sets\n\nThe set of natural numbers represented by $\\\\{1, 3, 7\\\\}$\nis the predicate $S$ on $\\mathbb N$ given by\n$S(x) := (x = 1) \\lor (x = 3) \\lor (x = 7)$.\n\nLikewise, the set $\\\\{3, 7, 3, 1\\\\}$ is the predicate $T$ on\n$\\mathbb N$ given by\n$T(x) := (x = 3) \\lor (x = 7) \\lor (x = 3) \\lor (x = 1)$.\n\nClearly, $\\forall(x : X),\\ x \\in S \\leftrightarrow x \\in T$. Thus,\n$S$ and $T$ are equal. \n-/\n\nnamespace exlean -- hide\n\n\n/-\nIn Lean, we use `finset` to define finite sets.\n-/\n\nnamespace finset_test1 -- hide\n\ndef S : finset \u2115 := {1, 3, 7}\n\n-- hide\n\ndef T : finset \u2115 := {3, 7, 3, 1}\n\n/-\nResults that can be proved trivially by applying an algorithm (decidability) are proved in Lean\nusing `dec_trivial`. We can prove `S = T` using `dec_trivial`.\n-/\n\n/- Tactic : dec_trivial\nIf Lean knows that a given statement is 'decidable' (that is, it is given an algorithm for\ndetermining whether the statement is true or false), then `dec_trivial` can be used to prove the\ntheorem.\n-/\n\nexample : S = T :=\nbegin\n  dec_trivial,\nend\n\n\nend finset_test1  -- hide\n\n\n/-\n## Task\nProve that two of the sets below are equal.\n-/\n\nnamespace finset_test2 -- hide\n\ndef S : finset \u2115 := {3, 2, 3, 5}\n\n-- hide\n\ndef T : finset \u2115 := {2, 5, 1, 3}\n\n-- hide\n\ndef U : finset \u2115 := {2, 5, 3, 5}\n\n\n/- Theorem : no-side-bar\n$((S = T) \\lor (S = U)) \\lor (T = U)$.\n-/\ntheorem which_set_equal :\n((S = T) \u2228 (S = U)) \u2228 (T = U) :=\nbegin\n", "proof": "  dec_trivial,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend finset_test2 -- hide\n\nend exlean -- hide", "height": 4, "editorText": "sorry", "lineOffset": 77, "name": "which_set_equal", "statement": "((S = T) \u2228 (S = U)) \u2228 (T = U)"}, {"type": "lean", "content": "1034", "hidden": true}, {"type": "lean", "content": "1035", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1036", "hidden": true}, {"type": "text", "content": "1037"}, {"type": "lean", "content": "1038", "hidden": true}, {"type": "text", "content": "1039"}, {"type": "lean", "content": "1040", "hidden": true}, {"type": "lean", "content": "1041", "hidden": false}, {"type": "lean", "content": "1042", "hidden": true}, {"type": "lean", "content": "1043", "hidden": true}, {"type": "lean", "content": "1044", "hidden": false}, {"type": "lean", "content": "1045", "hidden": true}, {"type": "text", "content": "1046"}, {"type": "lean", "content": "1047", "hidden": true}, {"type": "lean", "content": "1048", "hidden": true}, {"type": "lean", "content": "1049", "hidden": false}, {"type": "theorem", "text": "1050", "lean": "theorem find_size_of_S :\n\u2203 (m : \u2115), card S = m :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 65, "textBefore": "import sets.finite_sets  -- hide\n\n/-\n# Sets\n## Level 5: The size of finite sets\n\nLet $S$ be a set on a type $X$. For a natural number $n$ to be the *size* of\n$S$ means that $n$ is the smallest natural number for which $S$ can be\nexpressed as $\\\\{a_1, \\dots, a_n\\\\}$. We write $|S|$ for the size of $S$. \n\nFor example, the size of the set $\\\\{1, 3, 4, 3, 1\\\\}$ of integers is $3$\nas the set can be expressed as $\\\\{1, 3, 4\\\\}$ but as no smaller set.\n\nIn Lean, the size (more formally called the *cardinality*) of a finite set `S`\nis denoted by `card S`.\n-/\n\nnamespace exlean -- hide\n\n\n/-\nEquations involving cardinalities of sets can be proved trivially by\ndecidability, as below.\n-/\n\nnamespace finset_test3 -- hide\n\ndef S : finset \u2115 := {1, 3, 7}\n\n-- hide\n\nopen finset -- hide\n\nexample : \u2203 (m : \u2115), card S = m :=\nbegin\n  use 3,\n  dec_trivial,\nend\n\nend finset_test3  -- hide\n\n\n/-\n## Task\nFind the cardinality of the given set.\n-/\n\nnamespace finset_test4 -- hide\n\nopen finset -- hide\n\ndef S : finset \u2115 := {3, 2, 3, 5, 1, 2, 7, 5}\n\n/- Theorem : no-side-bar\nGiven $S = \\\\{3, 2, 3, 5, 1, 2, 7, 5\\\\}$,\n$\\exists (m : \\mathbb N),\\ |S| = m$.\n-/\ntheorem find_size_of_S :\n\u2203 (m : \u2115), card S = m :=\nbegin\n", "proof": "  use 5,\n  dec_trivial,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend finset_test4 -- hide\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 60, "name": "find_size_of_S", "statement": "\u2203 (m : \u2115), card S = m"}, {"type": "lean", "content": "1051", "hidden": true}, {"type": "lean", "content": "1052", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "1053", "hidden": true}, {"type": "text", "content": "1054"}, {"type": "lean", "content": "1055", "hidden": true}, {"type": "text", "content": "1056"}, {"type": "text", "content": "1057"}, {"type": "lean", "content": "1058", "hidden": true}, {"type": "axiom", "content": "1059", "name": "vacuous_truth :", "sideBar": true}, {"type": "lean", "content": "1060", "hidden": false}, {"type": "lean", "content": "1061", "hidden": true}, {"type": "text", "content": "1062"}, {"type": "text", "content": "1063"}, {"type": "lean", "content": "1064", "hidden": false}, {"type": "lean", "content": "1065", "hidden": true}, {"type": "lean", "content": "1066", "hidden": false}, {"type": "text", "content": "1067"}, {"type": "hint", "content": "1068", "title": "1069"}, {"type": "theorem", "text": "1070", "lean": "theorem eq_five_of_in_S :\n\u2200 (x : \u2115), x \u2208 S \u2192 x = 5 :=\n", "sideBar": false, "firstProofLineNumber": 111, "lastProofLineNumber": 117, "textBefore": "import sets.finite_sets_cardinality  -- hide\n\n/-\n# Sets\n## Level 6: The empty set\n\nGiven a type $X$, the empty set on $X$, denoted $\\varnothing$, is the set\ndefined so that $x \\in \\varnothing$ means $\\bot$.\n\nEqually, $\\varnothing$ can be viewed as the predicate $\\varnothing : X \\to \\mathsf{Prop}$\ndefined by $\\varnothing(x) := \\bot$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\nThis definition gives rise to the interesting fact that, for any predicate $P$, the proposition\n$P(x)$ is *always* true on the assumption that $x \\in \\varnothing$.\n\n**Theorem**: Let $X$ be a type and let $P$ be a predicate on $X$. Then\n$\\forall (x : X),\\ x \\in \\varnothing \\to P(x)$.\n\n**Proof**: Assume $x : X$. Assume $h : x \\in \\varnothing$. But this just means\n$h : \\bot$. From false elimination on $h$, we show $P(x)$. \u220e\n-/\n\n/-\nBelow is a Lean proof of the result. In Lean, we must specify the type of the empty set.\nHere, we are concerned with `\u2205 : set X`, the empty set of elements of type `X`.\n\nThe symbol `\u2205` is typed `\\empty`.\n-/\n\nvariables {X : Type*} {P : X \u2192 Prop} -- hide\n\n/- Axiom : vacuous_truth :\n\u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x)\n-/\n\nlemma vacuous_truth : \u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x) :=\nbegin\n  assume x : X,\n  assume h : x \u2208 \u2205,\n  given h : false,\n  from false.elim h,\nend\n\nnamespace empty_set1 -- hide\n\n/-\nAs another example, let $S$ be the set of natural numbers defined by\n$S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$. We'll show that $S = \\varnothing$.\n\n**Proof**: We must show (by extensionality), that given $n : \\mathbb N$,\n$n \\in S \\leftrightarrow n \\in \\varnothing$.\n\nThat is, we must show both $n \\in S \\to n \\in \\varnothing$ and\n$n \\in \\varnothing \\to n\\in S$.\n\n1. Assume $h : n \\in S$. That is, $h : n < 0$. This gives false, by arithmetic.\n2. Assume $h : n \\in \\varnothing$. That is, $h : \\bot$.\nWe show $n \\in S$ by false elimination on $h$. \u220e\n-/\n\n/-\nThis can be proved in Lean as follows.\n-/\n\ndef S : set \u2115 := {n : \u2115 | n < 0}   \n\n-- hide\n\nlemma empty_S : S = \u2205 :=\nbegin\n  ext n,\n  show n \u2208 S \u2194 n \u2208 \u2205, \n  split,\n  { show n \u2208 S \u2192 n \u2208 \u2205,\n    assume h : n \u2208 S,\n    given h : n < 0,\n    show false, linarith, },\n  { show n \u2208 \u2205 \u2192 n \u2208 S,\n    assume h : n \u2208 \u2205,\n    given h : false,\n    show n \u2208 S, from false.elim h, },\nend\n\n\n/-\n## Task\nSuppose $S$ is the set of natural numbers given by $S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$.\nUsing the two theorems given above, prove \n$\\forall (x : \\mathbb N),\\ x \\in S \\to x = 5$.\n-/\n\n/- Hint : Starting the proof\n\nA good starting point is to rewrite the theorem statement using one of the results given\nin this level.\n\nYou should be able to complete the proof using one more line.\n-/\n\n/- Theorem : no-side-bar\n$\\forall (x : \\mathbb N)\\, x \\in S \\to x = 5$.\n-/\ntheorem eq_five_of_in_S :\n\u2200 (x : \u2115), x \u2208 S \u2192 x = 5 :=\nbegin\n", "proof": "  rw empty_S,\n  from vacuous_truth,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend empty_set1 -- hide\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 110, "name": "eq_five_of_in_S", "statement": "\u2200 (x : \u2115), x \u2208 S \u2192 x = 5"}, {"type": "lean", "content": "1071", "hidden": true}, {"type": "lean", "content": "1072", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1073", "hidden": true}, {"type": "text", "content": "1074"}, {"type": "lean", "content": "1075", "hidden": true}, {"type": "text", "content": "1076"}, {"type": "text", "content": "1077"}, {"type": "lean", "content": "1078", "hidden": true}, {"type": "axiom", "content": "1079", "name": "subset_rfl :", "sideBar": true}, {"type": "lean", "content": "1080", "hidden": false}, {"type": "text", "content": "1081"}, {"type": "axiom", "content": "1082", "name": "subset_antisymm (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) :", "sideBar": true}, {"type": "lean", "content": "1083", "hidden": false}, {"type": "text", "content": "1084"}, {"type": "theorem", "text": "1085", "lean": "theorem subset_trans {S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U :=\n", "sideBar": true, "firstProofLineNumber": 92, "lastProofLineNumber": 104, "textBefore": "import sets.empty_set  -- hide\n\n/-\n# Sets\n## Level 7 : Subsets\n\nLet $S$ and $T$ be sets on a type $X$. For $S$ to be a subset of $T$,\nwritten $S \\subseteq T$, means\n$\\forall (x : X),\\ x \\in S \\to x \\in T$.\n\nThis is abbreviated to $\\forall x \\in S,\\ x \\in T$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem** [Reflexivity of subset]:\nLet $X$ be a type and let $S$ be a set on $X$. Then $S \\subseteq S$.\n\n**Proof**: We must show $\\forall (x : X),\\ x \\in S \\to x \\in S$.\nAssume $x : X$. Assume $h : x \\in S$. We show $x \\in S$, from $h$. \u220e\n-/\n\n/-\nIn Lean, we write `\u2286` as `\\sub`. Below, we prove reflexivity of `\u2286` in Lean.\n-/\n\nvariable {X : Type*} -- hide\n\n/- Axiom : subset_rfl :\nS \u2286 S\n-/\n\nlemma subset_rfl {S : set X} : S \u2286 S :=\nbegin\n  show \u2200 x \u2208 S, x \u2208 S,\n  assume x : X,\n  assume h : x \u2208 S,\n  show x \u2208 S, from h,\nend\n\n/-\nAbove we *proved* a subset result. Let's now *use* subset assumptions to prove\nanother result. The result we're interested in is 'antisymmetry' of the subset relation.\nThat is, on the assumptions that $h_1 : S \\subseteq T$ and $h_2 : T \\subseteq S$, we'll prove $S = T$.\n\n**Proof**: We must show $S = T$. That is, we must show $x \\in S \\leftrightarrow x \\in T$\n(given $x : X$). This requires proving each direction of the double implication.\n\n1. We'll show $x \\in S \\to x \\in T$. Assume $h : x \\in S$. We show $x \\in T$ from $h_1$ and $h$.\n2. We'll show $x \\in T \\to x \\in S$. Assume $h : x \\in T$. We show $x \\in S$ from $h_2$ and $h$.\n\u220e\n\nIn the proof above, our 'from $h_1 : S \\subseteq T$ and $h : x \\in S$ is a combination of\nfor all elimination and implication elimination. The same idiom is accessible in the Lean proof below.\n-/\n\n\n/- Axiom : subset_antisymm (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) :\nS = T \n-/\n\ntheorem subset_antisymm {S T : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) : S = T :=\nbegin\n  ext x,\n  show x \u2208 S \u2194 x \u2208 T,\n  split,\n  { show x \u2208 S \u2192 x \u2208 T,\n    assume h : x \u2208 S,\n    show x \u2208 T, from h\u2081 h, },\n  { show x \u2208 T \u2192 x \u2208 S,\n    assume h : x \u2208 T,\n    show x \u2208 S, from h\u2082 h, }\nend\n\n/-\n## Task\nProve the transitivity of $\\subseteq$. That is, given sets $S$, $T$, and $U$\non a type $X$, prove that if $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n\nYou may draw inspiration from parts of the proof of antisymmetry.\n-/\n\n\n/- Theorem :\nGiven sets $S$, $T$, and $U$\non a type $X$, one has $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n-/\ntheorem subset_trans {S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U :=\nbegin\n", "proof": "  show \u2200 x \u2208 S, x \u2208 U,\n  assume x : X,\n  assume h : x \u2208 S,\n  have h\u2083 : x \u2208 T, from h\u2081 h,\n  show x \u2208 U, from h\u2082 h\u2083, \n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 91, "name": "subset_trans", "statement": "{S T U : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 U) : S \u2286 U"}, {"type": "lean", "content": "1086", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1087", "hidden": true}, {"type": "text", "content": "1088"}, {"type": "lean", "content": "1089", "hidden": true}, {"type": "text", "content": "1090"}, {"type": "text", "content": "1091"}, {"type": "tactic", "content": "1092", "name": "tauto!", "sideBar": true}, {"type": "lean", "content": "1093", "hidden": true}, {"type": "lean", "content": "1094", "hidden": false}, {"type": "text", "content": "1095"}, {"type": "text", "content": "1096"}, {"type": "lean", "content": "1097", "hidden": false}, {"type": "text", "content": "1098"}, {"type": "theorem", "text": "1099", "lean": "theorem inter_union_distrib_left {S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U) :=\n", "sideBar": true, "firstProofLineNumber": 86, "lastProofLineNumber": 98, "textBefore": "import sets.subset -- hide\n\n/-\n# Sets\n## Level 8 : Intersection and Union\n\n### Intersection\n\nLet $S$ and $T$ be sets on a type $X$. The *intersection* of $S$ and $T$, written $S \\cap T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\in T) \\\\}$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem** [Commutativity of intersection]:\nLet $X$ be a type and let $S$ and $T$ be sets on $X$. Then $S \\cap T = T \\cap S$.\n\n**Proof**: We must show $x \\in S \\cap T \\leftrightarrow x \\in T \\cap S$, given $x : X$.\nWe prove this by calculation.\n\\begin{align}\nx \\in S \\cap T  &\\leftrightarrow (x \\in S) \\land  (x \\in T) & & \\text{[by definition]} \\\\\\\\\n&\\leftrightarrow (x \\in T) \\land  (x \\in S)& &\\text{[by logic]} \\\\\\\\\n&\\leftrightarrow  x \\in T \\cap S.  & &\\text{[by definition]}\n\\end{align} \u220e\n-/\n\n/-\nIn Lean, we write `\u2229` as `\\i`. Below, we prove commutativity of `\u2229`. \nWe use the Lean tactic `tauto!`, which proves any result in propositional logic.\n-/\n\n/- Tactic : tauto!\nProves any result in propositional logic.\n-/\n\nvariable {X : Type*} -- hide\n\n\nlemma inter_comm (S T : set X) : S \u2229 T = T \u2229 S :=\nbegin\n  ext x,\n  show x \u2208 S \u2229 T \u2194 x \u2208 T \u2229 S,\n  calc x \u2208 S \u2229 T \u2194 (x \u2208 S) \u2227 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2227 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u2229 S           : by refl\nend\n\n\n/-\n### Union\n\nLet $S$ and $T$ be sets on a type $X$. The *union* of $S$ and $T$, written $S \\cup T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\lor (x \\in T) \\\\}$.\n-/\n\n/-\nIn Lean, we write `\u222a` as `\\un`. Below is a Lean proof of the commutativity of union.\n-/\n\nlemma union_comm (S T : set X) : S \u222a T = T \u222a S :=\nbegin\n  ext x,\n  show x \u2208 S \u222a T \u2194 x \u2208 T \u222a S,\n  calc\n  x \u2208 S \u222a T \u2194 (x \u2208 S) \u2228 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2228 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u222a S           : by refl\nend\n\n/-\n## Task\nProve the left distributivity of intersection over union. That is, given sets $S$, $T$, $U$\nof a type $X$, prove $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n\nTry a 'proof by calculation', as above. You should need only three calculation lines.\n-/\n\n/- Theorem :\nGiven sets $S$, $T$, and $U$\non a type $X$, one has  $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n-/\ntheorem inter_union_distrib_left {S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 S \u2229 (T \u222a U) \u2194 x \u2208 (S \u2229 T) \u222a (S \u2229 U),\n  calc\n  x \u2208 S \u2229 (T \u222a U) \u2194  (x \u2208 S) \u2227 ((x \u2208 T) \u2228 (x \u2208 U))   :  by refl\n    ... \u2194  ((x \u2208 S) \u2227 (x \u2208 T)) \u2228 ((x \u2208 S) \u2227 (x \u2208 U)) : by tauto!\n    ... \u2194 x \u2208 (S \u2229 T) \u222a (S \u2229 U)                      :  by refl,\n  \n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 85, "name": "inter_union_distrib_left", "statement": "{S T U : set X} : S \u2229 (T \u222a U) = (S \u2229 T) \u222a (S \u2229 U)"}, {"type": "lean", "content": "1100", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1101", "hidden": true}, {"type": "text", "content": "1102"}, {"type": "lean", "content": "1103", "hidden": true}, {"type": "lean", "content": "1104", "hidden": true}, {"type": "text", "content": "1105"}, {"type": "axiom", "content": "1106", "name": "subset_union_left :", "sideBar": true}, {"type": "lean", "content": "1107", "hidden": false}, {"type": "text", "content": "1108"}, {"type": "theorem", "text": "1109", "lean": "theorem subset_union_right : T \u2286 S \u222a T :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 55, "textBefore": "import sets.intersection_union -- hide\n\n/-\n# Sets\n## Level 9 : Union and subset\n\nIn this level, we'll see that $S \\subseteq S \\cup T$ and\n$T \\subseteq S \\subset T$.\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {S T : set X} -- hide\n\n/-\nWe begin with a Lean proof of $S \\subseteq S \\cup T$.\n-/\n\n/- Axiom : subset_union_left :\nS \u2286 S \u222a T\n-/\n\nlemma subset_union_left : S \u2286 S \u222a T :=\nbegin\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2208 S \u222a T,\n  assume x : X,\n  assume h : x \u2208 S,\n  show (x \u2208 S) \u2228 (x \u2208 T), from or.inl h,\nend\n\n/-\n## Task\nShow that $T \\subseteq S \\cup T$. Do this in two different ways.\n\n1. Prove $T \\subseteq S \\cup T$ by adapting the proof above.\n2. Give a backward proof of $T \\subseteq S \\cup T$ as follows: first\nrewrite with commutativity of union; then use the result above.\n-/\n\n/- Theorem :\nGiven sets $S$ and $T$, one has $T \\subseteq S \\cup T$.\n-/\ntheorem subset_union_right : T \u2286 S \u222a T :=\nbegin\n", "proof": "  rw union_comm, show T \u2286 T \u222a S,\n  from subset_union_left,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 44, "name": "subset_union_right", "statement": "T \u2286 S \u222a T"}, {"type": "lean", "content": "1110", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1111", "hidden": true}, {"type": "text", "content": "1112"}, {"type": "lean", "content": "1113", "hidden": true}, {"type": "text", "content": "1114"}, {"type": "lean", "content": "1115", "hidden": true}, {"type": "text", "content": "1116"}, {"type": "theorem", "text": "1117", "lean": "theorem subset_inter_iff {S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T) :=\n", "sideBar": true, "firstProofLineNumber": 48, "firstProofHintLineNumber": 75, "lastProofHintLineNumber": 89, "lastProofLineNumber": 90, "textBefore": "import sets.subset_union -- hide\n\n/-\n# Sets\n## Level 10 : Intersections and subsets\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Theorem**:\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$.\n\n**Sketch proof**: We must show both directions of the double implication.\n\n1. We'll show $U \\subseteq (S \\cap T) \\to (U \\subseteq S) \\land (U \\subseteq T)$\nAssume $h : U \\subseteq (S \\cap T)$. We'll show $(U \\subseteq S) \\land (U \\subseteq T)$.\nTo prove this is to prove two statements.\n\n  1.1. We'll show $U \\subseteq S$. Assume $x : X$. Assume $h_2 : x \\in U$. We must show\n    $x \\in S$.  We have $h_3 : x \\in S \\cap T$, from $h$ and $h_2$. The remainder of this\n    subproof is left for the reader.\n\n\n  1.2. We'll show $U \\subseteq T$. Do this yourself.\n\n\n2. We'll show $(U \\subseteq S) \\land (U \\subseteq T) \\to U \\subseteq (S \\cap T)$. Or rather,\nyou'll show this!  \u220e\n-/\n\nvariable {X : Type*} -- hide\n\n/-\n## Task\nComplete the Lean proof below of the theorem above.\n-/\n\n/- Theorem :\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$\n-/\ntheorem subset_inter_iff {S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T) :=\nbegin\n", "proof": "  split,\n  { show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T),\n    assume h : U \u2286 (S \u2229 T),\n    show (U \u2286 S) \u2227 (U \u2286 T),\n    split,\n    { assume x : X,\n      assume h\u2082 : x \u2208 U,\n      show x \u2208 S,\n      have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n      show x \u2208 S, from h\u2083.left, },\n    { assume x : X,\n      assume h\u2082 : x \u2208 U,\n      show x \u2208 T,\n      have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n      show x \u2208 T, from h\u2083.right, }, },\n  { show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T),\n    assume h : (U \u2286 S) \u2227 (U \u2286 T),\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show (x \u2208 S) \u2227 (x \u2208 T),\n    cases h with h\u2083 h\u2084,\n    given h\u2083 : U \u2286 S,\n    given h\u2084 : U \u2286 T,\n    have h\u2085 : x \u2208 S, from h\u2083 h\u2082,\n    have h\u2086 : x \u2208 T, from h\u2084 h\u2082,\n    show x \u2208 S \u2227 x \u2208 T, from and.intro h\u2085 h\u2086, },\n/- hint\nsplit,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },\n-/", "proof_hint": "split,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 43, "editorText": "split,\n{ show U \u2286 (S \u2229 T) \u2192 (U \u2286 S) \u2227 (U \u2286 T), -- Part 1 of proof.\n  assume h : U \u2286 (S \u2229 T),\n  show (U \u2286 S) \u2227 (U \u2286 T),\n  split,\n  { show U \u2286 S,                          -- Part 1.1.\n    assume x : X,\n    assume h\u2082 : x \u2208 U,\n    show x \u2208 S,\n    have h\u2083 : x \u2208 S \u2229 T, from h h\u2082,\n    sorry },\n  { show U \u2286 T,                          -- Part 1.2.\n    sorry, }, },\n{ show (U \u2286 S) \u2227 (U \u2286 T) \u2192 U \u2286 (S \u2229 T), -- Part 2.\n  sorry, },", "lineOffset": 47, "name": "subset_inter_iff", "statement": "{S T U : set X} :\nU \u2286 (S \u2229 T) \u2194 (U \u2286 S) \u2227 (U \u2286 T)"}, {"type": "lean", "content": "1118", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1119", "hidden": true}, {"type": "text", "content": "1120"}, {"type": "lean", "content": "1121", "hidden": true}, {"type": "lean", "content": "1122", "hidden": true}, {"type": "text", "content": "1123"}, {"type": "theorem", "text": "1124", "lean": "theorem diff_inter_diff {S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U) :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 42, "textBefore": "import sets.subset_inter -- hide\n\n/-\n# Sets\n## Level 11: Set difference\n\nLet $S$ and $T$ be sets on a type $X$. The *set difference* of $S$ and $T$, written $S \\setminus T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\notin T) \\\\}$.\n\n\n-/\n\n\nvariable {X : Type*} -- hide\n\n\nnamespace exlean -- hide\n\n/-\n## Task\nComplete the proof below.\n-/\n\n/- Theorem :\nLet $S$, $T$, and $U$ be sets on a type $X$, then\n$(S \\setminus T)  \\cap (S \\setminus U) = S \\setminus (T \\cup U)$.\n-/\ntheorem diff_inter_diff {S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 S \\ T \u2229 (S \\ U) \u2194 x \u2208 S \\ (T \u222a U),\n  calc\n  x \u2208 S \\ T \u2229 (S \\ U) \u2194 (x \u2208 S \u2227 x \u2209 T) \u2227 (x \u2208 S \u2227 x \u2209 U) : by refl \n  ... \u2194 (x \u2208 S) \u2227 (x \u2209 T \u2227 x \u2209 U)               : by tauto!\n  ... \u2194 (x \u2208 S) \u2227 \u00ac(x \u2208 T \u2228 x \u2208 U)              : by tauto!\n  ... \u2194   x \u2208 S \\ (T \u222a U)                       : by refl,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 30, "name": "diff_inter_diff", "statement": "{S T U : set X} :\n(S \\ T) \u2229 (S \\ U) = S \\ (T \u222a U)"}, {"type": "lean", "content": "1125", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "1126", "hidden": true}, {"type": "text", "content": "1127"}, {"type": "text", "content": "1128"}, {"type": "text", "content": "1129"}, {"type": "lean", "content": "1130", "hidden": true}, {"type": "lean", "content": "1131", "hidden": true}, {"type": "axiom", "content": "1132", "name": "union_prod {A B : set X} {S : set Y} :", "sideBar": true}, {"type": "lean", "content": "1133", "hidden": false}, {"type": "text", "content": "1134"}, {"type": "theorem", "text": "1135", "lean": "theorem inter_prod {A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S) :=\n", "sideBar": true, "firstProofLineNumber": 59, "lastProofLineNumber": 70, "textBefore": "import sets.set_difference -- hide\n\n/-\n# Sets\n## Level 12: Cartesian product\n\nLet $X$ and $Y$ be types. The *Cartesian product* of $X$ and $Y$, written $X \\times Y$, is the set of pairs\n$(x, y)$, where $x : X$ and $y : Y$. Given a term $z : X \\times Y$, we write $z = (z_1, z_2)$.\n\n\nLet $S$ be a set on $X$ and let $T$ be a set on $Y$. The *Cartesian product*\nof $S$ and $T$ is the set $\\\\{z : X \\times Y \\mid (z_1 \\in S) \\land (z_2 \\in T) \\\\}$.\n-/\n\n/-\nIn Lean, we write `X \u00d7 Y` for the Cartesian product of types `X` and `Y`, where `\u00d7` is typed `\\x`.\n\nLikewise, we write `S \u00d7\u02e2 T` for the Cartesian product of two sets `S` and `T`. Here, `\u00d7\u02e2` is typed `\\x\\^s`.\n\nGiven `z : X \u00d7 Y`, we write `z.fst` and `z.snd` for the first and second elements of the pair `z`. Thus,\n`z = (z.fst, z.snd)`.\n-/\n\n/-\nBelow is a Lean proof of the mathematical result $(A \\cup B) \\times S = (A \\times S) \\cup (B \\times S)$.\n-/\n\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} -- hide\n\n/- Axiom : union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S)\n-/\n\nlemma union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S) :=\nbegin\n  ext x,\n  show x \u2208 (A \u222a B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u222a B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2228 x.fst \u2208 B) \u2227 x.snd \u2208 S : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2228 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S                               : by refl\nend\n\n/-\n## Task\nProve that $(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n-/\n\n/- Theorem :\n$(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n-/\ntheorem inter_prod {A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S) :=\nbegin\n", "proof": "  ext x,\n  show x \u2208 (A \u2229 B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u2229 B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u2229 B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2227 x.fst \u2208 B) \u2227 x.snd \u2208 S   : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2227 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u2229 B \u00d7\u02e2 S                                 : by refl\n\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 58, "name": "inter_prod", "statement": "{A B : set X} {S : set Y} :\n(A \u2229 B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u2229 (B \u00d7\u02e2 S)"}, {"type": "lean", "content": "1136", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1137", "hidden": true}, {"type": "text", "content": "1138"}, {"type": "text", "content": "1139"}, {"type": "lean", "content": "1140", "hidden": true}, {"type": "lean", "content": "1141", "hidden": true}, {"type": "text", "content": "1142"}, {"type": "lean", "content": "1143", "hidden": false}, {"type": "text", "content": "1144"}, {"type": "theorem", "text": "1145", "lean": "theorem powerset_sub_power_of_sub {S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T) :=\n", "sideBar": true, "firstProofLineNumber": 53, "firstProofHintLineNumber": 61, "lastProofHintLineNumber": 62, "lastProofLineNumber": 69, "textBefore": "import sets.union_prod -- hide\n\n/-\n# Sets\n## Level 13: Power set\n\nLet $S$ be a set on a type $X$. The *power set* of $S$, denoted $\\mathcal P(S)$, is the set of\nall subsets of $S$.\n\nThat is, $A \\in \\mathcal P(S)$ means $A \\subseteq S$.\n\nIn set constructor notation, the definition of $\\mathcal P(S)$ is\n$\n\\mathcal P(S) := \\\\{A : \\text{set}\\ X \\mid A \\subseteq S\\\\}.\n$\n\nThis illustrates that the members $A$ of the set $\\mathcal P(S)$ are terms of\ntype $\\text{set} X$. That is, each $A$ is itself a set of elements of type $X$.\n-/\n\n/-\nIn Lean, the power set of `S` is written `\ud835\udcab(S)`, where `\ud835\udcab` is typed `\\power`.\n-/\n\nvariables {X : Type*} -- hide\n\nnamespace exlean -- hide\n\n/-\nHere is a Lean proof that $S \\in \\mathcal P(S)$, for every set $S$.\n-/\n\nexample (S : set X) : S \u2208 \ud835\udcab(S) :=\nbegin\n  show S \u2286 S,\n  from subset_refl S,\nend\n\n\n/-\n## Task\nProve that for all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n-/\n\n\n/- Theorem :\nFor all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n-/\ntheorem powerset_sub_power_of_sub {S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T) :=\nbegin\n", "proof": "  assume A : set X,\n  show A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),\n  assume h\u2082 : A \u2208 \ud835\udcab(S),\n  show A \u2208 \ud835\udcab(T),\n  show A \u2286 T,\n  given h\u2082 : A \u2286 S,\n  from subset_trans h\u2082 h, \n/- hint\nassume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),\n-/\n\n\n\n\n\n", "proof_hint": "assume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "assume A : set X,\nshow A \u2208 \ud835\udcab(S) \u2192 A \u2208 \ud835\udcab(T),", "lineOffset": 52, "name": "powerset_sub_power_of_sub", "statement": "{S T : set X} (h : S \u2286 T) : \ud835\udcab(S) \u2286 \ud835\udcab(T)"}, {"type": "lean", "content": "1146", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1147", "hidden": true}, {"type": "text", "content": "1148"}, {"type": "lean", "content": "1149", "hidden": true}, {"type": "lean", "content": "1150", "hidden": true}, {"type": "text", "content": "1151"}, {"type": "hint", "content": "1152", "title": "1153"}, {"type": "theorem", "text": "1154", "lean": "theorem powerset_inter {S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T) :=\n", "sideBar": true, "firstProofLineNumber": 33, "firstProofHintLineNumber": 40, "lastProofHintLineNumber": 41, "lastProofLineNumber": 46, "textBefore": "import sets.power_set -- hide\n\n/-\n# Sets\n## Level 14: Power sets and intersections\n-/\n\n\n\nvariables {X : Type*} -- hide\n\nnamespace exlean -- hide\n\n/-\n## Task\nProve, by calculation, that for all sets $S$ and $T$ on a type $X$, \n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n-/\n\n/- Hint : A useful result\nCheck the sidebar for a useful theorem you proved in a previous level\nof this world.\n-/\n\n\n\n/- Theorem : \nFor all sets $S$ and $T$ on a type $X$,\n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n-/\ntheorem powerset_inter {S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T) :=\nbegin\n", "proof": "  ext A,\n  show A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),\n  calc\n  A \u2208 \ud835\udcab(S \u2229 T) \u2194 A \u2286 S \u2229 T : by refl\n  ... \u2194 (A \u2286 S) \u2227 (A \u2286 T)  : set.subset_inter_iff\n  ... \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T)   : by refl\n/- hint\next A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),\n-/\n\n\n\n", "proof_hint": "ext A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "ext A,\nshow A \u2208 \ud835\udcab(S \u2229 T) \u2194  A \u2208 \ud835\udcab(S) \u2229 \ud835\udcab(T),", "lineOffset": 32, "name": "powerset_inter", "statement": "{S T : set X} : \ud835\udcab(S \u2229 T) = \ud835\udcab(S) \u2229 \ud835\udcab(T)"}, {"type": "lean", "content": "1155", "hidden": true}]}], "parents": [3]}, {"name": "1156", "levels": [{"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "1157", "hidden": true}, {"type": "text", "content": "1158"}, {"type": "lean", "content": "1159", "hidden": true}, {"type": "lean", "content": "1160", "hidden": true}, {"type": "lean", "content": "1161", "hidden": false}, {"type": "lean", "content": "1162", "hidden": true}, {"type": "lean", "content": "1163", "hidden": false}, {"type": "lean", "content": "1164", "hidden": true}, {"type": "text", "content": "1165"}, {"type": "lean", "content": "1166", "hidden": false}, {"type": "text", "content": "1167"}, {"type": "hint", "content": "1168", "title": "1169"}, {"type": "lean", "content": "1170", "hidden": true}, {"type": "lean", "content": "1171", "hidden": true}, {"type": "lean", "content": "1172", "hidden": false}, {"type": "lean", "content": "1173", "hidden": true}, {"type": "lean", "content": "1174", "hidden": true}, {"type": "lean", "content": "1175", "hidden": false}, {"type": "theorem", "text": "1176", "lean": "theorem func_equal (h : c ^ 3 + 4 * c ^ 2 - 11 * c - 30 = 0) : p = q :=\n", "sideBar": false, "firstProofLineNumber": 80, "lastProofLineNumber": 87, "textBefore": "import tactic.modded tactic.linarith -- hide\n\n/-\n# Functions\n## Level 1: Function extensionality\n\nLet $f : X \\to Y$ and $g : X \\to Y$ be functions. The principle of\nfunction extensionality asserts that $f = g$, given\n$\\forall(x : X),\\ f(x) = g(x)$.\n\n**Theorem**: Let $f : \\mathbb N \\to \\mathbb Z$ and \n$g : \\mathbb N \\to \\mathbb Z$ be functions given by\n$f(u) := 2u$ and $g(v) := v + v$. Then $f = g$.\n\n**Proof**: By the principle of extensionality, ot suffices to show that\n$\\forall(n : \\mathbb N),\\ f(n) = g(n)$. Assume $n : \\mathbb N$. We must show\n$f(n) = g(n)$. That is, $2n = n + n$. This holds by arithmetic.\n-/\n\n\n\nnamespace exlean -- hide\n\nnamespace function_test1 -- hide\n\ndef f : \u2115 \u2192 \u2124 := \u03bb u, 2 * u\n\n-- hide\n\ndef g : \u2115 \u2192 \u2124:= \u03bb v, v + v \n\n-- hide\n\n/-\nHere is a Lean proof of the result. We use the `ext` (extensionality)\ntactic with the variable `n` to replace the target of proving `f = g`\nwith the target of proving `f(n) = g(n)`, given `n : \u2115`.\n-/\n\nexample : f = g :=\nbegin\n  ext n,\n  show f(n) = g(n),\n  show (2 : \u2124) * n = n + n, linarith,\nend\n\n\n\n\n/-\n## Task\nLet $c$ be an integer. Let $p$ and $q$ be functions from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$p(u) := 30u$ and $q(v) := c(c^2 + 4c - 11)v$. Given that $h : c^3 + 4c^2 - 11c - 30 = 0$,\nprove that $p = q$.\n-/\n\n/- Hint : Proving an equation\nIn this exercise, you'll rewrite using an auxiliary equation, which can be proved using\n`linarith`.\n-/\n\nconstant c : \u2124 -- hide\n\n-- hide\n\ndef p : \u2124 \u2192 \u2124 := \u03bb u, 30 * u\n\n-- hide\n\nnoncomputable -- hide\ndef q : \u2124 \u2192 \u2124 := \u03bb v, c * (c^2 + 4 * c - 11) * v\n\n\n/- Theorem : no-side-bar\nLet $c$ be an integer. Let $p$ and $q$ be functions from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$p(u) := 30u$ and $q(v) := c(c^2 + 4c - 11)v$. Suppose $h : c^3 + 4c^2 - 11c - 30 = 0$. Then $p = q$.\n-/\ntheorem func_equal (h : c ^ 3 + 4 * c ^ 2 - 11 * c - 30 = 0) : p = q :=\nbegin\n", "proof": "  ext n,\n  show 30 * n = c * (c^2 + 4 * c - 11) * n,\n  have h\u2082 : c * (c ^2 + 4 * c - 11) = 30, linarith,\n  rw h\u2082,\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend function_test1 -- hide\n\nend exlean -- hide", "height": 8, "editorText": "sorry", "lineOffset": 79, "name": "func_equal", "statement": "(h : c ^ 3 + 4 * c ^ 2 - 11 * c - 30 = 0) : p = q"}, {"type": "lean", "content": "1177", "hidden": true}, {"type": "lean", "content": "1178", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1179", "hidden": true}, {"type": "text", "content": "1180"}, {"type": "tactic", "content": "1181", "name": "rcases", "sideBar": true}, {"type": "lean", "content": "1182", "hidden": true}, {"type": "lean", "content": "1183", "hidden": true}, {"type": "text", "content": "1184"}, {"type": "theorem", "text": "1185", "lean": "theorem image_subset (f : X \u2192 Y) : S \u2286 T \u2192 f '' S \u2286 f '' T :=\n", "sideBar": true, "firstProofLineNumber": 90, "firstProofHintLineNumber": 105, "lastProofHintLineNumber": 111, "lastProofLineNumber": 119, "textBefore": "import functions.function_extensionality -- hide\n\n/-\n# Functions\n## Level 2: Images of sets under functions \n\nLet $f : X \\to Y$ be a function and let $S$ be a set on $X$.\nThe *image* of $S$ under $f$, written $f(S)$, is the set\n$\n\\\\{y : Y \\mid \\exists(x : X), x \\in S \\land f(x) = y\\\\}.\n$\n\n**Theorem**: Let $f : X \\to Y$ be a function. Let $S$ and $T$ be sets of\nelements of $X$. If $S \\subseteq T$, then $f(S) \\subseteq f(T)$.\n\n**Proof**: Assume $h : S \\subseteq T$. We must show $f(S) \\subseteq f(T)$.\nAssume $y : Y$. Assume $h_2 : y \\in f(S)$. We must show $y \\in f(T)$.\nFrom $h_2$, we have $x : X$, $h_3 : x \\in S$, and $h_4 : f(x) = y$.\nWe must show $\\exists (z : X),\\ z \\in T \\land f(z) = y$. Take $z$ to be $x$.\nThen we must show $x \\in T \\land f(x) = y$. We prove each of these separately.\n\n1. We show $x \\in T$ from $h$ and $h_3$.\n\n2. We show $f(x) = y$, from $h_4$. \u220e\n\nIn the proof above, we implicitly perform exists elimination and both left and right\nand elimination when we decompose the hypothesis\n$h_2 : \\exists (x : X),\\ x \\in S \\land f(x) = y$.\n\nIn Lean, a compound expression such as this can be decomposed in one step using the `rcases`\n(for recursive cases) tactic.\n\nThis is used in the proof fragment below. The 'angle quotes' `\u27e8` and `\u27e9` are typed `\\<` and `\\>`.\n\nWe have the compound expression `h\u2082 : \u2203 (x : X), x \u2208 S \u2227 f(x) = y`.\n\nWe could perform a 'first level' decomposition by typing `rcases h\u2082 with \u27e8x, k\u2082 : x \u2208 S \u2227 f(x) = y\u27e9`, say.\nThis would be the same as `cases h\u2082 with x k\u2082` and would introduce a variable `x : X`\nand the assumption `k\u2082 : x \u2208 S \u2227 f(x) = y`. But the `k\u2082` can also be decomposed\n(via left and right and elimination).\n\nWe could do this by typing `cases k\u2082 with h\u2083 h\u2084`. Or we could decompose `h\u2082` entirely\nin one command by typing `rcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9`.\n\nEither way gives `h\u2083 : x \u2208 S` and `h\u2084 : f(x) = y`.\n\n**Note** that the image $f(S)$ is denoted in Lean by `f '' S`.\n-/\n\n/- Tactic : rcases\nUsed for recursive elimination.\n\n## Examples\n* If `h : a \u2227 b` then `rcases h with \u27e8h\u2081 : a, h\u2082 : b\u27e9` replaces `h` with two hypotheses,\n`h\u2081 : a` and `h\u2082 : b`.\n\n* If `h : \u2203 (x : X), P(x)`, then `rcases h with \u27e8x, h\u2082 : P(x)\u27e9` replaces `h` with `x : X`\nand `h\u2082 : P(x)`.  \n\n* If `h : a \u2228 b`, then `rcases h with (h\u2081 : a) | (h\u2082 : b)` replaces the goal with two new goals,\none with a hypothesis `h\u2081 : a` and one with a hypothesis `h\u2082 : b`.\n\n* If `h : a = b`, then `rcases h with rfl` replaces every occurence of `b` in the context\nwith `a`.\n\n* These rules can be used recursively. Thus if `\u2203 (x : \u2115), Q(x) \u2228 (P(x) \u2227 y = 2 * x)`,\nthen `rcases h with \u27e8x, (h\u2082 : Q(x)) | \u27e8h\u2083 : P(x), rfl\u27e9 \u27e9` replaces `h` and creates two new goals.\nEach goal contains `x : \u2115`. The context of the first goal contains contains `h\u2082 : Q(x)`.\nIn the second goal, every instance of `y` is replaced with `2 * x`. The context of the\nsecond goal  contains `h\u2083: P(x)`.\n-/\n\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {S T : set X}-- hide\n\n\n/-\n## Task\nComplete the proof of the theorem below.\n-/\n\n/- Theorem :\nLet $f : X \\to Y$ be a function. Let $S$ and $T$ be sets of\nelements of $X$. If $S \\subseteq T$, then $f(S) \\subseteq f(T)$.\n-/\ntheorem image_subset (f : X \u2192 Y) : S \u2286 T \u2192 f '' S \u2286 f '' T :=\nbegin\n", "proof": "  assume h : S \u2286 T,\n  show f '' S \u2286 f '' T,\n  assume y : Y,\n  assume h\u2082 : y \u2208 f '' S,\n  given h\u2082: \u2203 (x : X), x \u2208 S \u2227 f(x) = y,\n  rcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9,\n  show y \u2208 f '' T,\n  show \u2203 (z : X), z \u2208 T \u2227 f(z) = y,\n  use x,\n  split,\n  { show x \u2208 T,\n    from h h\u2083, },\n  { show f(x) = y,\n    from h\u2084, },\n/- hint\nassume h : S \u2286 T,\nshow f '' S \u2286 f '' T,\nassume y : Y,\nassume h\u2082 : y \u2208 f '' S,\ngiven h\u2082: \u2203 (x : X), x \u2208 S \u2227 f(x) = y, \nrcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9,\nsorry,\n-/\n\n\n\n\n\n\n", "proof_hint": "assume h : S \u2286 T,\nshow f '' S \u2286 f '' T,\nassume y : Y,\nassume h\u2082 : y \u2208 f '' S,\ngiven h\u2082: \u2203 (x : X), x \u2208 S \u2227 f(x) = y, \nrcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9,\nsorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 30, "editorText": "assume h : S \u2286 T,\nshow f '' S \u2286 f '' T,\nassume y : Y,\nassume h\u2082 : y \u2208 f '' S,\ngiven h\u2082: \u2203 (x : X), x \u2208 S \u2227 f(x) = y, \nrcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9,\nsorry,", "lineOffset": 89, "name": "image_subset", "statement": "(f : X \u2192 Y) : S \u2286 T \u2192 f '' S \u2286 f '' T"}, {"type": "lean", "content": "1186", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1187", "hidden": true}, {"type": "text", "content": "1188"}, {"type": "lean", "content": "1189", "hidden": true}, {"type": "lean", "content": "1190", "hidden": true}, {"type": "lean", "content": "1191", "hidden": false}, {"type": "lean", "content": "1192", "hidden": true}, {"type": "lean", "content": "1193", "hidden": false}, {"type": "lean", "content": "1194", "hidden": true}, {"type": "lean", "content": "1195", "hidden": false}, {"type": "lean", "content": "1196", "hidden": true}, {"type": "lean", "content": "1197", "hidden": false}, {"type": "text", "content": "1198"}, {"type": "theorem", "text": "1199", "lean": "theorem image_of_S_equals_T  : f '' S = T :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 93, "textBefore": "import functions.func_image1 -- hide\n\n/-\n# Functions\n## Level 3: Example of images of sets under functions\n\nLet $f : \\mathbb Z \\to \\mathbb Z$ be the function given by $f(u) = 2(u + 4)$.\n\nLet $S$ and $T$ be the sets of elements of $\\mathbb Z$ given by\n$S := \\\\{n : \\mathbb Z \\mid n \\ge -4 \\\\}$ and\n$T := \\\\{y : \\mathbb Z \\mid y \\ge 0 \\land \\exists(m : \\mathbb Z),\\ y = 2m \\\\}$.\n\nThen $f(S) = T$.\n\nAs this result is an equality of sets, we must prove that $y \\in f(S) \\leftrightarrow y \\in T$,\ngiven $y : \\mathbb Z$. This requires proving two implications.\n\nWe'll indicate how to prove one implication below in Lean and leave the complete proof for\nyou.\n-/\n\n\n\nnamespace exlean -- hide\n\nnamespace function_test2 -- hide\n\ndef f : \u2124 \u2192 \u2124 := \u03bb u, 2 * (u + 4)\n\n-- hide\n\ndef S : set \u2124 := {n : \u2124 | n \u2265 -4}\n\n-- hide\n\ndef T : set \u2124 := {y : \u2124 | y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m} \n\n-- hide\n\nexample : f '' S \u2286 T :=\nbegin\n  assume y : \u2124,\n  show y \u2208 f '' S \u2192 y \u2208 T,\n  assume h : y \u2208 f '' S,\n  given h : \u2203 (x : \u2124), x \u2208 S \u2227 f(x) = y,\n  show y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m,\n  rcases h with \u27e8x, \u27e8h\u2082 : x \u2265 -4, h\u2083 : 2 * (x + 4) = y\u27e9\u27e9,\n  split,\n  { linarith, },\n  { use x + 4,\n    linarith, },\nend\n\n\n/-\n## Task\nProve $f(S) = T$. You'll need to split this into two directions (via extensionality)\nand then prove each part separately. The proof above should help with the first\nimplication.\n-/\n\n\n/- Theorem : no-side-bar\n$f(S) = T$, with $f$, $S$, and $T$ as above.\n-/\ntheorem image_of_S_equals_T  : f '' S = T :=\nbegin\n", "proof": "  ext y,\n  split,\n  { show y \u2208 f '' S \u2192 y \u2208 T,\n    assume h : y \u2208 f '' S,\n    given h : \u2203 (x : \u2124), x \u2208 S \u2227 f(x) = y,\n    show y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m,\n    rcases h with \u27e8x, \u27e8h\u2082 : x \u2265 -4, h\u2083 : 2 * (x + 4) = y\u27e9\u27e9,\n    split,\n    { linarith, },\n    { use x + 4,\n      linarith, }, },\n  { show y \u2208 T \u2192 y \u2208 f '' S,\n    assume h : y \u2208 T,\n    given h : y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m,\n    rcases h with \u27e8h\u2081 : y \u2265 0, \u27e8m, h\u2083 : y = 2 * m\u27e9\u27e9,\n    show y \u2208 f '' S,\n    show \u2203 (x : \u2124), x \u2265 -4 \u2227 2 * (x + 4) = y,\n    use m - 4,\n    split,\n    { linarith, },\n    { linarith, }, }\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend function_test2 -- hide\n\nend exlean -- hide", "height": 26, "editorText": "sorry", "lineOffset": 67, "name": "image_of_S_equals_T", "statement": "f '' S = T"}, {"type": "lean", "content": "1200", "hidden": true}, {"type": "lean", "content": "1201", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1202", "hidden": true}, {"type": "text", "content": "1203"}, {"type": "lean", "content": "1204", "hidden": true}, {"type": "text", "content": "1205"}, {"type": "lean", "content": "1206", "hidden": true}, {"type": "theorem", "text": "1207", "lean": "theorem image_inter_subset (f : X \u2192 Y) (S T : set X) :\nf '' (S \u2229 T) \u2286 f '' S \u2229 f '' T :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 48, "textBefore": "import functions.func_image_example -- hide\n\n/-\n# Functions\n## Level 4: The image of an intersection\n\nIn this level, you'll prove that the image of an intersection is a subset of the intersection\nof the images.\n-/\n\nnamespace exlean -- hide\n\n/-\n## Task\nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Prove\n$f(S \\cap T) \\subseteq f(S) \\cap f(T)$.\n-/\n\nvariables {X : Type*} {Y : Type*} -- hide\n\n/- Theorem : \nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Then\n$f(S \\cap T) \\subseteq f(S) \\cap f(T)$.\n-/\ntheorem image_inter_subset (f : X \u2192 Y) (S T : set X) :\nf '' (S \u2229 T) \u2286 f '' S \u2229 f '' T :=\nbegin\n", "proof": "  assume y : Y,\n  assume h : y \u2208 f '' (S \u2229 T),\n  rcases h with \u27e8x, \u27e8\u27e8h\u2082 : x \u2208 S, h\u2083 : x \u2208 T\u27e9, h\u2084 : f(x) = y\u27e9\u27e9,\n  show (\u2203 (x : X), x \u2208 S \u2227 f(x) = y) \u2227 (\u2203 (x : X), x \u2208 T \u2227 f(x) = y),\n  split,\n  { show \u2203 (x : X), x \u2208 S \u2227 f(x) = y,\n    use x,\n    from and.intro h\u2082 h\u2084, },\n  { show \u2203 (x : X), x \u2208 T \u2227 f(x) = y,\n    use x,\n    from and.intro h\u2083 h\u2084, }\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 27, "name": "image_inter_subset", "statement": "(f : X \u2192 Y) (S T : set X) :\nf '' (S \u2229 T) \u2286 f '' S \u2229 f '' T"}, {"type": "lean", "content": "1208", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "1209", "hidden": true}, {"type": "text", "content": "1210"}, {"type": "text", "content": "1211"}, {"type": "lean", "content": "1212", "hidden": false}, {"type": "text", "content": "1213"}, {"type": "lean", "content": "1214", "hidden": false}, {"type": "lean", "content": "1215", "hidden": true}, {"type": "text", "content": "1216"}, {"type": "lean", "content": "1217", "hidden": true}, {"type": "theorem", "text": "1218", "lean": "theorem image_union (f : X \u2192 Y) (S T : set X) :\nf '' (S \u222a T) = f '' S \u222a f '' T :=\n", "sideBar": true, "firstProofLineNumber": 60, "lastProofLineNumber": 98, "textBefore": "import functions.image_inter_subset -- hide\n\n/-\n# Functions\n## Level 5: The image of a union\n\nIn this level, we'll investigate the image of a union. Unions are constructions that depend on the\n`\u2228` logical connective. We'll first see how to decompose such statements using `rcases`.\n-/\n\n/-\nGiven a hypothesis `h : p \u2228 q`, doing `rcases h with h\u2081 | h\u2081` splits the goal into\ntwo new goals, where `h\u2081 : p` in the first goal and `h\u2081 : q` in the second goal.\nHere, for instance, is one way of proving `p` on the assumption `h : (p \u2227 q) \u2228 (p \u2227 r)`. \n-/\n\nexample (p q r : Prop) (h : (p \u2227 q) \u2228 (p \u2227 r)) : p :=\nbegin\n  rcases h with (h\u2081 : p \u2227 q) | (h\u2081 : p \u2227 r),\n  { given h\u2081 : p \u2227 q,\n    show p, from h\u2081.left, },\n  { given h\u2081: p \u2227 r,\n    show p, from h\u2081.left, }\nend\n\n\n/-\nThe proof can be made even simpler by recursively decomposing each of the expressions `p \u2227 q` and `p \u2227 r`.\nHere, I use `-` to let Lean know I don't care about the other part of the hypothesis.\n-/\n\nexample (p q r : Prop) (h : (p \u2227 q) \u2228 (p \u2227 r)) : p :=\nbegin\n  rcases h with \u27e8h\u2081 : p, -\u27e9 | \u27e8h\u2081 : p, -\u27e9,\n  { show p, from h\u2081, },\n  { show p, from h\u2081, }\nend\n\n\n\n\n\nnamespace exlean -- hide\n\n/-\n## Task\nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Prove\n$f(S \\cup T) = f(S) \\cup f(T)$.\n-/\n\nvariables {X : Type*} {Y : Type*} -- hide\n\n/- Theorem : \nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Then\n$f(S \\cup T) = f(S) \\cup f(T)$.\n-/\ntheorem image_union (f : X \u2192 Y) (S T : set X) :\nf '' (S \u222a T) = f '' S \u222a f '' T :=\nbegin\n", "proof": "  ext y,\n  split,\n  { show y \u2208 f '' (S \u222a T) \u2192 y \u2208 f '' S \u222a f '' T,\n    assume h : y \u2208 f '' (S \u222a T),\n    show y \u2208 f '' S \u222a f '' T,\n    rcases h with \u27e8x, \u27e8(h\u2082 : x \u2208 S) | (h\u2082 : x \u2208 T), h\u2083 : f(x) = y\u27e9\u27e9,\n    { given h\u2082 : x \u2208 S,\n      show y \u2208 f '' S \u222a f '' T,\n      left, show y \u2208 f '' S,\n      show \u2203 (x : X), x \u2208 S \u2227 f(x) = y,\n      use x,\n      tauto!, },\n    { given h\u2082 : x \u2208 T,\n      show y \u2208 f '' S \u222a f '' T,\n      right, show y \u2208 f '' T,\n      show \u2203 (x : X), x \u2208 T \u2227 f(x) = y,\n      use x,\n      tauto!, }, },\n  { show y \u2208 f '' S \u222a f '' T \u2192 y \u2208 f '' (S \u222a T),\n    assume h : y \u2208 f '' S \u222a f '' T,\n    show y \u2208 f '' (S \u222a T),\n    show \u2203 (x : X), x \u2208 S \u222a T \u2227 f(x) = y,\n    rcases h with \u27e8x, \u27e8h\u2081 : x \u2208 S, h\u2082 : f(x) = y\u27e9\u27e9 | \u27e8x, \u27e8h\u2081 : x \u2208 T, h\u2082 : f(x) = y \u27e9\u27e9,\n    { use x,\n      from and.intro (or.inl h\u2081) h\u2082, },\n    { use x,\n      from and.intro (or.inr h\u2081) h\u2082, }, }\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 39, "editorText": "sorry", "lineOffset": 59, "name": "image_union", "statement": "(f : X \u2192 Y) (S T : set X) :\nf '' (S \u222a T) = f '' S \u222a f '' T"}, {"type": "lean", "content": "1219", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1220", "hidden": true}, {"type": "text", "content": "1221"}, {"type": "lean", "content": "1222", "hidden": true}, {"type": "lean", "content": "1223", "hidden": true}, {"type": "axiom", "content": "1224", "name": "preimage_mono (f : X \u2192 Y) (U V : set Y) (h : U \u2286 V) :", "sideBar": true}, {"type": "text", "content": "1225"}, {"type": "lean", "content": "1226", "hidden": false}, {"type": "text", "content": "1227"}, {"type": "theorem", "text": "1228", "lean": "theorem preimage_inter (f : X \u2192 Y) (U V : set Y) :\nf\u207b\u00b9'(U \u2229 V) = f\u207b\u00b9'(U) \u2229 f\u207b\u00b9'(V) :=\n", "sideBar": true, "firstProofLineNumber": 55, "lastProofLineNumber": 67, "textBefore": "import functions.image_union -- hide\n\n/-\n# Functions\n## Level 6: The preimage of a set under a function\n\nLet $f : X \\to Y$ be a function and let $U$ be a set on $Y$.\nThe *pre-image* of $U$ under $f$, written $f^{-1}(U)$, is the set\n$\n\\\\{x : X \\mid f(x) \\in U\\\\}.\n$\n-/\n\n\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} -- hide\n\n/- Axiom : preimage_mono (f : X \u2192 Y) (U V : set Y) (h : U \u2286 V) :\nf\u207b\u00b9'(U) \u2286 f\u207b\u00b9'(V)\n-/\n\n/-\nIn Lean, we write `f\u207b\u00b9'(U)` for $f^{-1}(U)$. This is typed `f\\-1'(U)`.\n\n**Theorem**: Suppose that $f : X \\to Y$, that $U$ and $V$ are sets of elements of $Y$\nand that $U \\subseteq V$. Then $f^{-1}(U) \\subseteq f^{-1}(V)$.\n\nWe prove this in Lean below.\n-/\n\nlemma preimage_mono (f : X \u2192 Y) (U V : set Y) (h : U \u2286 V) : f\u207b\u00b9'(U) \u2286 f\u207b\u00b9'(V) :=\nbegin\n  assume x : X,\n  assume h\u2082 : x \u2208 f\u207b\u00b9'(U),\n  given h\u2082 : f(x) \u2208 U,\n  show f(x) \u2208 V, from h h\u2082, \nend\n\n\n/-\n## Task\nLet $f : X \\to Y$ be a function and let $U$ and $V$ be sets on $Y$. Prove\n$f^{-1}(U \\cap V) = f^{-1}(U) \\cap f^{-1}(V)$.\n-/\n\n/- Theorem : \nLet $f : X \\to Y$ be a function and let $U$ and $V$ be sets on $Y$. Then\n$f^{-1}(U \\cap V) = f^{-1}(U) \\cap f^{-1}(V)$.\n-/\ntheorem preimage_inter (f : X \u2192 Y) (U V : set Y) :\nf\u207b\u00b9'(U \u2229 V) = f\u207b\u00b9'(U) \u2229 f\u207b\u00b9'(V) :=\nbegin\n", "proof": "  ext x,\n  calc\n  x \u2208 f\u207b\u00b9'(U \u2229 V) \u2194 f(x) \u2208 U \u2229 V    : by refl\n  ... \u2194 (f(x) \u2208 U) \u2227 (f(x) \u2208 V)     : by refl\n  ... \u2194 x \u2208 f\u207b\u00b9'(U) \u2229 f\u207b\u00b9'(V)       : by refl\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 54, "name": "preimage_inter", "statement": "(f : X \u2192 Y) (U V : set Y) :\nf\u207b\u00b9'(U \u2229 V) = f\u207b\u00b9'(U) \u2229 f\u207b\u00b9'(V)"}, {"type": "lean", "content": "1229", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1230", "hidden": true}, {"type": "text", "content": "1231"}, {"type": "lean", "content": "1232", "hidden": true}, {"type": "text", "content": "1233"}, {"type": "lean", "content": "1234", "hidden": true}, {"type": "lean", "content": "1235", "hidden": true}, {"type": "text", "content": "1236"}, {"type": "lean", "content": "1237", "hidden": false}, {"type": "lean", "content": "1238", "hidden": true}, {"type": "lean", "content": "1239", "hidden": false}, {"type": "text", "content": "1240"}, {"type": "lean", "content": "1241", "hidden": false}, {"type": "theorem", "text": "1242", "lean": "theorem surj_my_g : surjective g :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 64, "textBefore": "import functions.preimage data.real.basic -- hide\n\n/-\n# Functions\n## Level 7: Surjective functions\n\nFor the function $f : X \\to Y$ to be *surjective* means that\n$\\forall (y : Y),\\ \\exists(x : X),\\ f(x) = y$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Lemma**: Let $f : \\mathbb R \\to \\mathbb R$ be the function $f(x) := 2x$. Then $f$ is\nsurjective.\n\n**Proof**: We must show $\\forall (y : \\mathbb R),\\ \\exists (x : \\mathbb R),\\ 2x = y$.\nAssume $y : \\mathbb R$. Take $x$ to be $y/2$. Then $2(y/2) = y$ follows by arithmetic. \u220e\n-/\n\nnamespace func_surj1 -- hide\n\nopen function -- hide\n\n/-\nThe same result can be proved in Lean, as below.\n-/\n\ndef f : \u211d \u2192 \u211d := \u03bb x, 2 * x\n\n-- hide\n\nexample : surjective f :=\nbegin\n  show \u2200 (y : \u211d), \u2203 (x : \u211d), 2 * x = y,\n  assume y : \u211d,\n  use y / 2,\n  linarith,\nend\n\n/-\n## Task\nLet $g : \\mathbb R \\to \\mathbb R$ be the function $g(x) := 3x + 5$. Prove that $g$ is surjective.\n-/\n\ndef g : \u211d \u2192 \u211d := \u03bb x, 3 * x + 5 \n\n/- Theorem : no-side-bar\nLet $g : \\mathbb R \\to \\mathbb R$ be the function $g(x) := 3x + 5$. Then $g$ is surjective.\n-/\ntheorem surj_my_g : surjective g :=\nbegin\n", "proof": "  show \u2200 (y : \u211d), \u2203 (x : \u211d), 3 * x + 5 = y,\n  assume y : \u211d,\n  use (y - 5) / 3,\n  linarith, \n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend func_surj1 -- hide\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 53, "name": "surj_my_g", "statement": "surjective g"}, {"type": "lean", "content": "1243", "hidden": true}, {"type": "lean", "content": "1244", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1245", "hidden": true}, {"type": "text", "content": "1246"}, {"type": "lean", "content": "1247", "hidden": true}, {"type": "text", "content": "1248"}, {"type": "lean", "content": "1249", "hidden": true}, {"type": "lean", "content": "1250", "hidden": true}, {"type": "text", "content": "1251"}, {"type": "lean", "content": "1252", "hidden": false}, {"type": "lean", "content": "1253", "hidden": true}, {"type": "axiom", "content": "1254", "name": "nat.eq_one_of_mul_eq_one_right {a b : \u2115} (h : a * b = 1) :", "sideBar": true}, {"type": "lean", "content": "1255", "hidden": false}, {"type": "text", "content": "1256"}, {"type": "text", "content": "1257"}, {"type": "lean", "content": "1258", "hidden": false}, {"type": "theorem", "text": "1259", "lean": "theorem not_surj_my_g : \u00ac(surjective g) :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 84, "textBefore": "import functions.preimage -- hide\n\n/-\n# Functions\n## Level 8: Not surjective functions\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := 2x$. Then $f$ is\nnot surjective.\n\n**Proof**: For $f$ to *be* surjective means\n$\\forall (y : \\mathbb Z),\\ \\exists(x : \\mathbb Z),\\ 2x = y$.\nWe want to prove the negation of this statement, which is\n$\\exists (y : \\mathbb Z),\\ \\forall (x : \\mathbb Z),\\ 2x \u2260 y$.\nTake $y$ to be $1$. We must show $\\forall(x : \\mathbb Z), 2x \\ne 1$.\nAssume $x : \\mathbb Z$. Assume $h : 2x = 1$. But for natural numbers $a$ and $b$, we know\nif $ab = 1$, then $a = 1$. Thus, $2 = 1$, a contradiction. \u220e\n-/\n\nnamespace func_surj2 -- hide\n\nopen function -- hide\n\n/-\nThe same result can be proved in Lean, as below. We use the Lean theorem\n`nat.eq_one_of_mul_eq_one_right` which returns a proof of `a = 1` given a proof\nof `a * b = 1`.\n-/\n\ndef f : \u2115 \u2192 \u2115 := \u03bb x, 2 * x\n\n-- hide\n\n/- Axiom : nat.eq_one_of_mul_eq_one_right {a b : \u2115} (h : a * b = 1) :\na = 1\n-/\n\nexample : \u00ac(surjective f) :=\nbegin\n  push_neg,\n  show \u2203 (y : \u2115), \u2200 (x : \u2115), 2 * x \u2260 y,\n  use 1,\n  assume x : \u2115,\n  assume h : 2 * x = 1,\n  have h\u2082: 2 = 1, from nat.eq_one_of_mul_eq_one_right h,\n  linarith,\nend\n\n/-\n## Task\nLet $g : \\mathbb N \\to \\mathbb N$ be the function $g(x) := 3x + 5$. Prove that $g$ is not surjective.\n-/\n\n/-\nHint : How to proceed\nTry adapting the proof above. Try to arrange things so that you can prove \n`3 * x = 1`, for some `x`.\n-/\n\ndef g : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n\n/- Theorem : no-side-bar\nLet $g : \\mathbb N \\to \\mathbb N$ be the function $g(x) := 3x + 5$. Then $g$ is not surjective.\n-/\ntheorem not_surj_my_g : \u00ac(surjective g) :=\nbegin\n", "proof": "  push_neg,\n  show \u2203 (y : \u2115), \u2200 (x : \u2115), 3 * x + 5 \u2260 y,\n  use 6,\n  assume x : \u2115,\n  assume h\u2082 : 3 * x + 5 = 6,\n  have h\u2083 : 3 * x = 1, linarith,\n  have h\u2084 : 3 = 1, from nat.eq_one_of_mul_eq_one_right h\u2083, \n  linarith,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend func_surj2 -- hide\n\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 70, "name": "not_surj_my_g", "statement": "\u00ac(surjective g)"}, {"type": "lean", "content": "1260", "hidden": true}, {"type": "lean", "content": "1261", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1262", "hidden": true}, {"type": "text", "content": "1263"}, {"type": "lean", "content": "1264", "hidden": true}, {"type": "text", "content": "1265"}, {"type": "lean", "content": "1266", "hidden": true}, {"type": "lean", "content": "1267", "hidden": true}, {"type": "text", "content": "1268"}, {"type": "lean", "content": "1269", "hidden": false}, {"type": "lean", "content": "1270", "hidden": true}, {"type": "lean", "content": "1271", "hidden": false}, {"type": "text", "content": "1272"}, {"type": "lean", "content": "1273", "hidden": false}, {"type": "theorem", "text": "1274", "lean": "theorem inj_my_g : injective g :=\n", "sideBar": false, "firstProofLineNumber": 56, "lastProofLineNumber": 64, "textBefore": "import functions.not_surjective -- hide\n\n/-\n# Functions\n## Level 9: Injective functions\n\nFor the function $f : X \\to Y$ to be *injective* means that for all $x_1$ and $x_2$ of type\n$X$, if $f(x_1) = f(x_2)$, then $x_1 = x_2$.\n\nMore formally, $\\forall (x_1\\ x_1 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := 2x$. Then $f$ is\ninjective.\n\n**Proof**: Assume $x_1, x_2 : \\mathbb Z$. Assume $h : f(x_1) = f(x_2)$. We must show $x_1 = x_2$.\nBy definition, $h : 2x_1 = 2x_2$. The result $x_1 = x_2$ follows by arithmetic. \u220e\n-/\n\nnamespace func_inj1 -- hide\n\nopen function -- hide\n\n/-\nThis result is proved in Lean below.\n-/\n\ndef f : \u2124 \u2192 \u2124 := \u03bb x, 2 * x\n\n-- hide\n\nexample : injective f :=\nbegin\n  assume x\u2081 x\u2082 : \u2124,\n  assume h : f(x\u2081) = f(x\u2082),\n  given h : 2 * x\u2081 = 2 * x\u2082,\n  show x\u2081 = x\u2082, linarith,\nend\n\n/-\n## Task\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := 3x + 5$. Prove that $g$ is injective.\n-/\n\ndef g : \u2124 \u2192 \u2124 := \u03bb x, 3 * x + 5\n\n/- Theorem : no-side-bar\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := 3x + 5$. Then $g$ is injective.\n-/\ntheorem inj_my_g : injective g :=\nbegin\n", "proof": "  assume x\u2081 x\u2082 : \u2124,\n  assume h : g(x\u2081) = g(x\u2082),\n  given h : 3 * x\u2081 + 5 = 3 * x\u2082 + 5, \n  show x\u2081 = x\u2082, linarith,\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend func_inj1 -- hide\n\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 55, "name": "inj_my_g", "statement": "injective g"}, {"type": "lean", "content": "1275", "hidden": true}, {"type": "lean", "content": "1276", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1277", "hidden": true}, {"type": "text", "content": "1278"}, {"type": "lean", "content": "1279", "hidden": true}, {"type": "text", "content": "1280"}, {"type": "lean", "content": "1281", "hidden": true}, {"type": "lean", "content": "1282", "hidden": true}, {"type": "text", "content": "1283"}, {"type": "lean", "content": "1284", "hidden": false}, {"type": "lean", "content": "1285", "hidden": true}, {"type": "lean", "content": "1286", "hidden": false}, {"type": "text", "content": "1287"}, {"type": "lean", "content": "1288", "hidden": false}, {"type": "theorem", "text": "1289", "lean": "theorem not_inj_my_g : \u00ac(injective g) :=\n", "sideBar": false, "firstProofLineNumber": 77, "lastProofLineNumber": 89, "textBefore": "import functions.injective -- hide\n\n/-\n# Functions\n## Level 10: Not injective functions\n-/\n\nnamespace exlean -- hide\n\n\n/-\n**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x(x - 3)$. Then $f$ is not\ninjective.\n\nBefore proving this, consider the negation of 'injective'. In general, for $f : X \\to Y$ to be injective\nmeans $\\forall (x_1\\ x_1 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\nNegating this and pushing the negation through the quantifiers gives\n$\n\\exists (x_1\\ x_2 : X),\\ \\neg(f(x_1) = f(x_2) \\to x_1 = x_2).\n$\n\nOne result of our work on propositional logic is that $(p \\to q) \\leftrightarrow (\\neg p \\lor q)$,\nfor propositions $p$ and $q$. Thus (by propositional extensionality, de Morgan's law, and double negation),\n$\\neg(p \\to q) = \\neg(\\neg p \\lor q) = p \\land \\neg q$.\n\nThus, the negation of $f$ being injective is\n$\n\\exists (x_1\\ x_2 : X),\\ f(x_1) = f(x_2) \\land x_1 \\ne x_2.\n$\n\n**Proof**: \n\nWe must show $\\exists (x_1\\ x_2 : \u2124),\\ f(x_1) = f(x_2) \\land x_1 \\ne x_2$.\nTake $x_1$ to be $0$ and $x_2$ to be $3$. We must show $f(0) = f(3) \\land 0 \\ne 3$.\nThat is, to show $0 = 0 \\land 0 \\ne 3$. Each of these two statements can be proved by arithmetic.\n \u220e\n-/\n\nnamespace func_inj2 -- hide\n\nopen function -- hide\n\n/-\nThis result is proved in Lean below.\n-/\n\ndef f : \u2124 \u2192 \u2124 := \u03bb x, x * (x - 3)\n\n-- hide\n\nexample : \u00ac(injective f) :=\nbegin\n  show \u00ac(\u2200 (x\u2081 x\u2082 : \u2124), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082),\n  push_neg,\n  show \u2203 (x\u2081 x\u2082 : \u2124), f(x\u2081) = f(x\u2082) \u2227 x\u2081 \u2260 x\u2082,\n  use 0, use 3,\n  show (0 : \u2124) = 0 \u2227 (0 : \u2124) \u2260 3,\n  split,\n  { linarith, },\n  { linarith, },\nend\n\n/-\n## Task\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := x^3 + 3x^2 - 10x - 24$.\nProve that $g$ is not injective.\n-/\n\ndef g : \u2124 \u2192 \u2124 := \u03bb x, x^3 + 3 * x^2 - 10 * x - 24\n\n/- Theorem : no-side-bar\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := x^3 + 3x^2 - 10x - 24$.\nThen $g$ is not injective.\n-/\ntheorem not_inj_my_g : \u00ac(injective g) :=\nbegin\n", "proof": "  show \u00ac(\u2200 (x\u2081 x\u2082 : \u2124), g(x\u2081) = g(x\u2082) \u2192 x\u2081 = x\u2082),\n  push_neg,\n  show \u2203 (x\u2081 x\u2082 : \u2124), g(x\u2081) = g(x\u2082) \u2227 x\u2081 \u2260 x\u2082,\n  use -2, use 3,\n  show (0 : \u2124) = 0 \u2227 (-2 : \u2124) \u2260 3,\n  split,\n  { linarith, },\n  { linarith, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend func_inj2 -- hide\n\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 76, "name": "not_inj_my_g", "statement": "\u00ac(injective g)"}, {"type": "lean", "content": "1290", "hidden": true}, {"type": "lean", "content": "1291", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1292", "hidden": true}, {"type": "text", "content": "1293"}, {"type": "lean", "content": "1294", "hidden": true}, {"type": "lean", "content": "1295", "hidden": true}, {"type": "lean", "content": "1296", "hidden": true}, {"type": "text", "content": "1297"}, {"type": "lean", "content": "1298", "hidden": false}, {"type": "lean", "content": "1299", "hidden": true}, {"type": "theorem", "text": "1300", "lean": "theorem bij_f : bijective f :=\n", "sideBar": false, "firstProofLineNumber": 39, "firstProofHintLineNumber": 54, "lastProofHintLineNumber": 55, "lastProofLineNumber": 56, "textBefore": "import functions.not_injective -- hide\n\n/-\n# Functions\n## Level 11: Bijective functions\n\nFor a function $f : X \\to Y$ to be *bijective* means that\n$f$ is injective and $f$ is surjective.\n-/\n\nnamespace exlean -- hide\n\n\n\nnamespace func_bij1 -- hide\n\nopen function -- hide\n\n\n\n\n/-\n## Task\nLet $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x + 3$.\nProve that $f$ is bijective.\n-/\n\ndef f : \u2124 \u2192 \u2124 := \u03bb x, x + 3\n\n-- hide\n\n\n/- Theorem : no-side-bar\nLet $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x + 3$.\nThen $f$ is bijective.\n-/\ntheorem bij_f : bijective f :=\nbegin\n", "proof": "  show (injective f) \u2227 (surjective f),\n  split,\n  { show injective f,\n    assume x\u2081 x\u2082 : \u2124,\n    assume h : f(x\u2081) = f(x\u2082),\n    given h : x\u2081 + 3 = x\u2082 + 3,\n    show x\u2081 = x\u2082, linarith, },\n  { show surjective f, \n    show \u2200 (y : \u2124), \u2203 (x : \u2124), f(x) = y,\n    assume y : \u2124,\n    use y - 3,\n    show (y - 3) + 3 = y, linarith, },\n\n\n/- hint\nshow (injective f) \u2227 (surjective f),\nsorry,\n-/", "proof_hint": "show (injective f) \u2227 (surjective f),\nsorry,", "textAfter": "\nend\n\nend func_bij1 -- hide\n\n\nend exlean -- hide", "height": 18, "editorText": "show (injective f) \u2227 (surjective f),\nsorry,", "lineOffset": 38, "name": "bij_f", "statement": "bijective f"}, {"type": "lean", "content": "1301", "hidden": true}, {"type": "lean", "content": "1302", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1303", "hidden": true}, {"type": "text", "content": "1304"}, {"type": "lean", "content": "1305", "hidden": true}, {"type": "lean", "content": "1306", "hidden": true}, {"type": "text", "content": "1307"}, {"type": "lean", "content": "1308", "hidden": true}, {"type": "theorem", "text": "1309", "lean": "theorem sub_of_sub_of_injective\n(h\u2082 : injective f) (h\u2081 : f '' S \u2286 f '' T) :\nS \u2286 T :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 56, "textBefore": "import functions.bijective -- hide\n\n/-\n# Functions\n## Level 12: Image of an injective function\n-/\n\nnamespace exlean -- hide\n\n\nopen function -- hide\n\n\n\n\n/-\n## Task\nSuppose $f : X \\to Y$ is an injective function. Suppose $S$ and $T$\nare sets on $X$. Given that $f(S) \\subseteq f(T)$, prove that $S \\subseteq T$.\n\nNote: this is a question about equality of *sets*.\n-/\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y} {S T : set X} -- hide\n\n\n/- Theorem : \nSuppose $f : X \\to Y$ is an injective function. Suppose $S$ and $T$\nare sets on $X$. Given that $f(S) \\subseteq f(T)$, then $S \\subseteq T$.\n-/\ntheorem sub_of_sub_of_injective\n(h\u2082 : injective f) (h\u2081 : f '' S \u2286 f '' T) :\nS \u2286 T :=\nbegin\n", "proof": "  assume u : X,\n  assume h : u \u2208 S,\n  have h\u2083 : f(u) \u2208 f '' S,\n  { show \u2203 (x : X), x \u2208 S \u2227 f(x) = f(u),\n    use u,\n    from and.intro h rfl, }, \n  have h\u2084 : f(u) \u2208 f '' T, from h\u2081 h\u2083,\n  given h\u2084 : \u2203 (v : X), v \u2208 T \u2227 f(v) = f(u),\n  rcases h\u2084 with \u27e8v, h\u2085 : v \u2208 T, h\u2086 : f(v) = f(u)\u27e9,\n  have h\u2087 : v = u, from h\u2082 h\u2086,\n  rwa \u2190h\u2087,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 22, "editorText": "sorry", "lineOffset": 34, "name": "sub_of_sub_of_injective", "statement": "(h\u2082 : injective f) (h\u2081 : f '' S \u2286 f '' T) :\nS \u2286 T"}, {"type": "lean", "content": "1310", "hidden": true}]}, {"name": "", "problemIndex": 21, "objects": [{"type": "lean", "content": "1311", "hidden": true}, {"type": "text", "content": "1312"}, {"type": "lean", "content": "1313", "hidden": true}, {"type": "lean", "content": "1314", "hidden": true}, {"type": "lean", "content": "1315", "hidden": true}, {"type": "text", "content": "1316"}, {"type": "lean", "content": "1317", "hidden": false}, {"type": "lean", "content": "1318", "hidden": true}, {"type": "lean", "content": "1319", "hidden": false}, {"type": "lean", "content": "1320", "hidden": true}, {"type": "lean", "content": "1321", "hidden": false}, {"type": "lean", "content": "1322", "hidden": true}, {"type": "text", "content": "1323"}, {"type": "lean", "content": "1324", "hidden": true}, {"type": "axiom", "content": "1325", "name": "comp.assoc (p : X \u2192 Y) (q : Y \u2192 Z) (r : Z \u2192 W) :", "sideBar": true}, {"type": "lean", "content": "1326", "hidden": false}, {"type": "text", "content": "1327"}, {"type": "hint", "content": "1328", "title": "1329"}, {"type": "lean", "content": "1330", "hidden": false}, {"type": "lean", "content": "1331", "hidden": true}, {"type": "lean", "content": "1332", "hidden": false}, {"type": "theorem", "text": "1333", "lean": "theorem compo1 : \u2203 (p : \u2124 \u2192 \u2124), q \u2218 p = r :=\n", "sideBar": false, "firstProofLineNumber": 104, "firstProofHintLineNumber": 112, "lastProofHintLineNumber": 115, "lastProofLineNumber": 119, "textBefore": "import functions.image_of_injective -- hide\n\n/-\n# Functions\n## Level 13: The composition of two functions\n\nLet $f : X \\to Y$ and $g : Y \\to Z$ be functions. The *composition*\nof $g$ and $f$, denoted $g \\circ f$ is the function of type $X \\to Z$\ndefined by $(g \\circ f)(x) := g(f(x))$.\n-/\n\nnamespace exlean -- hide\n\n\n\nnamespace func_compo_1 -- hide\n\nopen function -- hide\n\n/-\nIn the example below, we show that if $f$ and $g$ are functions from $\\mathbb Z$\nto $\\mathbb Z$ given by $f(x) := x + 3$ and $g(y) = y^2 - 9$,\nthen for every $u : \\mathbb Z$, we have $(g \\circ f)(u) = u(6 + u)$.\n\nIn Lean, `\u2218` is typed `\\o`.\n-/\n\n\n\ndef f : \u2115 \u2192 \u2124 := \u03bb x, x + 3\n\n-- hide\n\ndef g : \u2124 \u2192 \u2124 := \u03bb y, y ^ 2 - 9\n\n-- hide\n\nexample (u : \u2115) : (g \u2218 f)(u) = u * (6 + u) :=\nbegin\n  show g(f(u)) = u * (6 + u),\n  show g(u + 3) = u * (6 + u),\n  show ((u + 3)^2 - 9 : \u2124) = u * (6 + u),\n  linarith,\nend\n\nend func_compo_1 -- hide\n\n/-\nAs another example, we prove that function composition is associative. That is,\ngiven $p : X \\to Y$, $q : Y \\to Z$ and $r : Z \\to W$, we'll show\n$(r \\circ q) \\circ p = r \\circ (q \\circ p)$.\n\nIn fact this result follows by reflexivity. However, to illustrate other\nuseful techniques, we give a slightly longer proof.\n-/\n\nvariables {X : Type*} {Y : Type*} {Z : Type*} {W : Type*} -- hide\n\n/- Axiom : comp.assoc (p : X \u2192 Y) (q : Y \u2192 Z) (r : Z \u2192 W) :\n(r \u2218 q) \u2218 p = r \u2218 (q \u2218 p) \n-/\n\nlemma comp.assoc (p : X \u2192 Y) (q : Y \u2192 Z) (r : Z \u2192 W) :\n(r \u2218 q) \u2218 p = r \u2218 (q \u2218 p) :=\nbegin\n  ext x, -- By extensionality, it suffices to ...\n  show (r \u2218 q)(p(x)) = r((q \u2218 p)(x)),\n  show r(q(p(x))) = r(q(p(x))),\n  from rfl,\nend\n\n\n/-\n## Task\nGiven functions $r$ and $q$ from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$q(y) := y + y^2$ and $r(u) := u^2 + 5u + 6$, find a function $p$\nfrom $\\mathbb Z$ to $\\mathbb Z$ such that $q \\circ p = r$.\n\nIn the Lean proof below, replace the `_` with an expression, to give a\ndefinition of `p`. You are then left with the task of proving the equality\n`q \u2218 p = r`. Ask yourself: what is it to prove the equality of two functions?\n-/\n\n/- Hint : A suggested approach\nDo this by hand first. Try a solution of the form $p(x) := ax + b$\nwhere $a$ and $b$ are parameters to be determined.\n-/\n\nnamespace func_compo_1\n\ndef r : \u2124 \u2192 \u2124 := \u03bb u, u^2 + 5 * u + 6\n\n-- hide\n\ndef q : \u2124 \u2192 \u2124 := \u03bb y, y + y^2\n\n/- Theorem : no-side-bar\nGiven functions $r$ and $q$ from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$q(y) := y + y^2$ and $r(u) := u^2 + 5u + 6$. There exists a function $p$\nfrom $\\mathbb Z$ to $\\mathbb Z$ such that $q \\circ p = r$.\n-/\ntheorem compo1 : \u2203 (p : \u2124 \u2192 \u2124), q \u2218 p = r :=\nbegin\n", "proof": "  let p : \u2124 \u2192 \u2124 := \u03bb x, x + 2,\n  use p,\n  ext x,\n  show q(p(x)) = r(x),\n  show q(x + 2) = r(x),\n  show (x + 2) + (x + 2)^2 = x^2 + 5 * x + 6,\n  linarith,\n/- hint\n  let p : \u2124 \u2192 \u2124 := \u03bb x, _,\n  use p,\n  sorry,\n\n-/\n\n\n", "proof_hint": "  let p : \u2124 \u2192 \u2124 := \u03bb x, _,\n  use p,\n  sorry,\n", "textAfter": "\nend\n\nend func_compo_1 -- hide\n\n\nend exlean -- hide", "height": 16, "editorText": "  let p : \u2124 \u2192 \u2124 := \u03bb x, _,\n  use p,\n  sorry,\n", "lineOffset": 103, "name": "compo1", "statement": "\u2203 (p : \u2124 \u2192 \u2124), q \u2218 p = r"}, {"type": "lean", "content": "1334", "hidden": true}, {"type": "lean", "content": "1335", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1336", "hidden": true}, {"type": "text", "content": "1337"}, {"type": "lean", "content": "1338", "hidden": true}, {"type": "lean", "content": "1339", "hidden": true}, {"type": "text", "content": "1340"}, {"type": "lean", "content": "1341", "hidden": true}, {"type": "theorem", "text": "1342", "lean": "theorem injective.comp \n(h\u2081 : injective g) (h\u2082 : injective f) :\ninjective (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 46, "textBefore": "import functions.composite -- hide\n\n/-\n# Functions\n## Level 14: The composition of two injective functions\n\n-/\n\nnamespace exlean -- hide\n\n\n\nopen function -- hide\n\n\n\n\n\n\n\n/-\n## Task\nProve that the composition of two injective functions is injective.\n-/\n\nvariables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n\n/- Theorem :\nLet $g : Y \\to Z$ and $f : X \\to Y$ be injective functions.\nThen $g \\circ f$ is injective.\n-/\ntheorem injective.comp \n(h\u2081 : injective g) (h\u2082 : injective f) :\ninjective (g \u2218 f) :=\nbegin\n", "proof": "  show \u2200 (x\u2081 x\u2082 : X), g(f(x\u2081)) = g(f(x\u2082)) \u2192 x\u2081 = x\u2082,\n  assume x\u2081 x\u2082 : X,\n  assume h : g(f(x\u2081)) = g(f(x\u2082)),\n  have h\u2083 : f(x\u2081) = f(x\u2082), from h\u2081 h,\n  show x\u2081 = x\u2082, from h\u2082 h\u2083,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 35, "name": "injective.comp", "statement": "(h\u2081 : injective g) (h\u2082 : injective f) :\ninjective (g \u2218 f)"}, {"type": "lean", "content": "1343", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1344", "hidden": true}, {"type": "text", "content": "1345"}, {"type": "lean", "content": "1346", "hidden": true}, {"type": "lean", "content": "1347", "hidden": true}, {"type": "text", "content": "1348"}, {"type": "lean", "content": "1349", "hidden": true}, {"type": "theorem", "text": "1350", "lean": "theorem surjective.comp \n(h\u2081 : surjective g) (h\u2082 : surjective f) :\nsurjective (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 58, "textBefore": "import functions.comp_inj -- hide\n\n/-\n# Functions\n## Level 15: The composition of two surjective functions\n-/\n\nnamespace exlean -- hide\n\n\n\nopen function -- hide\n\n\n\n\n\n\n\n/-\n## Task\nProve that the composition of two surjective functions is surjective.\n-/\n\nvariables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n\n/- Theorem :\nLet $g : Y \\to Z$ and $f : X \\to Y$ be surjective functions.\nThen $g \\circ f$ is surjective.\n-/\ntheorem surjective.comp \n(h\u2081 : surjective g) (h\u2082 : surjective f) :\nsurjective (g \u2218 f) :=\nbegin\n", "proof": "  show \u2200 (z : Z), \u2203 (x : X), g(f(x)) = z,\n  assume z : Z,\n  have h\u2083 : \u2203 (y : Y), g(y) = z, from h\u2081 z,\n  cases h\u2083 with y h\u2084,\n  given h\u2084 : g(y) = z,\n  have h\u2085 : \u2203 (x : X), f(x) = y, from h\u2082 y,\n  cases h\u2085 with x h\u2086,\n  given h\u2086 : f(x) = y,\n  use x,\n  rw h\u2086,\n  from h\u2084,\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 24, "editorText": "sorry", "lineOffset": 34, "name": "surjective.comp", "statement": "(h\u2081 : surjective g) (h\u2082 : surjective f) :\nsurjective (g \u2218 f)"}, {"type": "lean", "content": "1351", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1352", "hidden": true}, {"type": "text", "content": "1353"}, {"type": "lean", "content": "1354", "hidden": true}, {"type": "lean", "content": "1355", "hidden": true}, {"type": "text", "content": "1356"}, {"type": "lean", "content": "1357", "hidden": true}, {"type": "theorem", "text": "1358", "lean": "theorem comp_image_of_surjective \n(h\u2081 : surjective g) (h\u2082 : surjective f) (W : set Z):\n\u2203 (S : set X), (g \u2218 f) '' S = W :=\n", "sideBar": false, "firstProofLineNumber": 41, "lastProofLineNumber": 73, "textBefore": "import functions.comp_surj -- hide\n\n/-\n# Functions\n## Level 16: Images and surjective functions\n\nThis level will challenge your understanding of composition,\nsurjective functions, images, and preimages.\n-/\n\nnamespace exlean -- hide\n\n\n\nopen function -- hide\n\n\n\n\n\n\n\n/-\n## Task\nLet $f : X \\to Y$ and $g : Y \\to Z$ be surjective functions.\nSuppose $W$ is a set on $Z$. Prove that there exists a set\n$S$ on $X$ such that $(g \\circ f)(S) = W$.\n-/\n\nvariables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n\n/- Theorem : no-side-bar\nLet $f : X \\to Y$ and $g : Y \\to Z$ be surjective functions.\nSuppose $W$ is a set on $Z$. Then there exists a set\n$S$ on $X$ such that $(g \\circ f)(S) = W$.\n-/\ntheorem comp_image_of_surjective \n(h\u2081 : surjective g) (h\u2082 : surjective f) (W : set Z):\n\u2203 (S : set X), (g \u2218 f) '' S = W :=\nbegin\n", "proof": "  use (g \u2218 f)\u207b\u00b9'(W),\n  ext z,\n  have h\u2083 : surjective (g \u2218 f), from surjective.comp h\u2081 h\u2082,\n  split,\n  { assume h\u2084 : z \u2208 (g \u2218 f) '' ((g \u2218 f)\u207b\u00b9'(W)),\n    given h\u2084 : \u2203 (x : X), x \u2208 (g \u2218 f)\u207b\u00b9'(W) \u2227 (g \u2218 f)(x) = z,\n    given h\u2084 : \u2203 (x : X), (g \u2218 f)(x) \u2208 W \u2227 (g \u2218 f)(x) =  z,\n    rcases h\u2084 with \u27e8x, \u27e8h\u2085 : (g \u2218 f)(x) \u2208 W, h\u2086 : (g \u2218 f)(x) = z\u27e9\u27e9,\n    rwa \u2190h\u2086, },\n  { assume h\u2084 : z \u2208 W,\n    have h\u2085 : \u2203 (x : X), (g \u2218 f)(x) = z, from h\u2083 z,\n    cases h\u2085 with x h\u2086,\n    given h\u2086 : (g \u2218 f)(x) = z,\n    use x,\n    show (g \u2218 f)(x) \u2208 W \u2227 (g \u2218 f)(x) = z,\n    rw h\u2086,\n    split,\n    { from h\u2084, },\n    { from rfl }, }\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 33, "editorText": "sorry", "lineOffset": 40, "name": "comp_image_of_surjective", "statement": "(h\u2081 : surjective g) (h\u2082 : surjective f) (W : set Z):\n\u2203 (S : set X), (g \u2218 f) '' S = W"}, {"type": "lean", "content": "1359", "hidden": true}]}, {"name": "", "problemIndex": 17, "objects": [{"type": "lean", "content": "1360", "hidden": true}, {"type": "text", "content": "1361"}, {"type": "text", "content": "1362"}, {"type": "lean", "content": "1363", "hidden": true}, {"type": "lean", "content": "1364", "hidden": true}, {"type": "lean", "content": "1365", "hidden": false}, {"type": "lean", "content": "1366", "hidden": true}, {"type": "lean", "content": "1367", "hidden": false}, {"type": "text", "content": "1368"}, {"type": "lean", "content": "1369", "hidden": true}, {"type": "text", "content": "1370"}, {"type": "text", "content": "1371"}, {"type": "lean", "content": "1372", "hidden": false}, {"type": "text", "content": "1373"}, {"type": "lean", "content": "1374", "hidden": false}, {"type": "text", "content": "1375"}, {"type": "text", "content": "1376"}, {"type": "theorem", "text": "1377", "lean": "theorem compo2 : \u2203 (g : \u2124 \u2192 \u2115), (g(1) = 42) \u2227 (g \u2218 f = id) :=\n", "sideBar": false, "firstProofLineNumber": 120, "lastProofLineNumber": 139, "textBefore": "import functions.comp_image_of_surjective -- hide\n\n/-\n# Functions\n## Level 17: Identity and inverses\n-/\n\n/-\nGiven a type $X$, the identity function on $X$, denoted $\\text{id}_X$,\nis the function from $X$ to $X$ defined by $\\text{id}_X(x) := x$.\n\nGiven $f : X \\to Y$, it follows that $f \\circ \\text{id}_X = f$\nand $\\text{id}_Y \\circ f = f$.\n\nIn Lean, the identity function on a type `X` is denoted `@id X`.\nIn most situations, Lean can infer the type, in which case you\ncan denote the identity function as `id`.\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} -- hide\n\nexample (f : X \u2192 Y) : f \u2218 id = f :=\nbegin\n  from rfl\nend\n\n-- hide\n\nexample (f : X \u2192 Y) : id \u2218 f = f :=\nbegin\n  from rfl\nend\n\n/-\nSuppose $p : X \\to Y$ is a function. For a function $f : Y \\to X$ to \nbe a *left inverse* of $p$ means that $f \\circ p = \\text{id}_X$.\n\nLikewise, for a function $g : Y \\to X$ to be a *right inverse* of $p$ means that\n$p \\circ f = \\text{id}_Y$.\n-/\n\n\n\nnamespace compo2 -- hide\n\n/-\nLet $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. \n\n\nConsider the function $g_1 : \\mathbb Z \\to \\mathbb N$ defined\n*piecewise* by\n\n$g_1(y) :=\n\\begin{cases}\nn, & \\text{if $y = n + 2$ is a natural number}, \\\\\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$\n\nThen $g_1$ is a left inverse of $f$. Indeed, let $n : \\mathbb N$.\nThen\n$g_1(f(n)) = g_1(n + 2) = (n + 2) - 2 = n$,\nas $n + 2$ is a natural number.\n-/\n\n/-\nHere is our Lean definition of `f`.\n-/\n\ndef f : \u2115 \u2192 \u2124 := \u03bb x, x + 2\n\n/-\nBelow, we prove `\u2203 (g : \u2124 \u2192 \u2115), g \u2218 f = id`. The first step is\nto give a piecewise definition of a function `g`. We do this\nvia a Lean `match` expression. Compare this with the definition\ngiven above.\n\nAs the `match` expression of `g\u2081` consists of two cases, we use `split`\nto ask Lean to provide a proof in each of the cases.\n-/\n\nexample : \u2203 (g : \u2124 \u2192 \u2115), g \u2218 f = id :=\nbegin\n  let g\u2081 : \u2124 \u2192 \u2115 := \u03bb y,\n  match y with \n  | (n + 2 : \u2115) := n\n  | _           := 0\n  end,\n  use g\u2081, show g\u2081 \u2218 f = id,\n  ext x, show g\u2081(f(x)) = x,\n  split, -- consider each of the cases of the definition of `g\u2081`.\nend\n\n/-\nInterestingly, $f$ has more than one left inverse!\n-/\n\n\n/-\n## Task\nSuppose $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. Find a function $g : \\mathbb Z \\to \\mathbb N$ such\nthat $g(1) = 42$ and such that $g$ is a left inverse of $f$.\n\nYou should be able to do this by adapting the proof above.\n-/\n\n\n/- Theorem : no-side-bar\nSuppose $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. Then there exists a function\n$g : \\mathbb Z \\to \\mathbb N$ such that $g(1) = 42$ and such that\n$g$ is a left inverse of $f$.\n-/\ntheorem compo2 : \u2203 (g : \u2124 \u2192 \u2115), (g(1) = 42) \u2227 (g \u2218 f = id) :=\nbegin\n", "proof": "  let g\u2081 : \u2124 \u2192 \u2115 := \u03bb y,\n  match y with \n  | (n + 2 : \u2115) := n\n  | _           := 42\n  end,\n  use g\u2081, show g\u2081(1) = 42 \u2227 g\u2081 \u2218 f = id,\n  split,\n  { show 42 = 42, from rfl, },\n  { ext x, show g\u2081 (f(x)) = x, \n    split, },\n\n\n\n\n\n\n\n\n    \n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend compo2 -- hide\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 119, "name": "compo2", "statement": "\u2203 (g : \u2124 \u2192 \u2115), (g(1) = 42) \u2227 (g \u2218 f = id)"}, {"type": "lean", "content": "1378", "hidden": true}, {"type": "lean", "content": "1379", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1380", "hidden": true}, {"type": "text", "content": "1381"}, {"type": "text", "content": "1382"}, {"type": "lean", "content": "1383", "hidden": true}, {"type": "lean", "content": "1384", "hidden": true}, {"type": "text", "content": "1385"}, {"type": "theorem", "text": "1386", "lean": "theorem eq_of_right_inverse_of_left_inverse (h\u2081 : g\u2081 \u2218 f = @id X) (h\u2082 : f \u2218 g\u2082 = @id Y) :\ng\u2081 = g\u2082 :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 58, "textBefore": "import functions.identity_lr_inverse -- hide\n\n/-\n# Functions\n## Level 18: Uniqueness of inverses\n-/\n\n/-\n**Theorem**:\nSuppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n\n**Sketch Proof**: We are given $h_1 : g_1 \\circ f = \\text{id}_X$ and\n$h_2 : f \\circ g_2 = \\text{id}_Y$.\n\nSo\n\\begin{align}\ng_1 & = g_1 \\circ \\text{id}_Y & & \\text{by definition} \\\\\\\\\n& = \\dots & & \\dots \\\\\\\\\n& = \\text{id}_X \\circ g_2 & & \\dots \\\\\\\\\n& = g_2 & & \\text{by definition} \\\\\\\\\n\\end{align} \u220e\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g\u2081 g\u2082 : Y \u2192 X} -- hide\n\n\n/-\n## Task\nComplete the sketch proof above and write it as a Lean proof.\n-/\n\n\n/- Theorem : no-side-bar\nSuppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n-/\ntheorem eq_of_right_inverse_of_left_inverse (h\u2081 : g\u2081 \u2218 f = @id X) (h\u2082 : f \u2218 g\u2082 = @id Y) :\ng\u2081 = g\u2082 :=\nbegin\n", "proof": "  calc\n  g\u2081 = g\u2081 \u2218 (@id Y)    : by refl\n  ... = g\u2081 \u2218 (f \u2218 g\u2082)  : by rw h\u2082\n  ... = (g\u2081 \u2218 f) \u2218 g\u2082  : by rw comp.assoc\n  ... = id \u2218 g\u2082        : by rw h\u2081\n  ... = g\u2082             : by refl,\n\n\n\n\n\n\n\n\n    \n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 42, "name": "eq_of_right_inverse_of_left_inverse", "statement": "(h\u2081 : g\u2081 \u2218 f = @id X) (h\u2082 : f \u2218 g\u2082 = @id Y) :\ng\u2081 = g\u2082"}, {"type": "lean", "content": "1387", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1388", "hidden": true}, {"type": "text", "content": "1389"}, {"type": "text", "content": "1390"}, {"type": "lean", "content": "1391", "hidden": true}, {"type": "lean", "content": "1392", "hidden": true}, {"type": "lean", "content": "1393", "hidden": true}, {"type": "text", "content": "1394"}, {"type": "theorem", "text": "1395", "lean": "theorem injective_of_left_inverse  (h\u2081 : g \u2218 f = id) :\ninjective f :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 63, "textBefore": "import functions.uniqueness_of_inverse -- hide\n\n/-\n# Functions\n## Level 19: A function with a left inverse is injective\n-/\n\n/-\n**Theorem**:\nSuppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a left inverse of $f$.\nThen $f$ is injective.\n\n**Sketch Proof**:\nWe must show $\\forall (x_1\\ x_2 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\nAssume $x_1,\\ x_2 : X$. Assume $h : f(x_1) = f(x_2)$. We must show $x_1 = x_2$.\nNow\n\n\\begin{align}\nx_1 & = \\text{id}_X(x_1) & & \\text{by definition} \\\\\\\\\n& = \\dots & & \\dots \\\\\\\\\n& = \\text{id}_X(x_2) & & \\dots \\\\\\\\\n& = x_2 & & \\text{by definition} \\\\\\\\\n\\end{align} \u220e\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g : Y \u2192 X} -- hide\n\nopen function -- hide\n/-\n## Task\nComplete the sketch proof above and write it as a Lean proof. At some point in your\nproof, you'll need to prove an equation. I suggest proving this by calculation.\n-/\n\n\n/- Theorem :\nSuppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n-/\ntheorem injective_of_left_inverse  (h\u2081 : g \u2218 f = id) :\ninjective f :=\nbegin\n", "proof": "  show \u2200 (x\u2081 x\u2082 : X), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082,\n  assume x\u2081 x\u2082 : X,\n  assume h : f(x\u2081) = f(x\u2082),\n  show x\u2081 = x\u2082,\n  calc\n  x\u2081 = id(x\u2081)           : by refl\n  ... = (g \u2218 f) (x\u2081)    : by rw h\u2081\n  ... = g(f(x\u2081))        : by refl\n  ... = g(f(x\u2082))        : by rw h\n  ... = (g \u2218 f)(x\u2082)     : by refl\n  ... = id(x\u2082)          : by rw h\u2081\n  ... = x\u2082              : by refl,\n\n\n\n\n\n    \n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 44, "name": "injective_of_left_inverse", "statement": "(h\u2081 : g \u2218 f = id) :\ninjective f"}, {"type": "lean", "content": "1396", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1397", "hidden": true}, {"type": "text", "content": "1398"}, {"type": "lean", "content": "1399", "hidden": true}, {"type": "lean", "content": "1400", "hidden": true}, {"type": "lean", "content": "1401", "hidden": true}, {"type": "text", "content": "1402"}, {"type": "theorem", "text": "1403", "lean": "theorem surjective_of_right_inverse (h\u2081 : f \u2218 g = id) :\nsurjective f :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 39, "textBefore": "import functions.inj_of_left_inv -- hide\n\n/-\n# Functions\n## Level 20: A function with a right inverse is surjective\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g : Y \u2192 X}  -- hide\n\nopen function -- hide\n/-\n## Task\nSuppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a right inverse of $f$.\nProve that $f$ is surjective.\n-/\n\n\n/- Theorem :\nSuppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a right inverse of $f$.\nThen $f$ is surjective.\n\n-/\ntheorem surjective_of_right_inverse (h\u2081 : f \u2218 g = id) :\nsurjective f :=\nbegin\n", "proof": "  show \u2200(y : Y), \u2203(x : X), f(x) = y,\n  assume y : Y,\n  use g(y),\n  show (f \u2218 g)(y) = y,\n  rw h\u2081,\n  show id(y) = y, from rfl,\n\n\n\n\n    \n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 27, "name": "surjective_of_right_inverse", "statement": "(h\u2081 : f \u2218 g = id) :\nsurjective f"}, {"type": "lean", "content": "1404", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "1405", "hidden": true}, {"type": "text", "content": "1406"}, {"type": "text", "content": "1407"}, {"type": "lean", "content": "1408", "hidden": true}, {"type": "lean", "content": "1409", "hidden": true}, {"type": "lean", "content": "1410", "hidden": true}, {"type": "text", "content": "1411"}, {"type": "text", "content": "1412"}, {"type": "axiom", "content": "1413", "name": "axiom_of_choice (h : \u2200 (u : U), \u2203 (v : V), R u v) :", "sideBar": true}, {"type": "lean", "content": "1414", "hidden": false}, {"type": "text", "content": "1415"}, {"type": "lean", "content": "1416", "hidden": false}, {"type": "lean", "content": "1417", "hidden": true}, {"type": "lean", "content": "1418", "hidden": true}, {"type": "lean", "content": "1419", "hidden": true}, {"type": "lean", "content": "1420", "hidden": true}, {"type": "lean", "content": "1421", "hidden": true}, {"type": "text", "content": "1422"}, {"type": "hint", "content": "1423", "title": "1424"}, {"type": "theorem", "text": "1425", "lean": "theorem right_inverse_of_surjective (h : surjective f) :\n\u2203(g : Y \u2192 X), f \u2218 g = id :=\n", "sideBar": true, "firstProofLineNumber": 115, "lastProofLineNumber": 128, "textBefore": "import functions.surj_of_right_inv-- hide\n\n/-\n# Functions\n## Level 21: A surjective function has a right inverse\n\nThe remaining levels are only for the experts. Our aim is to prove (partial)\nconverses of two of the previous results. For a function $f : X \\to Y$, we\nhave proved:\n\n* If $f$ has a right inverse, then $f$ is surjective.\n* If $f$ has a left inverse, then $f$ is injective.\n\nWe'll now prove:\n\n* If $f$ is surjective, then $f$ has a right inverse\n* If $f$ is injective *and* there is a term of type $X$, then $f$ has a left inverse.\n\nHowever, we cannot prove these results without relying on another principle of\nclassical (i.e. non-constructive) mathematics. This is the *axiom of choice*.\n-/\n\n/-\nThe axiom of choice is best explained via an example. Let $U$ denote the type of all modules\ncurrently running at Exeter and let $V$ denote the type of all students at Exeter.\n\nLet the two-variable predicate $R$ on $U$ and $V$ be defined so that $R(u,v)$ is the proposition\nthat student $v$ is enrolled on module $u$.\n\nWe know that for every module $u$, there is a student $v$ who is enrolled on $u$. That is,\n$\\forall (u : U),\\ \\exists (v : V),\\ R(u, v)$.\n\nThe axiom of choice asserts, under these hypotheses, that there is a function $g : U \\to V$ such that\n$R(u,g(u))$ holds for every $u : U$.\n\nIn our example, this means that for every module $u$, $g(u)$ is a student enrolled on $u$.\nIn other words, the axiom of choice guarantees the existence of a function that has (informally) *chosen*, for\neach module $u$, a student $v$ enrolled on $u$. Crucially, the axiom of choice is non-constructive: it does not\ngive an algorithm for finding such a function.\n\nMoreover such a function is not (necessarily) unique! There are \nmany functions with this property.\n-/\n\nsection aoc -- hide\n\nopen classical -- hide\n\nvariables {U : Type*} {V : Type*} {R : U \u2192 V \u2192 Prop} -- hide\n\n/-\nAs a more mathematical example, suppose we have a function $p : \\mathbb Q \\to \\mathbb Z$ with the \nproperty that for every $u : \\mathbb Q$, there exists a $v : \\mathbb Z$ such that $p(uv) > v$.\n\nBy the axiom of choice, we know that there is a function $g : \\mathbb Q \\to \\mathbb Z$ such that\nfor every $u : \\mathbb Q$, $p(ug(u)) > g(u)$.\n-/\n\n\n/-\nIn Lean, the axiom of choice is called `axiom_of_choice`. Here's the example above in Lean.\n-/\n\n\n/- Axiom : axiom_of_choice (h : \u2200 (u : U), \u2203 (v : V), R u v) :\n\u2203 g : U \u2192 V, \u2200 (u : U), R u (g u)\n-/\n\nexample (p : \u211a \u2192 \u2124) (h : \u2200 (u : \u211a), \u2203 (v : \u2124), p(u * v) > v) :\n\u2203 (g : \u211a \u2192 \u2124), \u2200 (u : \u211a), p(u * g(u)) > g(u) :=\nbegin\n  from axiom_of_choice h,\nend\n\n/-\nHere is a prototypical application of the axiom of choice.\n\n-/\n\nexample (h : \u2200 (u : U), \u2203 (v : V), R u v) : \u2203 (g : U \u2192 V), \u2200 (u : U), R u (g u) :=\nbegin\n  from axiom_of_choice h\nend\n\n\n\nend aoc -- hide\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y} -- hide\n\nopen function -- hide\n\nopen classical -- hide\n\n/-\n## Task\nSuppose $f : X \\to Y$. Suppose that $f$ is surjective. Prove, using the axiom of choice, that $f$ has a right inverse.\n-/\n\n/- Hint : How does the axiom of choice help?\nThink about your the hypothesis `h` relates in the theorem statement below relates to the `h`\nin the example above. What corresponds to `U`, `V` and `R u v`?\n-/\n\n\n/- Theorem :\nSuppose $f : X \\to Y$. Suppose that $f$ is surjective. Then $f$ has a right inverse.\n\n-/\ntheorem right_inverse_of_surjective (h : surjective f) :\n\u2203(g : Y \u2192 X), f \u2218 g = id :=\nbegin\n", "proof": "  given h : \u2200 (y : Y), \u2203(x : X), f(x) = y,\n  have h\u2082 : \u2203 (g : Y \u2192 X), \u2200 (y : Y), f(g(y)) = y, from axiom_of_choice h,\n  cases h\u2082 with g h\u2083,\n  use g,\n  ext y,\n  from h\u2083 y,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 114, "name": "right_inverse_of_surjective", "statement": "(h : surjective f) :\n\u2203(g : Y \u2192 X), f \u2218 g = id"}, {"type": "lean", "content": "1426", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1427", "hidden": true}, {"type": "text", "content": "1428"}, {"type": "lean", "content": "1429", "hidden": true}, {"type": "lean", "content": "1430", "hidden": true}, {"type": "lean", "content": "1431", "hidden": true}, {"type": "lean", "content": "1432", "hidden": true}, {"type": "text", "content": "1433"}, {"type": "theorem", "text": "1434", "lean": "theorem left_inverse_of_injective (d : X) (h : injective f) :\n\u2203(g : Y \u2192 X), g \u2218 f = id :=\n", "sideBar": true, "firstProofLineNumber": 38, "firstProofHintLineNumber": 67, "lastProofHintLineNumber": 70, "lastProofLineNumber": 80, "textBefore": "import functions.right_inv_of_surjective -- hide\n\n/-\n# Functions\n## Level 22: An injective function has a left inverse\n\n\n-/\n\nnamespace exlean -- hide\n\nvariables {X : Type*} {Y : Type*} {f : X \u2192 Y}  -- hide\n\nopen function -- hide\n\nopen classical -- hide\n\n/-\n## Task\nThis is the hardest level so far. Your task is to use the axiom of choice and\nother classical reasoning methods to prove that if $f : X \\to Y$ is injective and\nif there is some term $d$ of type $X$, then $f$ has a left inverse.\n\nYou are given a sketch of the start of the proof. Complete the proof of hypothesis `h\u2082`.\nDetermine what results from applying the axiom of choice to `h\u2082`, then complete the\nremainder of the proof.\n-/\n\n\n/- Theorem :\nSuppose $f : X \\to Y$. Suppose that $f$ is injective. Suppose $d$ is a term of the type\n$X$ (so the type isn't empy). Then $f$ has a left inverse.\n\n-/\ntheorem left_inverse_of_injective (d : X) (h : injective f) :\n\u2203(g : Y \u2192 X), g \u2218 f = id :=\nbegin\n", "proof": "  given h : \u2200 (x\u2081 x\u2082 : X), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082,\n  have h\u2082 : \u2200 (y : Y), \u2203 (a : X), ((f(a) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y)),\n  { assume y : Y,\n    by_cases h\u2083 : \u2203 (u : X), f(u) = y,\n    { given h\u2083 : \u2203 (u : X), f(u) = y,\n      cases h\u2083 with u h\u2084,\n      use u,\n      left,\n      from h\u2084, },\n    { given h\u2083 : \u00ac(\u2203 (u : X), f(u) = y),\n      use d,\n      right,\n      from h\u2083, }, },\n  have h\u2083 : \u2203 (g : Y \u2192 X), \u2200 (y : Y), (f(g(y)) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y),\n    from axiom_of_choice h\u2082,\n  cases h\u2083 with g h\u2084,\n  given h\u2084 : \u2200 (y : Y), (f(g(y)) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y),\n  use g,\n  ext u,\n  show g(f(u)) = u,\n  have h\u2085 : (f(g(f(u))) = f(u)) \u2228 \u00ac(\u2203 (x : X), f(x) = f(u)), from h\u2084 (f(u)),\n  cases h\u2085 with h\u2086 h\u2086,\n  { given h\u2086 : f(g(f(u))) = f(u),\n    show g(f(u)) = u, from h _ _ h\u2086, },\n  { given h\u2086 : \u00ac(\u2203 (x : X), f(x) = f(u)),\n    exfalso,\n    apply h\u2086,\n    use u, }\n/- hint\ngiven h : \u2200 (x\u2081 x\u2082 : X), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082,\nhave h\u2082 : \u2200 (y : Y), \u2203 (a : X), ((f(a) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y)),\n{ sorry, },\nsorry,\n-/\n\n\n\n\n\n\n\n\n", "proof_hint": "given h : \u2200 (x\u2081 x\u2082 : X), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082,\nhave h\u2082 : \u2200 (y : Y), \u2203 (a : X), ((f(a) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y)),\n{ sorry, },\nsorry,", "textAfter": "\nend\n\n\n\n\n\nend exlean -- hide", "height": 43, "editorText": "given h : \u2200 (x\u2081 x\u2082 : X), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082,\nhave h\u2082 : \u2200 (y : Y), \u2203 (a : X), ((f(a) = y) \u2228 \u00ac(\u2203 (x : X), f(x) = y)),\n{ sorry, },\nsorry,", "lineOffset": 37, "name": "left_inverse_of_injective", "statement": "(d : X) (h : injective f) :\n\u2203(g : Y \u2192 X), g \u2218 f = id"}, {"type": "lean", "content": "1435", "hidden": true}]}], "parents": [4]}, {"name": "1436", "levels": [{"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1437", "hidden": true}, {"type": "lean", "content": "1438", "hidden": true}, {"type": "text", "content": "1439"}, {"type": "lean", "content": "1440", "hidden": true}, {"type": "lean", "content": "1441", "hidden": false}, {"type": "text", "content": "1442"}, {"type": "lean", "content": "1443", "hidden": true}, {"type": "lean", "content": "1444", "hidden": false}, {"type": "lean", "content": "1445", "hidden": true}, {"type": "lean", "content": "1446", "hidden": false}, {"type": "lean", "content": "1447", "hidden": true}, {"type": "text", "content": "1448"}, {"type": "lean", "content": "1449", "hidden": true}, {"type": "lean", "content": "1450", "hidden": false}, {"type": "theorem", "text": "1451", "lean": "theorem seven_is_ub_rat : is_upper_bound T 7 :=\n", "sideBar": false, "firstProofLineNumber": 62, "lastProofLineNumber": 75, "textBefore": "import order tactic.modded sets.powerset_inter -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 1: Upper bound definition\n\nLet $X$ be an type equipped with an preorder (a relation that is\nreflexive and transitive). Let $S$ be a set on $X$. Then $u : X$ is said to be an\n*upper bound* of $S$ if for every $x : X$, if $x \\in S$, then $x \\le u$.\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\ndef is_upper_bound (S : set X) (u : X) := \u2200 (x : X), x \u2208 S \u2192 x \u2264 u\n\n\n/-\nAs a simple example, we'll show that $10$ is an upper bound of the set $S$ of rational numbers $x$\nsuch that $x \\le 5$.\n\n**Proof**. Suppose $x : \\mathbb Q$. Suppose $x \\in S$. Then $x \\le 5$. But $5 \\le 10$, so $x \\le 10$.\n\u220e\n-/\n\nnamespace up1 -- hide\n\ndef S := {x : \u211a | x \u2264 5}\n\n-- hide\n\nexample : is_upper_bound S 10 :=\nbegin\n  show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 10,\n  assume x : \u211a,\n  assume h : x \u2208 S,\n  given h : x \u2264 5,\n  show x \u2264 10, linarith,\nend\n\nend up1 -- hide\n\n\n/-\n## Task\n\nAdapt the proof above to show that $7$ is an upper bound of the set $T$ of rational numbers $x$\nsuch that $3x + 5 \\le  25$.\n-/\n\nnamespace up1 -- hide\n\ndef T := {x : \u211a  | 3 * x + 5 \u2264 23}\n\n/- Theorem : no-side-bar\nThe set $T$ of rational numbers $x$ such that $3x + 5 \\le  23$ has $7$ as an upper bound.\n-/\ntheorem seven_is_ub_rat : is_upper_bound T 7 :=\nbegin\n", "proof": "  show \u2200 (x : \u211a), x \u2208 T \u2192 x \u2264 7,\n  assume x : \u211a,\n  assume h : x \u2208 T,\n  given h : 3 * x + 5 \u2264 23,\n  show x \u2264 7, linarith,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend up1 -- hide\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 61, "name": "seven_is_ub_rat", "statement": "is_upper_bound T 7"}, {"type": "lean", "content": "1452", "hidden": true}, {"type": "lean", "content": "1453", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1454", "hidden": true}, {"type": "lean", "content": "1455", "hidden": true}, {"type": "text", "content": "1456"}, {"type": "text", "content": "1457"}, {"type": "hint", "content": "1458", "title": "1459"}, {"type": "lean", "content": "1460", "hidden": true}, {"type": "lean", "content": "1461", "hidden": true}, {"type": "lean", "content": "1462", "hidden": false}, {"type": "theorem", "text": "1463", "lean": "theorem twelve_is_ub_rat : is_upper_bound S 12 :=\n", "sideBar": false, "firstProofLineNumber": 41, "lastProofLineNumber": 56, "textBefore": "import reals.upper_bounds -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 2: Upper bound second example\n-/\n\n/-\n## Task\n\nIn this level, $S$ is the set of rational numbers $x$ such that either $-4 < x < 0$ or $2 < x < 10$,\na union of two intervals of rational numbers. You are asked to prove that $12$ is an upper bound of $S$.\n\nIn addition to the ideas introduced in the previous level, you will need to employ or elimination, together\nwith and elimination. The quickest approach is to use the `rcases` tactic from the Functions World.\n-/\n\n/- Hint: A proof template\nYou should begin with the following template.\n```\nshow \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 12,\nsorry,\n```\n-/\n\nnamespace up2 -- hide\n\n-- hide\n\ndef S := {x : \u211a | ((-4 < x) \u2227 (x < 0)) \u2228 ((2 < x) \u2227 (x < 10))}\n\n/- Theorem : no-side-bar\nLet $S$ be the set of rational numbers $x$ such that either $-4 < x < 0$ or $2 < x < 10$. Then $12$ is an upper\nbound of $S$.\n-/\ntheorem twelve_is_ub_rat : is_upper_bound S 12 :=\nbegin\n", "proof": "  show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 12,\n  assume x : \u211a,\n  assume h : x \u2208 S,\n  given h : ((-4 < x) \u2227 (x < 0)) \u2228 ((2 < x) \u2227 (x < 10)),\n  rcases h with (\u27e8h\u2081, h\u2082\u27e9 | \u27e8h\u2081, h\u2082\u27e9),\n  { linarith, },\n  { linarith, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend up2\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 40, "name": "twelve_is_ub_rat", "statement": "is_upper_bound S 12"}, {"type": "lean", "content": "1464", "hidden": false}, {"type": "lean", "content": "1465", "hidden": true}]}, {"name": "", "problemIndex": 23, "objects": [{"type": "lean", "content": "1466", "hidden": true}, {"type": "lean", "content": "1467", "hidden": true}, {"type": "text", "content": "1468"}, {"type": "lean", "content": "1469", "hidden": true}, {"type": "text", "content": "1470"}, {"type": "lean", "content": "1471", "hidden": false}, {"type": "text", "content": "1472"}, {"type": "lean", "content": "1473", "hidden": true}, {"type": "lean", "content": "1474", "hidden": false}, {"type": "lean", "content": "1475", "hidden": true}, {"type": "lean", "content": "1476", "hidden": false}, {"type": "lean", "content": "1477", "hidden": true}, {"type": "text", "content": "1478"}, {"type": "axiom", "content": "1479", "name": "sq_lt_sq_of_pos (h : a < b) (h\u2082 : 0 < a) :", "sideBar": true}, {"type": "lean", "content": "1480", "hidden": true}, {"type": "lean", "content": "1481", "hidden": true}, {"type": "lean", "content": "1482", "hidden": false}, {"type": "text", "content": "1483"}, {"type": "text", "content": "1484"}, {"type": "text", "content": "1485"}, {"type": "lean", "content": "1486", "hidden": true}, {"type": "lean", "content": "1487", "hidden": false}, {"type": "lean", "content": "1488", "hidden": true}, {"type": "theorem", "text": "1489", "lean": "example : bounded_above T :=\n", "sideBar": false, "firstProofLineNumber": 105, "lastProofLineNumber": 124, "textBefore": "import reals.upper_bounds2 -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 3: Sets that are bounded above\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\n/-\nFor a set $S$ to be bounded above means that $S$ has an upper bound.\n-/\n\ndef bounded_above (S : set X) := \u2203 (u : X), is_upper_bound S u\n\n/-\nFor example, let $S$ be the set of rational numbers $x$ such that $x - 2 \\le 5$.\nTo show that $S$ is bounded above is to exhibit a value $u$ and a proof that $u$\nis an upper bound of $S$. We do this below in Lean\n-/\n\nnamespace ub_bdd_above -- hide\n\ndef S := {x : \u211a | x - 2 \u2264 5} \n\n-- hide\n\nexample : bounded_above S :=\nbegin\n  show \u2203 (u : \u211a), is_upper_bound S u,\n  use 7, -- Take \"u\" to be 7.\n  show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 7,\n  assume x : \u211a,\n  assume h : x \u2208 S,\n  given h : x - 2 \u2264 5,\n  show x \u2264 7, linarith,\nend\n\n\nend ub_bdd_above -- hide\n\n/-\nFrom your study of school algebra, you know that for a ordered type such as $\\mathbb Z$, $\\mathbb Q$, or $\\mathbb R$ with `nice' addition,\nsubtraction and multiplication, given $a < b$ and $0 < a$, one can deduce $a ^ 2 < b ^2$.\n\nWe have this in Lean as the theorem `sq_lt_sq_of_pos`\n-/\n\n/- Axiom : sq_lt_sq_of_pos (h : a < b) (h\u2082 : 0 < a) :\na ^ 2 < b ^ 2\n-/\n\n\nlemma sq_lt_sq_of_pos {R : Type*} {a b : R} [linear_ordered_ring R] -- hide\n(h : a < b) (h\u2082 : 0 < a) : a ^ 2 < b ^ 2 := sq_lt_sq' (lt_trans (neg_lt_zero.mpr (lt_trans h\u2082 h)) h\u2082) h -- hide\n\nexample (a b : \u211a) (h : a < b) (h\u2082 : 0 < a) : a ^2 < b ^2 :=\nbegin\n  from sq_lt_sq_of_pos h h\u2082,\nend\n\n/-\nWe'll use this result to help in working with sets of numbers $x$ that satisfy a condition like $x^2 < 5$.\n\nLet $S$ be the set of all rational numbers $x$ such that $x^2 < 1$. We'll prove that $5$ is an upper bound of $S$.\n\n**Proof**: Assume that $x : \\mathbb Q$ and that $x \\in S$. Then (by definition of $S$), we have\n$x ^ 2 < 1$. Our aim is to show $x \\le 5$.\n\nSuppose, for a contradiction, that $\\neg (x \\le 5)$. We deduce that $5 < x$. But $0 < 5$, so\nwe deduce $5 ^ 2 < x ^ 2$. But this gives a contradiction with the assumption $x^2 < 1$. \u220e\n-/\n\n/-\nLet's prove this in Lean. One thing to look out for is that in our Lean proof of $0 < 5$,\nwe need to specify that we are dealing with *rational* numbers rather than natural numbers.\nWe do this by using a type annotation in `(0 : \u211a) < 5`.\n-/\n\n\n/-\n## Task\nLet $T$ be the set of rational numbers $x$ for which $(x + 1)^2 < 8$. Your task is to\nshow that $T$ is bounded above.\n\nTo do this, you need to *find* such a value $u$ and then show that it is an upper bound. For\nthe second part of the proof, you may adapt the proof above.\n-/\n\nnamespace ubsq -- hide\n\ndef T := {x : \u211a  | (x + 1) ^ 2 < 17}\n\n-- hide\n\n/- Theorem : no-side-bar\nLet $T$ be the set of rational numbers $x$ for which $(x + 1)^2 < 17$. Then $T$ is\nbounded above\n-/\nexample : bounded_above T :=\nbegin\n", "proof": "  use 4,\n  assume x : \u211a,\n  assume h : x \u2208 T,\n  given h : (x + 1) ^ 2 < 17,\n  show x \u2264 4,\n  by_contra k,\n  given k : \u00ac(x \u2264 4),\n  have h\u2082 : 4 < x, linarith,\n  have h\u2083 : (0 : \u211a) < 4, linarith,\n  have h\u2084 : 4 ^ 2 < x ^2, from sq_lt_sq_of_pos h\u2082 h\u2083,\n  show false, linarith,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend ubsq -- hide\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 104, "name": "", "statement": "bounded_above T"}, {"type": "lean", "content": "1490", "hidden": true}, {"type": "lean", "content": "1491", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1492", "hidden": true}, {"type": "lean", "content": "1493", "hidden": true}, {"type": "text", "content": "1494"}, {"type": "lean", "content": "1495", "hidden": true}, {"type": "text", "content": "1496"}, {"type": "lean", "content": "1497", "hidden": false}, {"type": "text", "content": "1498"}, {"type": "lean", "content": "1499", "hidden": false}, {"type": "text", "content": "1500"}, {"type": "lean", "content": "1501", "hidden": false}, {"type": "text", "content": "1502"}, {"type": "lean", "content": "1503", "hidden": true}, {"type": "lean", "content": "1504", "hidden": false}, {"type": "lean", "content": "1505", "hidden": true}, {"type": "theorem", "text": "1506", "lean": "theorem has_lb_rat : bounded_below T :=\n", "sideBar": false, "firstProofLineNumber": 57, "lastProofLineNumber": 71, "textBefore": "import reals.upper_bounds_squares -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 4: Lower bounds\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\n/-\nLet $S$ be a set on an preordered type $X$. For a term $v$ of type $X$ to be\na *lower bound* of $S$ means that for all $x : X$, if $x \\in S$, then $v \\le x$.\n\nHere is the definition in Lean.\n-/\n\ndef is_lower_bound (S : set X) (v : X) := \u2200 (x : X), x \u2208 S \u2192 v \u2264 x\n\n/-\nFor a set $S$ to be *bounded below* means that there exists a term\n$v : X$ for which $v$ is a lower bound of $S$.\n-/\n\ndef bounded_below (S : set X) := \u2203 (v : X), is_lower_bound S v\n\n\n/-\nFor a set to be *bounded* means that it is bounded above and bounded below.\n-/\n\ndef bounded (S : set X) := (bounded_above S) \u2227 (bounded_below S)\n\n\n/-\n## Task\nLet $T$ be the set of rational numbers $x$ such that $2x + 3 > 26$.\nShow that $T$ is bounded below.\n\nYou should be able to do this by choosing an appropriate value $v$ then\n(adapting the work on upper bounds), showing that $v$ is a lower bound of $T$.\n-/\n\nnamespace lb1 -- hide\n\ndef T := {x : \u211a  | 2 * x + 3 > 26 }\n\n-- hide\n\n/- Theorem : no-side-bar\nThe set $T$ defined above is bounded below.\n-/\ntheorem has_lb_rat : bounded_below T :=\nbegin\n", "proof": "  use 11,\n  show \u2200 (x : \u211a), x \u2208 T \u2192 11 \u2264 x,\n  assume x : \u211a,\n  assume h : x \u2208 T,\n  given h : 2 * x + 3 > 26,\n  show 11 \u2264 x, linarith,\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend lb1 -- hide\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 56, "name": "has_lb_rat", "statement": "bounded_below T"}, {"type": "lean", "content": "1507", "hidden": true}, {"type": "lean", "content": "1508", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "1509", "hidden": true}, {"type": "lean", "content": "1510", "hidden": true}, {"type": "text", "content": "1511"}, {"type": "lean", "content": "1512", "hidden": true}, {"type": "text", "content": "1513"}, {"type": "axiom", "content": "1514", "name": "is_upper_bound_of_is_upper_bound_of_subset", "sideBar": true}, {"type": "lean", "content": "1515", "hidden": false}, {"type": "text", "content": "1516"}, {"type": "lean", "content": "1517", "hidden": false}, {"type": "text", "content": "1518"}, {"type": "theorem", "text": "1519", "lean": "theorem is_lower_bound_of_is_lower_bound_of_subset (v : X)\n(h\u2081 : S \u2286 T) (h\u2082 : is_lower_bound T v) : is_lower_bound S v :=\n", "sideBar": false, "firstProofLineNumber": 89, "lastProofLineNumber": 102, "textBefore": "import reals.lower_bounds -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 5: Using upper bounds & lower bounds\n\nWe've seen how to *prove* that a term is an upper bound of a set. If we are *given* that a term is\nan upper bound of a set, how do we use that information?\n-/\n\nvariables  {X : Type*} {S T : set X} [preorder X] -- hide\n\n\n\n/-\nWe start by proving that if $S \\subseteq T$ and if $u$ is an upper bound of $T$, then\nthen $u$ is an upper bound of $S$.\n\nIn the Lean proof below, we start with `h\u2081 : S \u2286 T` and `h\u2082 : is_upper_bound T u`. By definition,\n`h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u`.\n\nTo show `is_upper_bound S u` is to show `\u2200 (x : X), x \u2208 S \u2192 x \u2264 u`.\n\nThis is a `\u2200` statement, so we assume `x : X`. We have to prove the implication `x \u2208 S \u2192 x \u2264 u`.\nThus we assume `h\u2083 : x \u2208 S` and are left with proving `x \u2264 u`. From the hypothesis `h\u2081 : S \u2286 T` and\nthe deduction `h\u2083 : x \u2208 S`, we derive `h\u2084 : x \u2208 T`.\n\nFinally, we use the upper bound property `h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u`. We apply this to `x`\nand to `h\u2082 : x \u2208 T` and derive `x \u2264 u`.\n-/\n\n/- Axiom : is_upper_bound_of_is_upper_bound_of_subset\n(u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u\n-/\n\nlemma is_upper_bound_of_is_upper_bound_of_subset\n(u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u :=\nbegin\n  given h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u,\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2264 u,\n  assume x : X,\n  assume h\u2083 : x \u2208 S,\n  have h\u2084 : x \u2208 T, from h\u2081 h\u2083,\n  show x \u2264 u, from h\u2082 x h\u2084,\nend\n\n/-\n## Implicit variables\nOne small time-saving measure is to realise, in using `\u2200 {x : X}, x \u2208 T \u2192 x \u2264 u`, that the quantity\n`x` is implicitly determined by a proof of `x \u2208 T`. We can ask Lean to try to infer that variable by\nusing braces in `h\u2082 : \u2200 {x : X}, x \u2208 T \u2192 x \u2264 u` below.\n\nOur final deduction is then from `h\u2082 h\u2084`, rather than `h\u2082 x h\u2084`. Use this technique if you find it\nhelpful.\n-/\n\nexample (u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u :=\nbegin\n  -- Using {x : X} in place of (x : X) makes x implicit.\n  given h\u2082 : \u2200 {x : X}, x \u2208 T \u2192 x \u2264 u,\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2264 u,\n  assume x : X,\n  assume h\u2083 : x \u2208 S,\n  have h\u2084 : x \u2208 T, from h\u2081 h\u2083,\n  show x \u2264 u, from h\u2082 h\u2084, -- Note that `x` does not appear in this line\nend\n\n/-\n## Task\n\nAdapt either of the proofs above to show that if $S$ and $T$ are sets and if $v$ is a lower bound\nof $S$, then $v$ is a lower bound of $T$.\n-/\n\n/- Theorem : no-side-bar\nIf $S$ and $T$ are sets and if $v$ is a lower bound of $S$, then $v$ is a lower bound of $T$.\n-/\n\n\ntheorem is_lower_bound_of_is_lower_bound_of_subset (v : X)\n(h\u2081 : S \u2286 T) (h\u2082 : is_lower_bound T v) : is_lower_bound S v :=\nbegin\n", "proof": "  given h\u2082 : \u2200 {x : X}, x \u2208 T \u2192 v \u2264 x, \n  show \u2200 (x : X), x \u2208 S \u2192 v \u2264 x,\n  assume x : X,\n  assume h\u2083 : x \u2208 S,\n  have h\u2084 : x \u2208 T, from h\u2081 h\u2083,\n  show v \u2264 x, from h\u2082 h\u2084,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 88, "name": "is_lower_bound_of_is_lower_bound_of_subset", "statement": "(v : X)\n(h\u2081 : S \u2286 T) (h\u2082 : is_lower_bound T v) : is_lower_bound S v"}, {"type": "lean", "content": "1520", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "1521", "hidden": true}, {"type": "lean", "content": "1522", "hidden": true}, {"type": "text", "content": "1523"}, {"type": "text", "content": "1524"}, {"type": "lean", "content": "1525", "hidden": true}, {"type": "text", "content": "1526"}, {"type": "text", "content": "1527"}, {"type": "tactic", "content": "1528", "name": "norm_num", "sideBar": true}, {"type": "lean", "content": "1529", "hidden": false}, {"type": "lean", "content": "1530", "hidden": true}, {"type": "text", "content": "1531"}, {"type": "lean", "content": "1532", "hidden": true}, {"type": "lean", "content": "1533", "hidden": false}, {"type": "theorem", "text": "1534", "lean": "theorem seven_not_upb : \u00ac(is_upper_bound T 7) :=\n", "sideBar": false, "firstProofLineNumber": 81, "lastProofLineNumber": 94, "textBefore": "import reals.using_bounds -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 6: Not an upper bound\n-/\n\n/-\nFor a set $S$ to have $u$ as an upper bound means\n$\\forall (x : X), x \\in S \\to x \\le u$.\n\nFrom our study of predicate and propositional logic, we know that\nthe statement \"$u$ is *not* an upper bound of $S$\" is equivalent to\n$\\exists (x : X), x \\in S \\land u < x$.\n-/\n\nnamespace not_upb -- hide\n\n/-\nIn this example, let $S$ be the set of all integers such that\n$x ^ 2 \\le 100$. We'll show that the integer $5$ is not an\nupper bound of $S$.\n\n**Proof**: We must show $\\neg (\\forall (x : \\mathbb Z), x \\in S \\to x \\le 5)$.\nEquivalently, to show $\\exists(x : \\mathbb Z), x ^ 2 \\le 100 \\land 5 < x$.\n\nTake `$x$' to be $10$. We must show $10^2 \\le 100$ and $5 < 10$.\nEach of these follows by arithmetic. \u220e\n-/\n\n/-\nHere is the corresponding Lean proof. Note the use of type annotations\nso Lean knows we are dealing with integers not natural numbers.\n\nWe also introduce a new tactic, `norm_num`. This is particularly useful\nfor deadling with numeric expressions.\n-/\n\n/- Tactic : norm_num\nProves numeric equations and inequalities.\n-/\n\ndef S := {x : \u2124 | x ^ 2 \u2264 100}\n\nexample : \u00ac(is_upper_bound S 5) :=\nbegin\n  show \u00ac(\u2200 (x : \u2124), x \u2208 S \u2192 x \u2264 5),\n  push_neg,\n  show \u2203 (x : \u2124), x ^2 \u2264 100 \u2227 5 < x,\n  use 10, -- Take \"x\" to be 10.\n  split,\n  { show (10 : \u2124) ^2 \u2264 100, norm_num, },\n  { show (5 : \u2124) < 10, norm_num, },\nend\n\n\nend not_upb -- hide\n\n\n/-\n## Task\n\nLet $T$ be the set of rational numbers $x$ such that $(x + 2)^3 \\le 800$.\nShow that $7$ is not an upper bound of $T$.\n\n**Use the `norm_num` tactic** for proving any numerical equations or inequalities.\n-/\n\nnamespace not_upb -- hide\n\ndef T := {x : \u211a | (x + 2) ^ 3 \u2264 800}\n\n/- Theorem : no-side-bar\nThe rational number $7$ is not an upper bound of the set $T$ above.\n-/\ntheorem seven_not_upb : \u00ac(is_upper_bound T 7) :=\nbegin\n", "proof": "  show \u00ac(\u2200 (x : \u211a), x \u2208 T \u2192 x \u2264 7),\n  push_neg,\n  show \u2203 (x : \u211a), (x + 2) ^ 3 \u2264 800 \u2227 7 < x,\n  use 7.1,\n  split,\n  { norm_num, },\n  { norm_num, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend not_upb\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 80, "name": "seven_not_upb", "statement": "\u00ac(is_upper_bound T 7)"}, {"type": "lean", "content": "1535", "hidden": false}, {"type": "lean", "content": "1536", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1537", "hidden": true}, {"type": "lean", "content": "1538", "hidden": true}, {"type": "text", "content": "1539"}, {"type": "text", "content": "1540"}, {"type": "lean", "content": "1541", "hidden": true}, {"type": "lean", "content": "1542", "hidden": false}, {"type": "theorem", "text": "1543", "lean": "theorem not_bounded_above : \u00ac(bounded_above T) :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 47, "textBefore": "import reals.not_upper_bound -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 7: Sets without upper bounds\n-/\n\n/-\n## Task\n\nLet $T$ be the set of natural numbers $x$ such that $x = 3m$, for some natural number $m$.\nProve that $T$ has no upper bound. That is, prove that $T$ is not bounded above.\n\nThis *challenging* level tests your understanding of logic and of the definitions seen so far.\n-/\n\nnamespace no_upb -- hide\n\ndef T := {x : \u2115 | \u2203 (m : \u2115), x = 3 * m}\n\n/- Theorem : no-side-bar\nLet $T$ be the set of natural numbers $x$ such that $x = 3m$, for some natural number $m$.\nThen $T$ is not bounded above\n-/\ntheorem not_bounded_above : \u00ac(bounded_above T) :=\nbegin\n", "proof": "  show \u00ac(\u2203 (u : \u2115), is_upper_bound T u),\n  show \u00ac(\u2203 (u : \u2115), \u2200 (x : \u2115), x \u2208 T \u2192 x \u2264 u),\n  push_neg,\n  show \u2200 (u : \u2115), \u2203 (x : \u2115), (\u2203 (m : \u2115), x = 3 * m) \u2227 u < x,\n  assume u : \u2115,\n  use 3* (u + 1),\n  use u + 1,\n  show u < 3 * (u + 1), linarith,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend no_upb -- hide\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 29, "name": "not_bounded_above", "statement": "\u00ac(bounded_above T)"}, {"type": "lean", "content": "1544", "hidden": true}, {"type": "lean", "content": "1545", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "1546", "hidden": true}, {"type": "lean", "content": "1547", "hidden": true}, {"type": "text", "content": "1548"}, {"type": "lean", "content": "1549", "hidden": true}, {"type": "text", "content": "1550"}, {"type": "lean", "content": "1551", "hidden": false}, {"type": "text", "content": "1552"}, {"type": "text", "content": "1553"}, {"type": "lean", "content": "1554", "hidden": true}, {"type": "lean", "content": "1555", "hidden": false}, {"type": "lean", "content": "1556", "hidden": true}, {"type": "lean", "content": "1557", "hidden": false}, {"type": "lean", "content": "1558", "hidden": true}, {"type": "text", "content": "1559"}, {"type": "lean", "content": "1560", "hidden": true}, {"type": "lean", "content": "1561", "hidden": false}, {"type": "theorem", "text": "1562", "lean": "theorem no_smaller_2_T : no_smaller_upper_bound T 2 :=\n", "sideBar": false, "firstProofLineNumber": 94, "lastProofLineNumber": 114, "textBefore": "import reals.has_no_upper_bound -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 8: No smaller upper bound\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\n\n/-\nLet $S$ be a set on an preordered type $X$. Let $u : X$. We can ask the question:\n\"is every upper bound of $S$ no smaller than $u$?\"\n\nThat is, is it the case that for every $t : X$, if $t$ is an upper bound of $S$,\nthen $u \\le t$?\n-/\n\ndef no_smaller_upper_bound (S : set X) (u : X) :=\n\u2200 (t : X), (is_upper_bound S t) \u2192 u \u2264 t\n\n/-\nAs an example, we'll show that for the set $S$ of rational numbers $x$ for which\n$(x + 2) ^ 3 \\le 3000$, there is no smaller upper bound than $12$.\n\n**Proof**: We must show that for all $t : \\mathbb Q$, if $t$ is an\nupper bound of $S$, then $12 \\le t$.\n\nAssume $t : \\mathbb Q$. Assume that $t$ is an upper bound of $S$.\n\nThat is, we have assumed for all $x : \\mathbb Q$, if $x \\in S$, then $x \\le t$.\n\nWe must show $12 \\le t$.\n\nSuppose, for a contradiction, that $\\neg(12 \\le t)$. We must prove $\\bot$.\n\nObserve (by a numerical calculation) that $12 \\in S$, as $(12 + 2)^3 = 2744 \\le 3000$.\n\nBy the assumption that $t$ is an upper bound of $S$, we deduce $12 \\le t$.\n\nThis contradicts the assumption that $\\neg(12 \\le t)$. \u220e\n-/\n\n/-\nHere is the proof in Lean.\n-/\n\nnamespace no_smaller -- hide\n\ndef S := {x : \u211a | (x + 2) ^ 3 < 3000}\n\n-- hide\n\nexample : no_smaller_upper_bound S 12 :=\nbegin\n  show \u2200 (t : \u211a), (is_upper_bound S t) \u2192 12 \u2264 t,\n  assume t : \u211a,\n  assume h : is_upper_bound S t,\n  given h : \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 t,\n  show 12 \u2264 t, by_contra k, -- Assume, for a contradction,\n  given k : \u00ac(12 \u2264 t),      -- that \u00ac(12 \u2264 t)\n  have h\u2082 : (12 : \u211a) \u2208 S,\n  { show ((12 : \u211a) + 2) ^ 3 < 3000, norm_num, },\n  have h\u2083 : (12 : \u211a) \u2264 t, from h 12 h\u2082,\n  show false, linarith,\nend\n\n\nend no_smaller -- hide\n\n/-\n## Task\n\nLet $T$ be the set of rational numbers $x$ such that $3 < x$ and $x < 10$. Show that\n$T$ has no smaller upper bound than $2$.\n\n**Remember to use type annotations** when dealing with numerals.\n\nTo prove numeric inequalities, **use the `norm_num` tactic**.\n-/\n\nnamespace no_smaller -- hide\n\ndef T := {x : \u211a | 3 < x \u2227 x < 10}\n\n/- Theorem : no-side-bar\nLet $T$ be the above set. Then $T$ has no smaller upper bound than $2$.\n-/\ntheorem no_smaller_2_T : no_smaller_upper_bound T 2 :=\nbegin\n", "proof": "  show \u2200 (t : \u211a), (is_upper_bound T t) \u2192 2 \u2264 t,\n  assume t : \u211a,\n  assume h : is_upper_bound T t,\n  given h : \u2200 (x : \u211a), x \u2208 T \u2192 x \u2264 t,\n  show 2 \u2264 t, by_contra k,\n  given k : \u00ac(2 \u2264 t),\n  have h\u2082 : (4 : \u211a) \u2208 T,\n  { show (3 : \u211a) < 4 \u2227 (4 : \u211a) < 10, norm_num, },\n  have h\u2083 : 4 \u2264 t, from h 4 h\u2082,\n  show false, linarith,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend no_smaller -- hide\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 93, "name": "no_smaller_2_T", "statement": "no_smaller_upper_bound T 2"}, {"type": "lean", "content": "1563", "hidden": true}, {"type": "lean", "content": "1564", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "1565", "hidden": true}, {"type": "lean", "content": "1566", "hidden": true}, {"type": "text", "content": "1567"}, {"type": "lean", "content": "1568", "hidden": true}, {"type": "text", "content": "1569"}, {"type": "lean", "content": "1570", "hidden": false}, {"type": "lean", "content": "1571", "hidden": true}, {"type": "text", "content": "1572"}, {"type": "text", "content": "1573"}, {"type": "lean", "content": "1574", "hidden": false}, {"type": "lean", "content": "1575", "hidden": true}, {"type": "lean", "content": "1576", "hidden": false}, {"type": "lean", "content": "1577", "hidden": true}, {"type": "text", "content": "1578"}, {"type": "lean", "content": "1579", "hidden": false}, {"type": "lean", "content": "1580", "hidden": true}, {"type": "text", "content": "1581"}, {"type": "lean", "content": "1582", "hidden": true}, {"type": "lean", "content": "1583", "hidden": false}, {"type": "theorem", "text": "1584", "lean": "theorem S_has_sup_1 : has_sup S :=\n", "sideBar": false, "firstProofLineNumber": 117, "lastProofLineNumber": 148, "textBefore": "import reals.no_smaller_ub -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 9: Suprema\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\n\n/-\nLet $S$ be a set on an preordered type $X$. For a term $u : X$ to be a *supremum* of $S$\n(also called a *least upper bound* of $S$) is for: $u$ to be an upper bound of $S$ *and*\nfor $S$ to have no smaller upper bound than $u$.\n\nThe word *suprema* is just the plural form of supremum.\n-/\n\ndef is_sup (S : set X) (u : X) := (is_upper_bound S u) \u2227 (no_smaller_upper_bound S u)\n\n\nnamespace sup1 -- hide\n\n/-\n**Theorem**: Let $T := \\\\{x : \\mathbb Q \\mid x < 1 \\\\}$. Then $1$ is a supremum of $T$.\n\n**Proof**: The proof splits into two parts.\n\n1. We show $1$ is an upper bound of $T$.\n   Assume $x : \\mathbb Q$ and that $x \\in T$. We must show $x \\le 1$.\n   But $x \\in T$ means $x < 1$. From this, $x \\le 1$ follows.\n\n2. We show $T$ has no smaller upper bound than $1$.\n  That is, we show for all rational numbers $v$, if $v$ is an upper bound\n  of $T$, then $1 \\le v$.\n  Suppose not, for a contradiction.\n\n  Then we have a rational number $v$ such that $v$ is an upper bound\n  of $T$ and $v < 1$.\n  \n  Write $x := (v + 1)/2$. Then $x$ is a rational number and $v < x < 1$.\n  As $x < 1$, we have $x \\in T$. But $v$ is an upper bound of $T$,\n  whence $x \\le v$. It follows that $v < v$, a contradiction. \u220e\n-/\n\n/-\nThis can be proved in Lean. Below, I use `rcases` to perform recursive\nelimination. If you prefer, you could instead use two applications of `cases`.\n-/\n\ndef T := {x : \u211a | x < 1}\n\n\n-- hide\n\nlemma is_sup_T_1 : is_sup T 1 :=\nbegin\n  split,\n  { show is_upper_bound T 1,\n    show \u2200 (x : \u211a), x < 1 \u2192 x \u2264 1,\n    assume x : \u211a,\n    assume h : x < 1,\n    show x \u2264 1, linarith, },\n  { show no_smaller_upper_bound T 1,\n    show \u2200 (t : \u211a), is_upper_bound T t \u2192 1 \u2264 t, by_contra k,\n    push_neg at k,\n    given k : \u2203(t : \u211a), is_upper_bound T t \u2227 t < 1,\n    rcases k with \u27e8t, h\u2081, h\u2082\u27e9,\n    given h\u2081 : \u2200 (x : \u211a), x < 1 \u2192 x \u2264 t,\n    given h\u2082 : t < 1,\n    have h\u2083 : (t + 1)/2 < 1, linarith,\n    have : t < (t + 1)/2, linarith,\n    have : (t + 1)/2 \u2264 t, from h\u2081 ((t + 1)/2) h\u2083,\n    show false, linarith, },\nend\n\n\nend sup1 -- hide\n\n/-\nOften, we are interested in *whether* a set has a supremum.\nWe define the predicate `has_sup` so that `has_sup S` is the\nproposition `\u2203 (u : X), is_sup S u`.\n-/\n\ndef has_sup (S : set X) := \u2203 (u : X), is_sup S u\n\n-- hide\n\n\n\n/-\n## Task\n\nLet $S$ be the set of rational numbers $x$ such that $x \u2264 1$.\nThen $S$ has a supremum.\n\nThis proof should be easier than that of the theorem above.\n\n**Remember to use type annotations** when dealing with numerals.\n\nTo prove numeric inequalities, **use the `norm_num` tactic**.\n-/\n\nnamespace sup1 -- hide\n\ndef S := {x : \u211a | x \u2264 1}\n\n/- Theorem : no-side-bar\nThe set $S$ above has a supremum.\n-/\ntheorem S_has_sup_1 : has_sup S :=\nbegin\n", "proof": "  use 1,\n  split,\n  { -- We prove 1 is an upper bound of S\n    show is_upper_bound S 1,\n    show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 1,\n    assume x : \u211a,\n    assume h : x \u2264 1,\n    show x \u2264 1, from h, },\n  { -- We prove $S$ has no smaller upper bound than 1.\n    show no_smaller_upper_bound S 1,\n    show \u2200 (t : \u211a), is_upper_bound S t \u2192 1 \u2264 t,\n    assume t : \u211a,\n    assume h : is_upper_bound S t,\n    given h : \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 t,\n    show 1 \u2264 t, by_contra k,\n    given k : \u00ac(1 \u2264 t),\n    have h\u2082 : (1 : \u211a) \u2264 1, norm_num,\n    have h\u2083 : (1 : \u211a) \u2264 t, from h 1 h\u2082,\n    show false, linarith, }\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend sup1 -- hide\n\nend exlean -- hide", "height": 32, "editorText": "sorry", "lineOffset": 116, "name": "S_has_sup_1", "statement": "has_sup S"}, {"type": "lean", "content": "1585", "hidden": true}, {"type": "lean", "content": "1586", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1587", "hidden": true}, {"type": "lean", "content": "1588", "hidden": true}, {"type": "text", "content": "1589"}, {"type": "lean", "content": "1590", "hidden": true}, {"type": "text", "content": "1591"}, {"type": "axiom", "content": "1592", "name": "le_antisymm (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) :", "sideBar": true}, {"type": "lean", "content": "1593", "hidden": false}, {"type": "text", "content": "1594"}, {"type": "lean", "content": "1595", "hidden": false}, {"type": "text", "content": "1596"}, {"type": "hint", "content": "1597", "title": "1598"}, {"type": "lean", "content": "1599", "hidden": true}, {"type": "theorem", "text": "1600", "lean": "theorem sup_unique (h\u2081 : is_sup S u\u2081) (h\u2082 : is_sup S u\u2082) : u\u2081 = u\u2082 :=\n", "sideBar": true, "firstProofLineNumber": 67, "lastProofLineNumber": 84, "textBefore": "import reals.suprema -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 10: Uniqueness of supremum\n-/\n\nvariables {X : Type*} [partial_order X] -- hide\n\n/-\nA *partial order* on a type $X$ is a preorder (a reflexive, transitive relation) that is\nantisymmetric. Recall that for a relation\n$\\le$ to be antisymmetric means that if $a \\le b$ and $b \\le a$, then $a = b$.\n\nHere is how to use antisymmetry in Lean:\n-/\n\n/- Axiom : le_antisymm (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) :\na = b\n-/\n\nexample (a b : X) (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) : a = b :=\nbegin\n  from le_antisymm h\u2081 h\u2082,\nend\n\n/-\nIt can be clearer to apply antisymmetry *backward*. That is, to prove $a = b$, it\nsuffices to prove $a \\le b$ and to prove $b \\le a$.\n-/\n\nexample (a b : X) (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) : a = b :=\nbegin\n  apply le_antisymm,\n  { show a \u2264 b, from h\u2081, },\n  { show b \u2264 a, from h\u2082, },\nend\n\n/-\n## Task\n\nLet $S$ be a set on a partially ordered type $X$. Suppose that $u_1$ and $u_2$ are suprema of $S$.\nProve that $u_1 = u_2$.\n-/\n\n/- Hint : A proof template\nI suggest a backward application of antisymmetry.\n```\n  apply le_antisymm,\n  { show u\u2081 \u2264 u\u2082,\n    sorry, },\n  { show u\u2082 \u2264 u\u2081,\n    sorry, }\n```\n-/\n\nvariables {S : set X} {u\u2081 u\u2082 : X} -- hide\n\n/- Theorem : \nIf a set $S$ has suprema $u_1$ and $u_2$, then $u_1 = u_2$.\n-/\ntheorem sup_unique (h\u2081 : is_sup S u\u2081) (h\u2082 : is_sup S u\u2082) : u\u2081 = u\u2082 :=\nbegin\n", "proof": "  cases h\u2081 with k\u2081 p\u2081,\n  cases h\u2082 with k\u2082 p\u2082,\n  apply le_antisymm,\n  { show u\u2081 \u2264 u\u2082,\n    from p\u2081 _ k\u2082, },\n  { show u\u2082 \u2264 u\u2081,\n    from p\u2082 _ k\u2081, }\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 66, "name": "sup_unique", "statement": "(h\u2081 : is_sup S u\u2081) (h\u2082 : is_sup S u\u2082) : u\u2081 = u\u2082"}, {"type": "lean", "content": "1601", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "1602", "hidden": true}, {"type": "lean", "content": "1603", "hidden": true}, {"type": "text", "content": "1604"}, {"type": "lean", "content": "1605", "hidden": true}, {"type": "text", "content": "1606"}, {"type": "text", "content": "1607"}, {"type": "text", "content": "1608"}, {"type": "lean", "content": "1609", "hidden": false}, {"type": "lean", "content": "1610", "hidden": true}, {"type": "lean", "content": "1611", "hidden": false}, {"type": "axiom", "content": "1612", "name": "le_max_left (a b : X) :", "sideBar": true}, {"type": "axiom", "content": "1613", "name": "le_max_right (a b : X) :", "sideBar": true}, {"type": "text", "content": "1614"}, {"type": "lean", "content": "1615", "hidden": false}, {"type": "text", "content": "1616"}, {"type": "theorem", "text": "1617", "lean": "lemma max_le_max_max_left (a b c : X) : max a b \u2264 max (max a b) c :=\n", "sideBar": false, "firstProofLineNumber": 90, "lastProofLineNumber": 94, "textBefore": "import reals.sup_uniqueness -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 11: The maximum of two numbers\n\nWe take a brief pause from our discussion of suprema\nto study the maximum function. This will be highly relevant for our future study in this\nworld and the next.\n-/\n\nvariables {X : Type*} [linear_order X] -- hide\n\n/-\nLet $X$ be a type with a partial order. Suppose, additionally, that for all $a, b : X$,\nthat either $a \\le b$ or $b \\le a$. An order relation with these properties is said to be\na *linear order*.\n\nThe *maximum* function on a linear order is defined so that\n$$\n\\max(a, b) :=\n\\begin{cases}\na, & \\text{if } b \\le a, \\\\\\\\\nb, & \\text{otherwise}.\n\\end{cases}\n$$\n-/\n\n\n/-\nFrom this definition, we easily extract a theorem with two parts.\n\n**Theorem**: For all $a$ and $b$ of a linear ordered type $X$\n\n* $a \\le \\max(a,b)$ and\n* $b \\le \\max(a,b)$.\n-/\n\n/-\nIn Lean, these theorems are called `le_max_left` and `le_max_right`, respectively.\n-/\n\nexample (a b : X) : a \u2264 max a b :=\nbegin\n  from le_max_left a b,\nend\n\n-- hide\n\nexample (a b : X) : b \u2264 max a b :=\nbegin\n  from le_max_right a b\nend\n\n/- Axiom : le_max_left (a b : X) :\na \u2264 max a b\n-/\n\n/- Axiom : le_max_right (a b : X) :\nb \u2264 max a b\n-/\n\n/-\nIf you invoke `le_max_left` with the `apply` tactic, then Lean will create new goals\nfor the inputs and, where possible, close the goals automatically.\n-/\n\nexample (a b : X) : a \u2264 max a b :=\nbegin\n  apply le_max_left,\nend\n\n\n/-\n## Task\nLet $a$, $b$, $c$ be terms of a linear ordered type $X$. Show that\n$\\max(a,b) \\le \\max(\\max(a,b),c)$.\n-/\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$ be terms of a linear ordered type $X$. Then\n$\\max(a,b) \\le \\max(\\max(a,b),c)$.\n-/\nlemma max_le_max_max_left (a b c : X) : max a b \u2264 max (max a b) c :=\nbegin\n", "proof": "  apply le_max_left,\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 5, "editorText": "sorry", "lineOffset": 89, "name": "max_le_max_max_left", "statement": "(a b c : X) : max a b \u2264 max (max a b) c"}, {"type": "lean", "content": "1618", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "1619", "hidden": true}, {"type": "lean", "content": "1620", "hidden": true}, {"type": "text", "content": "1621"}, {"type": "lean", "content": "1622", "hidden": true}, {"type": "axiom", "content": "1623", "name": "max_le {a b c : X}", "sideBar": true}, {"type": "lean", "content": "1624", "hidden": false}, {"type": "text", "content": "1625"}, {"type": "lean", "content": "1626", "hidden": false}, {"type": "text", "content": "1627"}, {"type": "text", "content": "1628"}, {"type": "axiom", "content": "1629", "name": "max_le_max_left (a b c : X) :", "sideBar": true}, {"type": "lean", "content": "1630", "hidden": false}, {"type": "text", "content": "1631"}, {"type": "theorem", "text": "1632", "lean": "theorem max_le_max_swap (a b : X) : max a b \u2264 max b a :=\n", "sideBar": true, "firstProofLineNumber": 96, "lastProofLineNumber": 105, "textBefore": "import reals.maximum -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 12: Proving a maximum is at most another number\n\nIn the last level, we saw $a \\le \\max(a,b)$ and $b \\le \\max(a,b)$,\nproving a maximum of two numbers is at least the first number and is at least the second number.\n\nLikewise, one can show that if $a \\le c$ and $b \\le c$, then $\\max(a,b) \\le c$, proving that\na maximum of two numbers is at most a third number if each of the two numbers is at most the\nthird number.\n\nIn Lean, this theorem is called `max_le`.\n-/\n\nvariables {X : Type*} [linear_order X] -- hide\n\n\n/- Axiom : max_le {a b c : X}\n(h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : nax a b  \u2264 c\n-/\n\nexample (a b c : X) (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c :=\nbegin\n  from max_le h\u2081 h\u2082,\nend\n\n/-\nIt's often most convenient to use this theorem backward. That is, to replace the goal\nof proving `max a b \u2264 c` with two goals: one of proving `a \u2264 c` and the other of proving\n`b \u2264 c`.\n\nWe show this below in Lean.\n-/\n\nexample (a b c : X) (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c :=\nbegin\n  apply max_le,\n  { show a \u2264 c, from h\u2081},\n  { show b \u2264 c, from h\u2082}\nend\n\n\n/-\n**Theorem**: Let $a$, $b$, $c$ be terms of a linear ordered type $X$.\nThen $\\max(a, b) \\le \\max(a, \\max(b,c))$.\n\n**Proof**:\nIt suffices to prove $a \\le \\max(a, \\max(b,c))$ and to prove $b \\le \\max(a, \\max(b,c))$.\n\n1. We show $a \\le \\max(a, \\max(b,c))$ by the fact that a maximum of two numbers is at least\nthe first number.\n\n2. We show $b \\le \\max(a, \\max(b,c))$ as follows. Note that\n\\begin{align}\nb &\\le \\max(b,c) & & \\text{[a maximum of two numbers is at least the first number]}\\\\\\\\\n&\\le \\max(a,\\max(b,c)). & & \\text{[a maximum of two numbers is at least the second number]}\n\\end{align}\n\u220e\n-/\n\n/-\nThis proof can be written in Lean. Note the use of proof by calculation.\n-/\n\n/- Axiom : max_le_max_left (a b c : X) :\nmax a b \u2264 max a (max b c)\n-/\n\nlemma max_le_max_left (a b c : X) : max a b \u2264 max a (max b c) :=\nbegin\n  apply max_le,\n  { show a \u2264 max a (max b c), apply le_max_left,  },\n  { show b \u2264 max a (max b c), \n    calc\n    b \u2264 max b c           : by apply le_max_left\n    ... \u2264 max a (max b c) : by apply le_max_right, },\nend\n\n/-\n## Task\nProve that $\\max(a,b) \\le \\max(b,a)$. You will need to use `max_le`, `le_max_right`, and\n`le_max_left`.\n-/\n\n/- Theorem :\n$\\max(a,b) \\le \\max(b,a)$.\n-/\ntheorem max_le_max_swap (a b : X) : max a b \u2264 max b a :=\nbegin\n", "proof": "  apply max_le,\n  { show a \u2264 max b a, apply le_max_right, },\n  { show b \u2264 max b a, apply le_max_left, },\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "sorry", "lineOffset": 95, "name": "max_le_max_swap", "statement": "(a b : X) : max a b \u2264 max b a"}, {"type": "lean", "content": "1633", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "1634", "hidden": true}, {"type": "lean", "content": "1635", "hidden": true}, {"type": "text", "content": "1636"}, {"type": "lean", "content": "1637", "hidden": true}, {"type": "text", "content": "1638"}, {"type": "text", "content": "1639"}, {"type": "axiom", "content": "1640", "name": "max_eq_max_swap (a b : X) :", "sideBar": true}, {"type": "lean", "content": "1641", "hidden": false}, {"type": "text", "content": "1642"}, {"type": "theorem", "text": "1643", "lean": "theorem max_assoc (a b c : X) : max (max a b) c = max a (max b c) :=\n", "sideBar": true, "firstProofLineNumber": 48, "lastProofLineNumber": 85, "textBefore": "import reals.max_le -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 13: Associativity of maximum\n-/\n\nvariables {X : Type*} [linear_order X] -- hide\n\n/-\nIn this challenging level, you will prove the associativity of maximum. That is, you will prove\n$$\n\\max(\\max(a,b), c) = \\max(a,\\max(b,c)).\n$$\n-/\n\n/-\nAs another example (which may help in your proof), we extract a result from the theorem you\nproved in the previous level.\n-/\n\n/- Axiom : max_eq_max_swap (a b : X) :\nmax a b = max b a\n-/\nlemma max_eq_max_swap (a b : X) : max a b = max b a :=\nbegin\n  apply le_antisymm,\n  { show max a b \u2264 max b a, apply max_le_max_swap, },\n  { show max b a \u2264 max a b, apply max_le_max_swap, },\nend\n\n/-\n## Task\nProve that $\\max(\\max(a,b), c) = \\max(a,\\max(b,c))$, for all $a$, $b$, $c$ terms in a linear\nordered type $X$. You will benefit from understanding the theorems and reading the examples\nin the previous two levels.\n-/\n\n/- Theorem :\n$\\max(\\max(a,b), c) = \\max(a,\\max(b,c))$\n-/\ntheorem max_assoc (a b c : X) : max (max a b) c = max a (max b c) :=\nbegin\n", "proof": "  apply le_antisymm,\n  { show max (max a b) c \u2264 max a (max b c),\n    apply max_le,\n    { show max a b \u2264 max a (max b c),\n      apply max_le_max_left, },\n    { show c \u2264 max a (max b c),\n      calc\n      c \u2264 max b c           : by apply le_max_right\n      ... \u2264 max a (max b c) : by apply le_max_right, }, },\n  { show max a (max b c) \u2264 max (max a b) c,\n    apply max_le,\n    { show a \u2264 max (max a b) c,\n      calc\n      a \u2264 max a b           : by apply le_max_left\n      ... \u2264 max (max a b) c : by apply le_max_left, },\n    { show max b c \u2264 max (max a b) c,\n      calc\n      max b c = max c b       : by rw max_eq_max_swap\n      ... \u2264 max c (max b a)   : by apply max_le_max_left\n      ... = max c (max a b)   : by rw max_eq_max_swap b a\n      ... = max (max a b) c   : by rw max_eq_max_swap}, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 38, "editorText": "sorry", "lineOffset": 47, "name": "max_assoc", "statement": "(a b c : X) : max (max a b) c = max a (max b c)"}, {"type": "lean", "content": "1644", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1645", "hidden": true}, {"type": "lean", "content": "1646", "hidden": true}, {"type": "text", "content": "1647"}, {"type": "lean", "content": "1648", "hidden": true}, {"type": "text", "content": "1649"}, {"type": "text", "content": "1650"}, {"type": "lean", "content": "1651", "hidden": true}, {"type": "text", "content": "1652"}, {"type": "lean", "content": "1653", "hidden": false}, {"type": "text", "content": "1654"}, {"type": "lean", "content": "1655", "hidden": false}, {"type": "text", "content": "1656"}, {"type": "theorem", "text": "1657", "lean": "theorem no_upper_bound : \u00ac(bounded_above {x : \u211a | (x + 1) ^ 2 > 12}) :=\n", "sideBar": false, "firstProofLineNumber": 88, "lastProofLineNumber": 113, "textBefore": "import reals.max_le -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 14: Sets without an upper bound\n-/\n\nvariables {X : Type*} [linear_order X] -- hide\n\n/-\nThe maximum function can be used profitably to show that a given set has no upper bound.\n\n**Theorem**: Let $S$ be the set of rational numbers $x$ such that $x^2 > 1$. Then\n$S$ is not bounded above.\n\n**Proof**: Suppose, for a contradiction, that $S$ has an upper bound. Let $u$ be this\nupper bound. Let $x := \\max(2,u + 1)$.\nBy properties of maximum, we have $2 \\le x$ and $u + 1 \\le x$. From these, one can\nshow $x \\in S$, whence $x \\le u$. But this contradicts $u + 1 \\le x$. \u220e\n-/\n\n/-\nWe give this proof below in Lean. The only tricky part of the Lean translation is deducing $x ^ 2 > 1$\nfrom $2 \\le x$. For this, we use the result `sq_le_sq_of_nonneg_of_le`\nthis proves `a ^ 2 \u2264 b ^ 2` given `a \u2264 b` and `0 \u2264 a`\n-/\n\n-- begin hide\n/- Axiom : sq_le_sq_of_nonneg_of_le (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) :\na ^ 2 \u2264 b ^ 2 \n-/\n\nlemma sq_le_sq_of_nonneg_of_le {R : Type*} {a b : R} [linear_ordered_ring R] \n(h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) : a ^ 2 \u2264 b ^ 2 :=\nsq_le_sq' (le_trans (neg_le_neg h\u2081) (le_trans (neg_nonpos.mpr h\u2082) h\u2082 )) h\u2081\n-- end hide\n\n/-\nHere is a protypical application of the result.\n-/\n\nexample (a b : \u211a) (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) : a ^ 2 \u2264 b ^ 2 :=\nbegin\n  apply sq_le_sq_of_nonneg_of_le,\n  { show a \u2264 b, from h\u2081 },\n  { show 0 \u2264 a, from h\u2082 },\nend\n\n/-\nWith this in hand, we move on to our Lean proof.\n-/\n\nexample : \u00ac(bounded_above {x : \u211a | x ^ 2 > 1}) :=\nbegin\n  let S := {x : \u211a | x ^ 2 > 1},\n  assume h : bounded_above S,\n  given h : \u2203 (u : \u211a), is_upper_bound S u,\n  rcases h with \u27e8u, h\u2082 : is_upper_bound S u\u27e9,\n  let x := max 2 (u + 1),\n  have h\u2083 : 2 \u2264 x, apply le_max_left,\n  have h\u2084 : u + 1 \u2264 x, apply le_max_right,\n  have h\u2085 : x  ^ 2 \u2265 2 ^ 2,\n  { apply sq_le_sq_of_nonneg_of_le,\n    { show 2 \u2264 x, linarith, },\n    { show (0 : \u211a) \u2264 2, linarith }, },\n  have h\u2086 : x \u2208 S,\n  { show x ^ 2 > 1, linarith, },\n  have h\u2086 : x \u2264 u, from h\u2082 _ h\u2086,\n  show false, linarith,\nend\n\n/-\n## Task\nLet $S$ be the set of rational numbers $x$ for which $(x + 1)^2 > 12$.\nBy adapting the proof above, show that $S$ has no upper bound.\n-/\n\n/- Theorem : no-side-bar\nLet $S$ be the set of rational numbers $x$ for which $(x + 1)^2 > 12$.\nThen $S$ is not bounded above.\n-/\ntheorem no_upper_bound : \u00ac(bounded_above {x : \u211a | (x + 1) ^ 2 > 12}) :=\nbegin\n", "proof": "  let S := {x : \u211a | (x + 1) ^ 2 > 12},\n  assume h : bounded_above S,\n  given h : \u2203 (u : \u211a), is_upper_bound S u,\n  rcases h with \u27e8u, h\u2082 : is_upper_bound S u\u27e9,\n  let x := max 3 (u + 1),\n  have h\u2083 : 3 \u2264 x, apply le_max_left,\n  have h\u2084 : u + 1 \u2264 x, apply le_max_right,\n  have h\u2085 : (x + 1)^ 2 \u2265 4 ^ 2,\n  { apply sq_le_sq_of_nonneg_of_le,\n    { show 4 \u2264 x + 1, linarith },\n    { show (0 : \u211a) \u2264 4, linarith }, },\n  have h\u2086 : x \u2208 S,\n  { show (x + 1) ^ 2 > 12, linarith, },\n  have h\u2086 : x \u2264 u, from h\u2082 _ h\u2086,\n  show false, linarith,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 26, "editorText": "sorry", "lineOffset": 87, "name": "no_upper_bound", "statement": "\u00ac(bounded_above {x : \u211a | (x + 1) ^ 2 > 12})"}, {"type": "lean", "content": "1658", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1659", "hidden": true}, {"type": "lean", "content": "1660", "hidden": true}, {"type": "text", "content": "1661"}, {"type": "lean", "content": "1662", "hidden": true}, {"type": "text", "content": "1663"}, {"type": "hint", "content": "1664", "title": "1665"}, {"type": "hint", "content": "1666", "title": "1667"}, {"type": "lean", "content": "1668", "hidden": true}, {"type": "theorem", "text": "1669", "lean": "theorem sup_union_eq_max_sup (h\u2081 : is_sup S u) (h\u2082 : is_sup T v) (h\u2083 : is_sup (S \u222a T) w) :\nw = max u v :=\n", "sideBar": true, "firstProofLineNumber": 52, "lastProofLineNumber": 120, "textBefore": "import reals.max_assoc -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 15: The supremum of a union\n-/\n\nvariables {X : Type*} [linear_order X] -- hide\n\n\n/-\n## Task\nIn this challenging level, your task is to show that the supremum of a\nunion of two sets is the maximum of their suprema.\n-/\n\n/- Hint : A proof template\n\nStart by using uniqueness of supremum. This leaves you with the goal of proving that\n$\\max(u,v)$ is a supremum of $S \\cup T$. That is, to prove\n$\\max(u,v)$ is an upper bound of $S \\cup T$ and that $S\\cup T$ has no smaller upper bound\nthan $\\max(u,v)$.\n```\n  apply sup_unique h\u2083,\n  show is_sup (S \u222a T) (max u v),\n  split,\n  { show is_upper_bound (S \u222a T) (max u v),\n    sorry, },\n  { show no_smaller_upper_bound (S \u222a T) (max u v),\n    sorry, },\n```\n-/\n\n/- Hint : Useful results on sets\nRemember the results `subset_union_left` and `subset_union_right` from \nthe Sets world. These show `S \u2286 S \u222a T` and `T \u2286 S \u222a T`, respectively.\n-/\n\n\n\nvariables {S T : set X} {u v w : X} -- hide\n\n/- Theorem : \nLet $S$ and $T$ be sets with suprema. Then $\\sup(S \\cup T) = \\max(\\sup(S ), \\sup (T))$\n-/\ntheorem sup_union_eq_max_sup (h\u2081 : is_sup S u) (h\u2082 : is_sup T v) (h\u2083 : is_sup (S \u222a T) w) :\nw = max u v :=\nbegin\n", "proof": "  apply sup_unique h\u2083,\n  show is_sup (S \u222a T) (max u v),\n  rcases h\u2081 with \u27e8k\u2081 : is_upper_bound S u, p\u2081 : no_smaller_upper_bound S u\u27e9,\n  rcases h\u2082 with \u27e8k\u2082 : is_upper_bound T v, p\u2082 : no_smaller_upper_bound T v\u27e9,\n  rcases h\u2083 with \u27e8k\u2083 : is_upper_bound (S \u222a T) w, p\u2083 : no_smaller_upper_bound (S \u222a T) w\u27e9,\n  split,\n  { show is_upper_bound (S \u222a T) (max u v),\n    show \u2200 (x : X), x \u2208 S \u222a T \u2192 x \u2264 max u v,\n    assume x : X,\n    assume h : x \u2208 S \u222a T,\n    cases h with hs ht,\n    { given hs : x \u2208 S,\n      show x \u2264 max u v,\n      calc\n      x \u2264 u         : k\u2081 _ hs\n      ... \u2264 max u v : le_max_left _ _, },\n    { given ht : x \u2208 T,\n      show x \u2264 max u v,\n      calc\n      x \u2264 v         : k\u2082 _ ht\n      ... \u2264 max u v : le_max_right _ _, } },\n  { show no_smaller_upper_bound (S \u222a T) (max u v),\n    assume x : X,\n    assume h : is_upper_bound (S \u222a T) x,\n    apply max_le,\n    { show u \u2264 x,\n      have h\u2084 : is_upper_bound S w,\n      { apply is_upper_bound_of_is_upper_bound_of_subset,\n        { show S \u2286 S \u222a T, from subset_union_left, },\n        { show is_upper_bound (S \u222a T) w, from k\u2083, }, },\n      calc\n      u \u2264 w   : p\u2081 _ h\u2084\n      ... \u2264 x : p\u2083 _ h,  },\n    { show v \u2264 x,\n      have h\u2084 : is_upper_bound T w,\n      { apply is_upper_bound_of_is_upper_bound_of_subset,\n        { show T \u2286 S \u222a T, from subset_union_right, },\n        { show is_upper_bound (S \u222a T) w, from k\u2083, }, },\n      calc\n      v \u2264 w   : p\u2082 _ h\u2084\n      ... \u2264 x : p\u2083 _ h, }, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 69, "editorText": "sorry", "lineOffset": 51, "name": "sup_union_eq_max_sup", "statement": "(h\u2081 : is_sup S u) (h\u2082 : is_sup T v) (h\u2083 : is_sup (S \u222a T) w) :\nw = max u v"}, {"type": "lean", "content": "1670", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1671", "hidden": true}, {"type": "lean", "content": "1672", "hidden": true}, {"type": "text", "content": "1673"}, {"type": "lean", "content": "1674", "hidden": true}, {"type": "text", "content": "1675"}, {"type": "hint", "content": "1676", "title": "1677"}, {"type": "lean", "content": "1678", "hidden": true}, {"type": "lean", "content": "1679", "hidden": false}, {"type": "theorem", "text": "1680", "lean": "theorem T_has_sup_1 : is_sup T 1 :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 93, "textBefore": "import reals.suprema -- hide\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 16: Supremum challenge\n-/\n\nvariables  {X : Type*} [preorder X] -- hide\n\n\n\n/-\n## Task\n\nLet $T$ be the set of rational numbers $x$ such that $x^2 < 1$.\nShow that $1$ is a supremum of $T$.\n\nThis is a somewhat challenging level.\n-/\n\n/- Hint : A helpful result\n\nRecall that if `h\u2081 : a < b` and `h\u2082 : 0 < a`, then\n`sq_lt_sq_of_pos h\u2081 h\u2082` is a proof of `a ^ 2 < b ^ 2`.\n-/\n\nnamespace sup2 -- hide\n\ndef T := {x : \u211a | x ^ 2 < 1}\n\n/- Theorem : no-side-bar\nLet $T$ be the above set. Then 1 is a supremum of $S$.\n-/\ntheorem T_has_sup_1 : is_sup T 1 :=\nbegin\n", "proof": "  split,\n  { show is_upper_bound T 1,\n    show \u2200 (x : \u211a), x \u2208 T \u2192 x \u2264 1,\n    assume s : \u211a,\n    assume h : s \u2208 T ,\n    given h : s ^ 2 < 1,\n    show s \u2264 1,\n    by_contra h\u2082,\n    given h\u2082 : \u00ac(s \u2264 1),\n    have h\u2083 : 1 < s, by linarith,\n    have h\u2084 : (0 : \u211a) < 1, by linarith,\n    have h\u2085 : 1 ^ 2 < s ^2, from sq_lt_sq_of_pos h\u2083 h\u2084,\n    linarith, },\n  { show no_smaller_upper_bound T 1,\n    show \u2200 (v : \u211a), is_upper_bound T v \u2192 (1 : \u211a) \u2264 v,\n    assume v : \u211a,\n    assume h : is_upper_bound T v,\n    given h : \u2200 (x : \u211a), x ^ 2 < 1 \u2192 x \u2264 v,\n    show (1 : \u211a) \u2264 v, by_contra h\u2082,\n    given h\u2082 : \u00ac(1 \u2264 v),\n    have h\u2083 : v < 1, by linarith,\n    have k : 0 < v,\n    { by_contra h\u2084,\n      have h\u2085 : v \u2264 0, by linarith,\n      have h\u2086 : ((1 : \u211a)/2)^2 < 1, by norm_num,\n      have h\u2087 : (1 : \u211a)/2 \u2264 v, from h _ h\u2086,\n      linarith, },\n    have h\u2084 : v < (1 + v)/2, linarith,\n    have h\u2085 : (1 + v) /2 < 1, linarith,\n    have h\u2086 : 0 < (1 + v) /2, linarith,\n    have h\u2087 : ((1 + v)/2) ^ 2 < 1 ^ 2, from sq_lt_sq_of_pos h\u2085 h\u2086,\n    have h\u2088 : (1 + v)/2 \u2264 v, from h _ (by linarith),\n    linarith, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend sup2 -- hide\n\nend exlean -- hide", "height": 55, "editorText": "sorry", "lineOffset": 38, "name": "T_has_sup_1", "statement": "is_sup T 1"}, {"type": "lean", "content": "1681", "hidden": true}, {"type": "lean", "content": "1682", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1683", "hidden": true}, {"type": "lean", "content": "1684", "hidden": true}, {"type": "text", "content": "1685"}, {"type": "lean", "content": "1686", "hidden": true}, {"type": "lean", "content": "1687", "hidden": true}, {"type": "lean", "content": "1688", "hidden": true}, {"type": "text", "content": "1689"}, {"type": "lean", "content": "1690", "hidden": false}, {"type": "axiom", "content": "1691", "name": "completeness (h\u2081 : S.nonempty) (h\u2082 : bounded_above S) :", "sideBar": true}, {"type": "text", "content": "1692"}, {"type": "hint", "content": "1693", "title": "1694"}, {"type": "lean", "content": "1695", "hidden": true}, {"type": "theorem", "text": "1696", "lean": "theorem has_sup_of_subset_of_has_sup_of_nonempty \n(h\u2081 : S.nonempty) (h\u2082 : has_sup T) (h\u2083 : S \u2286 T) :\nhas_sup S :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 80, "textBefore": "import library.real_field tactic.modded tactic.linarith -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 17: Completeness\n-/\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field -- hide\n\n/-\nThe type of real numbers, $\\mathbb R$ has all the 'algebraic' properties of the \ntype $\\mathbb Q$ of rational numbers (for example, associativity of addition,\nmultiplicative inverses for non-zero numbers, etc.). It also shared the\norder properties of $\\mathbb Q$ (for example if $a < b$ and $c < d$< then $a + b < c + d$).\n\nAdditionally, the type $\\mathbb R$ has the *completeness property*: every non-empty set of real\nnumbers that has an upper bound has a supremum.\n-/\n\nexample (S : set \u211d) (h\u2081 : S.nonempty) (h\u2082 : bounded_above S) : has_sup S :=\nbegin\n  from completeness h\u2081 h\u2082,\nend\n\n/- Axiom : completeness (h\u2081 : S.nonempty) (h\u2082 : bounded_above S) :\nhas_sup S\n-/\n\n/-\n## Task\n\nSuppose $S$ and $T$ are sets of real numbers. Suppose $S$ is non-empty,\nthat $T$ has a supremum, and that $S \\subseteq T$. Show that $S$ has\na supremum.\n-/\n\n/- Hint : A useful result\nRecall the result `is_upper_bound_of_is_upper_bound_of_subset`\nfrom a previous level.\n-/\n\nvariables {S T : set \u211d} -- hide\n\n/- Theorem : no-side-bar\nSuppose $S$ and $T$ are sets of real numbers. Suppose $S$ is non-empty,\nthat $T$ has a supremum, and that $S \\subseteq T$. Then $S$ has\na supremum.\n-/\ntheorem has_sup_of_subset_of_has_sup_of_nonempty \n(h\u2081 : S.nonempty) (h\u2082 : has_sup T) (h\u2083 : S \u2286 T) :\nhas_sup S :=\nbegin\n", "proof": "  given h\u2082 : \u2203 (u : \u211d), is_sup T u,\n  given h\u2082 : \u2203 (u : \u211d), is_upper_bound T u \u2227 no_smaller_upper_bound T u,\n  rcases h\u2082 with \u27e8u, k\u2081, k\u2082\u27e9,\n  given k\u2081 : is_upper_bound T u,\n  given k\u2082 : no_smaller_upper_bound T u,\n  have h\u2083 : is_upper_bound S u,\n  { from is_upper_bound_of_is_upper_bound_of_subset u h\u2083 k\u2081,  },\n  have h\u2084 : bounded_above S, from Exists.intro u h\u2083,\n  from completeness h\u2081 h\u2084,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 60, "name": "has_sup_of_subset_of_has_sup_of_nonempty", "statement": "(h\u2081 : S.nonempty) (h\u2082 : has_sup T) (h\u2083 : S \u2286 T) :\nhas_sup S"}, {"type": "lean", "content": "1697", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1698", "hidden": true}, {"type": "lean", "content": "1699", "hidden": true}, {"type": "text", "content": "1700"}, {"type": "lean", "content": "1701", "hidden": true}, {"type": "lean", "content": "1702", "hidden": true}, {"type": "lean", "content": "1703", "hidden": true}, {"type": "text", "content": "1704"}, {"type": "theorem", "text": "1705", "lean": "theorem archimedean (x : \u211d) : \u2203 (n : \u2115), x < n :=\n", "sideBar": true, "firstProofLineNumber": 60, "firstProofHintLineNumber": 99, "lastProofHintLineNumber": 118, "lastProofLineNumber": 124, "textBefore": "import reals.completeness -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 18: The Archimedean property\n\nThe Archimedean property of $\\mathbb R$ asserts that for every real\nnumber $x$, there exists a natural number $n$ such that $x < n$.\n\nThis can be proved using the completeness property. Here is a sketch proof.\n\n**Proof sketch**: Let $x$ be a real number. We want to prove that\nthere exists a natural number $n$ such that $x < n$. Suppose, for a\ncontradiction, that for all natural numbers $n$, we have $n \\le x$.\nLet $S$ be the set of all real numbers $n$ such that $n$ is a natural number\nand $n \\le x$. Then (by our assumption), every natural number is in $S$.\n\nIn particular, $0 \\in S$, so $S$ is non-empty.\n\nOne can show that $S$ is bounded above (by $x$).\n\nThus, by the completness property of $\\mathbb R$, we deduce that $S$\nhas a supremum. Let $u$ be this supremum.\n\nOne may show that $u - 1$ is an upper bound of $S$. This contradicts\nthe assumption that there is $S$ has no upper bound smaller than $u$. \u220e\n-/\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n\n/-\n## Task\nYour task is to prove the Archimedean property of $\\mathbb R$ using Lean.\nDo this by fleshing out the skeleton proof below.\n\nThe informal proof above glosses over some serious difficulties. One such difficulty is\nthe fact the quantities (such as $n$) play dual roles as natural numbers and as real \nnumbers. This is in evidence in the definition of $S$ above.\n\nIn the skeleton Lean proof, the set $S$ is defined to be the\nset of all real numbers $m$ such that for some natural number $n$, $m = n$ and $n \\le x$.\n-/\n\n\n/- Theorem :\nFor every real\nnumber $x$, there exists a natural number $n$ such that $x < n$.\n-/\ntheorem archimedean (x : \u211d) : \u2203 (n : \u2115), x < n :=\nbegin\n", "proof": "  by_contra k,\n  given k : \u00ac(\u2203 (n : \u2115), x < n),\n  push_neg at k,\n  given k : \u2200 (n : \u2115), (n : \u211d) \u2264 x,\n  let S := {m : \u211d | \u2203 n : \u2115, (m = n) \u2227 (x \u2265 n)},\n  have h\u2081 : (0 : \u211d) \u2208 S,\n  { use 0,\n    split,\n    { show 0 = (0 : \u211d), refl, },\n    { show x \u2265 (0 : \u211d), from k 0, },  },\n  have h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\n  have h\u2083 : bounded_above S,\n  { use x,\n    assume s : \u211d,\n    assume h : s \u2208 S,\n    given h : \u2203 (n : \u2115), s = n \u2227 x \u2265 n,\n    rcases h with \u27e8n, h\u2083, h\u2084\u27e9,\n    linarith, },\n  have h\u2084 : has_sup S, from completeness h\u2082 h\u2083,\n  rcases h\u2084 with \u27e8u, h\u2085, h\u2086\u27e9,\n  given h\u2085 : is_upper_bound S u,\n  given h\u2086 : no_smaller_upper_bound S u,\n  have h\u2087 : is_upper_bound S (u - 1),\n  { assume s : \u211d,\n    assume h : s \u2208 S,\n    given h : \u2203 (n : \u2115), s = n \u2227 x \u2265 n,\n    rcases h with \u27e8n, k\u2081, k\u2082\u27e9,\n    have k\u2083 : (n : \u211d) + 1 \u2208 S,\n    { use n + 1,\n      split,\n      { refl, },\n      { from k (n + 1), }  },\n    have k\u2084 : (n : \u211d) + 1 \u2264 u, from h\u2085 _ k\u2083,\n    linarith, },\n  given h\u2086 : \u2200 (t : \u211d), is_upper_bound S t \u2192 u \u2264 t,\n  have h\u2088 : u \u2264 u - 1, from h\u2086 _ h\u2087,\n  linarith,\n\n/- hint\nby_contra k,\ngiven k : \u00ac(\u2203 (n : \u2115), x < n),\npush_neg at k,\ngiven k : \u2200 (n : \u2115), (n : \u211d) \u2264 x,\nlet S := {m : \u211d | \u2203 n : \u2115, (m = n) \u2227 (x \u2265 n)},\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ use 0,\n  split,\n  { show 0 = (0 : \u211d), refl, },\n  { show x \u2265 (0 : \u211d), sorry, },  },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry },\nhave h\u2084 : has_sup S, sorry,\nrcases h\u2084 with \u27e8u, h\u2085, h\u2086\u27e9,\ngiven h\u2085 : is_upper_bound S u,\ngiven h\u2086 : no_smaller_upper_bound S u,\nhave h\u2087 : is_upper_bound S (u - 1),\n{ sorry },\nsorry,\n-/\n\n\n\n\n", "proof_hint": "by_contra k,\ngiven k : \u00ac(\u2203 (n : \u2115), x < n),\npush_neg at k,\ngiven k : \u2200 (n : \u2115), (n : \u211d) \u2264 x,\nlet S := {m : \u211d | \u2203 n : \u2115, (m = n) \u2227 (x \u2265 n)},\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ use 0,\n  split,\n  { show 0 = (0 : \u211d), refl, },\n  { show x \u2265 (0 : \u211d), sorry, },  },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry },\nhave h\u2084 : has_sup S, sorry,\nrcases h\u2084 with \u27e8u, h\u2085, h\u2086\u27e9,\ngiven h\u2085 : is_upper_bound S u,\ngiven h\u2086 : no_smaller_upper_bound S u,\nhave h\u2087 : is_upper_bound S (u - 1),\n{ sorry },\nsorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 65, "editorText": "by_contra k,\ngiven k : \u00ac(\u2203 (n : \u2115), x < n),\npush_neg at k,\ngiven k : \u2200 (n : \u2115), (n : \u211d) \u2264 x,\nlet S := {m : \u211d | \u2203 n : \u2115, (m = n) \u2227 (x \u2265 n)},\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ use 0,\n  split,\n  { show 0 = (0 : \u211d), refl, },\n  { show x \u2265 (0 : \u211d), sorry, },  },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry },\nhave h\u2084 : has_sup S, sorry,\nrcases h\u2084 with \u27e8u, h\u2085, h\u2086\u27e9,\ngiven h\u2085 : is_upper_bound S u,\ngiven h\u2086 : no_smaller_upper_bound S u,\nhave h\u2087 : is_upper_bound S (u - 1),\n{ sorry },\nsorry,", "lineOffset": 59, "name": "archimedean", "statement": "(x : \u211d) : \u2203 (n : \u2115), x < n"}, {"type": "lean", "content": "1706", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "1707", "hidden": true}, {"type": "lean", "content": "1708", "hidden": true}, {"type": "text", "content": "1709"}, {"type": "text", "content": "1710"}, {"type": "lean", "content": "1711", "hidden": true}, {"type": "lean", "content": "1712", "hidden": true}, {"type": "lean", "content": "1713", "hidden": true}, {"type": "text", "content": "1714"}, {"type": "lean", "content": "1715", "hidden": true}, {"type": "theorem", "text": "1716", "lean": "theorem one_div_lt_of_pos (h : 0 < t) : \u2203 (n : \u2115), (n \u2260 0) \u2227 (1 / (n : \u211d) < t) :=\n", "sideBar": true, "firstProofLineNumber": 56, "firstProofHintLineNumber": 73, "lastProofHintLineNumber": 88, "lastProofLineNumber": 89, "textBefore": "import reals.archimedean -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 19: Arbitrarily small reciprocals of natural numbers\n\nA corollary (simple consequence) of the Archimedean property is that there are arbitrarily\nsmall reciprocals of natural numbers.\n\nThat is, given any real number $\\varepsilon > 0$, there exists a non-zero natural number $n$\nsuch that $1 / n < \\varepsilon$.\n\nThis result is very important for proofs regarding convergence of sequences of real numbers.\n-/\n\n/-\n**Proof outline**: By the completeness property, there exists an integer $n$ such that\n$1/\\varepsilon < n$. We'll show $n\\ne 0$ and $1 / n < \\varepsilon$.\nBy assumption, $\\varepsilon > 0$, so $0 < 1 / \\varepsilon$. But $1 / \\varepsilon < n$, so\n$0 < n$. It follows that $n \\ne 0$.\n\nIt remains to show $1 / n < \\varepsilon$. Equally (as $0 < n$), to show $1 / \\varepsilon < n$, which\nwe have already shown. \u220e\n-/\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n\n\n/-\n## Task\nComplete the Lean proof below. You should only need one line.\n\nThe proof contains  theorems\nyou have not seen before. You need not learn these theorems, but\nyou may wish to investigate their effects via the Lean Infoview\npane in the top-right of this window.\n-/\n\nvariable {t : \u211d} -- hide\n\n/- Theorem :\nFor every positive real number $t$, there exists a positive natural number $n$ such that\n$1/n < t$.\n-/\ntheorem one_div_lt_of_pos (h : 0 < t) : \u2203 (n : \u2115), (n \u2260 0) \u2227 (1 / (n : \u211d) < t) :=\nbegin\n", "proof": "  have h\u2081 : \u2203 (n : \u2115), (1/ t) < n, from archimedean (1/t),\n  rcases h\u2081 with \u27e8n, h\u2082\u27e9,\n  given h\u2082 : 1 / t < n,\n  use n,\n  show (n \u2260 0) \u2227 (1 / (n : \u211d) < t),\n  have h\u2083 : 0 <  1 / t, from one_div_pos.mpr h,\n  have h\u2084 : (0 : \u211d) < n, linarith,\n  split,\n  { show n \u2260 0,\n    assume k\u2081 : n = 0,\n    rw k\u2081 at h\u2084,\n    given h\u2084 : (0 : \u211d) < 0,\n    show false, linarith },\n  { show 1 / (n : \u211d) < t,\n    have h\u2085 : (1 / t < n) \u2192 (1 / (n : \u211d) < t), from (one_div_lt h h\u2084).mp,\n    show 1 / (n : \u211d) < t, from h\u2085 h\u2082, }\n/- hint\nhave h\u2081 : \u2203 (n : \u2115), (1/ t) < n, from sorry,\nrcases h\u2081 with \u27e8n, h\u2082\u27e9,\ngiven h\u2082 : 1 / t < n,\nuse n,\nshow (n \u2260 0) \u2227 (1 / (n : \u211d) < t),\nhave h\u2083 : 0 <  1 / t, from one_div_pos.mpr h,\nhave h\u2084 : (0 : \u211d) < n, linarith,\nsplit,\n{ show n \u2260 0,\n  assume k\u2081 : n = 0,\n  rw k\u2081 at h\u2084,\n  given h\u2084 : (0 : \u211d) < 0,\n  show false, linarith },\n{ show 1 / (n : \u211d) < t,\n  have h\u2085 : (1 / t < n) \u2192 (1 / (n : \u211d) < t), from (one_div_lt h h\u2084).mp,\n  sorry, }\n-/", "proof_hint": "have h\u2081 : \u2203 (n : \u2115), (1/ t) < n, from sorry,\nrcases h\u2081 with \u27e8n, h\u2082\u27e9,\ngiven h\u2082 : 1 / t < n,\nuse n,\nshow (n \u2260 0) \u2227 (1 / (n : \u211d) < t),\nhave h\u2083 : 0 <  1 / t, from one_div_pos.mpr h,\nhave h\u2084 : (0 : \u211d) < n, linarith,\nsplit,\n{ show n \u2260 0,\n  assume k\u2081 : n = 0,\n  rw k\u2081 at h\u2084,\n  given h\u2084 : (0 : \u211d) < 0,\n  show false, linarith },\n{ show 1 / (n : \u211d) < t,\n  have h\u2085 : (1 / t < n) \u2192 (1 / (n : \u211d) < t), from (one_div_lt h h\u2084).mp,\n  sorry, }", "textAfter": "\nend\n\nend exlean -- hide", "height": 34, "editorText": "have h\u2081 : \u2203 (n : \u2115), (1/ t) < n, from sorry,\nrcases h\u2081 with \u27e8n, h\u2082\u27e9,\ngiven h\u2082 : 1 / t < n,\nuse n,\nshow (n \u2260 0) \u2227 (1 / (n : \u211d) < t),\nhave h\u2083 : 0 <  1 / t, from one_div_pos.mpr h,\nhave h\u2084 : (0 : \u211d) < n, linarith,\nsplit,\n{ show n \u2260 0,\n  assume k\u2081 : n = 0,\n  rw k\u2081 at h\u2084,\n  given h\u2084 : (0 : \u211d) < 0,\n  show false, linarith },\n{ show 1 / (n : \u211d) < t,\n  have h\u2085 : (1 / t < n) \u2192 (1 / (n : \u211d) < t), from (one_div_lt h h\u2084).mp,\n  sorry, }", "lineOffset": 55, "name": "one_div_lt_of_pos", "statement": "(h : 0 < t) : \u2203 (n : \u2115), (n \u2260 0) \u2227 (1 / (n : \u211d) < t)"}, {"type": "lean", "content": "1717", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1718", "hidden": true}, {"type": "lean", "content": "1719", "hidden": true}, {"type": "text", "content": "1720"}, {"type": "text", "content": "1721"}, {"type": "lean", "content": "1722", "hidden": true}, {"type": "lean", "content": "1723", "hidden": true}, {"type": "lean", "content": "1724", "hidden": true}, {"type": "text", "content": "1725"}, {"type": "theorem", "text": "1726", "lean": "lemma zero_of_non_neg_of_lt_pos (a : \u211d) (h : 0 \u2264 a) (h\u2082 : \u2200 \u03b5 > 0, a < \u03b5) :\na = 0 :=\n", "sideBar": true, "firstProofLineNumber": 52, "firstProofHintLineNumber": 69, "lastProofHintLineNumber": 83, "lastProofLineNumber": 84, "textBefore": "import reals.small_reciprocals -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 20: An arbitrarily small non-negative number is zero\n\nIn the last level, we showed that for every positive real number $\\varepsilon$,\nthere is a non-zero natural number $n$ such that $1/n < \\varepsilon$.\n\nUsing this result, you will prove that if $a$ is a non-negative real number\nsuch that $a < \\varepsilon$ for every positive real number, then $a = 0$.\n-/\n\n/-\n**Proof outline**:\nWe know $a < 0$ or $a = 0$ or $0 < a$. Consider each case separately.\n1. Suppose $a < 0$, But we've assumed $0 \\le a$. This is a contradiction.\n2. Suppse $a = 0$. This is precisely what we wished to prove.\n3. Suppose $0 < a$. By the theorem from the previous level, we have\na natural number $n$ such that $n \\ne 0$ and $1/n < a$. From this,\nit is possible to derive a contradiction, the remaining details of this\nargument, gentle reader, are left for your amusement. \u220e \n-/\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n\n\n/-\n## Task\nComplete the Lean proof below. The proof contains some tactics and theorems\nyou have not seen before. You need not learn these tactics and theorems but\nyou may wish to investigate their effects via the Lean Infoview\npane in the top-right of this window.\n-/\n\n/- Theorem :\nIf $a$ is a non-negative real number\nsuch that $a < \\varepsilon$ for every positive real number, then $a = 0$.\n-/\nlemma zero_of_non_neg_of_lt_pos (a : \u211d) (h : 0 \u2264 a) (h\u2082 : \u2200 \u03b5 > 0, a < \u03b5) :\na = 0 :=\nbegin\n", "proof": "  have h\u2083 : (a < 0) \u2228 (a = 0) \u2228 (0 < a), from trichotomous a 0,\n  rcases h\u2083 with (h\u2083 | rfl | h\u2083 ),\n  { given h\u2083 : a < 0,\n    linarith, },\n  { from rfl, },\n  { given h\u2083 : 0 < a,\n    clear h,\n    rcases one_div_lt_of_pos h\u2083 with \u27e8n, h\u2084, h\u2085\u27e9,\n    given h\u2084 : n \u2260 0,\n    given h\u2085 : 1 / (n : \u211d) < a,\n    have h\u2086 : (0 : \u211d) < n,\n    { norm_cast,\n      from nat.pos_of_ne_zero h\u2084, },\n    have h\u2087 : 0 <  1 / (n : \u211d), from one_div_pos.mpr h\u2086,\n    have : a < 1 / (n : \u211d), from h\u2082 _ h\u2087,\n    linarith, },\n/- hint\nhave h\u2083 : (a < 0) \u2228 (a = 0) \u2228 (0 < a), from trichotomous a 0,\nrcases h\u2083 with (h\u2083 | h\u2083 | h\u2083 ),\n{ given h\u2083 : a < 0,\n  sorry, },\n{ given h\u2083 : a = 0,\n  sorry,  },\n{ given h\u2083 : 0 < a,\n  rcases one_div_lt_of_pos h\u2083 with \u27e8n, h\u2084, h\u2085\u27e9,\n  given h\u2084 : n \u2260 0,\n  given h\u2085 : 1 / (n : \u211d) < a,\n  have h\u2086 : (0 : \u211d) < n,\n  { norm_cast,\n    from nat.pos_of_ne_zero h\u2084, },\n  have h\u2087 : 0 <  1 / (n : \u211d), from one_div_pos.mpr h\u2086,\n  sorry, },\n-/", "proof_hint": "have h\u2083 : (a < 0) \u2228 (a = 0) \u2228 (0 < a), from trichotomous a 0,\nrcases h\u2083 with (h\u2083 | h\u2083 | h\u2083 ),\n{ given h\u2083 : a < 0,\n  sorry, },\n{ given h\u2083 : a = 0,\n  sorry,  },\n{ given h\u2083 : 0 < a,\n  rcases one_div_lt_of_pos h\u2083 with \u27e8n, h\u2084, h\u2085\u27e9,\n  given h\u2084 : n \u2260 0,\n  given h\u2085 : 1 / (n : \u211d) < a,\n  have h\u2086 : (0 : \u211d) < n,\n  { norm_cast,\n    from nat.pos_of_ne_zero h\u2084, },\n  have h\u2087 : 0 <  1 / (n : \u211d), from one_div_pos.mpr h\u2086,\n  sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 33, "editorText": "have h\u2083 : (a < 0) \u2228 (a = 0) \u2228 (0 < a), from trichotomous a 0,\nrcases h\u2083 with (h\u2083 | h\u2083 | h\u2083 ),\n{ given h\u2083 : a < 0,\n  sorry, },\n{ given h\u2083 : a = 0,\n  sorry,  },\n{ given h\u2083 : 0 < a,\n  rcases one_div_lt_of_pos h\u2083 with \u27e8n, h\u2084, h\u2085\u27e9,\n  given h\u2084 : n \u2260 0,\n  given h\u2085 : 1 / (n : \u211d) < a,\n  have h\u2086 : (0 : \u211d) < n,\n  { norm_cast,\n    from nat.pos_of_ne_zero h\u2084, },\n  have h\u2087 : 0 <  1 / (n : \u211d), from one_div_pos.mpr h\u2086,\n  sorry, },", "lineOffset": 51, "name": "zero_of_non_neg_of_lt_pos", "statement": "(a : \u211d) (h : 0 \u2264 a) (h\u2082 : \u2200 \u03b5 > 0, a < \u03b5) :\na = 0"}, {"type": "lean", "content": "1727", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1728", "hidden": true}, {"type": "lean", "content": "1729", "hidden": true}, {"type": "text", "content": "1730"}, {"type": "lean", "content": "1731", "hidden": true}, {"type": "lean", "content": "1732", "hidden": true}, {"type": "lean", "content": "1733", "hidden": true}, {"type": "text", "content": "1734"}, {"type": "text", "content": "1735"}, {"type": "axiom", "content": "1736", "name": "neg_le_of_abs_le  {a b : \u211d} (h : |a| \u2264 b) :", "sideBar": true}, {"type": "lean", "content": "1737", "hidden": true}, {"type": "lean", "content": "1738", "hidden": false}, {"type": "text", "content": "1739"}, {"type": "theorem", "text": "1740", "lean": "lemma le_of_abs_le (h : |a| \u2264 b) : a \u2264 b :=\n", "sideBar": true, "firstProofLineNumber": 73, "lastProofLineNumber": 85, "textBefore": "import reals.arbitrarily_small_number_is_zero -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 21: Absolute values\n-/\n\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n/-\nLet $a$ be a real number (more generally a term in a linear ordered type). The\n*absolute value* of $a$, written $|a|$ is defined to be $\\max(a,-a)$.\n\nThus $|5| = \\max(5,-5) = 5$, while $|-10| = \\max(-10,-(-10)) = 10$.\n\nAs with the maximum function, the absolute value function is crucial to the study of\nreal analysis.\n\nIn this level, we'll prove the following theorems.\n\n* If $|a| \\le b$, then $a \\le b$.\n\n* If $|a| \\le b$, then $-b \\le a$.\n-/\n\n/-\nHere is a Lean proof of the second theorem, which we prove by appeal to our results on\nmaxima, together with results on negating inequalities and equations.\n-/\n\n\n/- Axiom : neg_le_of_abs_le  {a b : \u211d} (h : |a| \u2264 b) :\n-b \u2264 a\n-/\n\nvariables {a b : \u211d} -- hide\n\n\nlemma neg_le_of_abs_le (h : |a| \u2264 b) : -b \u2264 a :=\nbegin\n  given h : max a (-a) \u2264 b,\n  calc\n  -b \u2264 -(max a (-a)) : by {rw neg_le_neg_iff, from h }\n  ... \u2264 -(-a)        : by {rw neg_le_neg_iff, apply le_max_right }\n  ... = a            : by rw neg_neg,\nend\n\n\n\n\n/-\n## Task\nProve that if $a$ and $b$ are real numbers and if $|a| \\le b$, then $-b \\le a$.\nThis is easier than the proof above. Other than the given hypothesis, you should\nonly need to use one result on maxima.\n-/\n\n\n/- Theorem :\nIf $a$ and $b$ are real numbers and if $|a| \\le b$, then $a \\le b$.\n-/\nlemma le_of_abs_le (h : |a| \u2264 b) : a \u2264 b :=\nbegin\n", "proof": "  given h : max a (-a) \u2264 b,\n  calc\n  a \u2264 max a (-a) : by apply le_max_left \n  ... \u2264 b        : h\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 72, "name": "le_of_abs_le", "statement": "(h : |a| \u2264 b) : a \u2264 b"}, {"type": "lean", "content": "1741", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1742", "hidden": true}, {"type": "lean", "content": "1743", "hidden": true}, {"type": "text", "content": "1744"}, {"type": "lean", "content": "1745", "hidden": true}, {"type": "lean", "content": "1746", "hidden": true}, {"type": "lean", "content": "1747", "hidden": true}, {"type": "text", "content": "1748"}, {"type": "lean", "content": "1749", "hidden": true}, {"type": "theorem", "text": "1750", "lean": "lemma bounded_iff : bounded S \u2194 \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M  :=\n", "sideBar": true, "firstProofLineNumber": 38, "firstProofHintLineNumber": 78, "lastProofHintLineNumber": 101, "lastProofLineNumber": 102, "textBefore": "import reals.absolute_values -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 22: A condition for boundedness\n\nUsing the Archimedean property, you will show that a set $S$ of real numbers is\nbounded if and only if there exists a natural number $M$ such that\n$|x| \\le M$, for all $x \\in S$.\n-/\n\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n/-\n## Task\nComplete the Lean proof below. You'll need results on maxima and absolute\nvalues. You will need the Archimedean property of $\\mathbb R$.\n-/\n\nvariable {S : set \u211d} -- hide\n\n/- Theorem :\nLet $S$ be a set of real numbers. The set $S$ is bounded if and only if\nthere exists a natural number $M$ such that for all $x \\in S$,\n$|x| \\le M$.\n-/\nlemma bounded_iff : bounded S \u2194 \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M  :=\nbegin\n", "proof": "  split,\n  { assume h : bounded S,\n    rcases h with \u27e8\u27e8u, h\u2082 : is_upper_bound S u\u27e9, \u27e8v, h\u2083 : is_lower_bound S v\u27e9\u27e9,\n    show \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n    let b := max (u) (-v),\n    have h\u2084 : \u2203 (M : \u2115), b < M, from archimedean b,\n    rcases h\u2084 with \u27e8M, h\u2084 : b < M\u27e9,\n    use M,\n    assume x : \u211d,\n    assume h\u2085 : x \u2208 S,\n    show |x| \u2264 M, rw abs_le,\n    show x \u2265 -M \u2227 x \u2264 M,\n    split,\n    { show x \u2265 -M,\n      calc\n      x \u2265 v     : h\u2083 _ h\u2085\n      ... \u2265 -b  : by { show -b \u2264 v, rw neg_le, apply le_max_right }\n      ... \u2265 -M   : by linarith, },\n    { show x \u2264 M,\n      calc\n      x \u2264 u     : h\u2082 _ h\u2085\n      ... \u2264 b   : by apply le_max_left\n      ... \u2264 M    : by linarith, } },\n  { assume h : \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n    rcases h with \u27e8M, h\u2082 : \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M\u27e9,\n    show bounded S,\n    split,\n    { show bounded_above S,\n      use M,\n      assume x : \u211d,\n      assume h\u2083 : x \u2208 S,\n      have h\u2084 : |x| \u2264 M, from h\u2082 _ h\u2083,\n      show x \u2264 M, from le_of_abs_le h\u2084, },\n    { show bounded_below S,\n      use -M,\n      assume x : \u211d,\n      assume h\u2083 : x \u2208 S,\n      have h\u2084 : |x| \u2264 M, from h\u2082 _ h\u2083,\n      show x \u2265 - M, from neg_le_of_abs_le h\u2084, }, },\n/- hint\nsplit,\n{ assume h : bounded S,\n  rcases h with \u27e8\u27e8u, h\u2082 : is_upper_bound S u\u27e9, \u27e8v, h\u2083 : is_lower_bound S v\u27e9\u27e9,\n  show \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  let b := max (u) (-v),\n  have h\u2084 : \u2203 (M : \u2115), b < M, sorry,\n  rcases h\u2084 with \u27e8M, h\u2084 : b < M\u27e9,\n  use M,\n  assume x : \u211d,\n  assume h\u2085 : x \u2208 S,\n  show |x| \u2264 M, rw abs_le,\n  show x \u2265 -M \u2227 x \u2264 M,\n  split,\n  { show x \u2265 -M,\n    calc\n    x \u2265 v     : h\u2083 _ h\u2085\n    ... \u2265 -b  : by { show -b \u2264 v, rw neg_le, apply le_max_right }\n    ... \u2265 -M   : by linarith, },\n  { show x \u2264 M,\n    sorry, } },\n{ assume h : \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  rcases h with \u27e8M, h\u2082 : \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M\u27e9,\n  show bounded S,\n  sorry, },\n-/", "proof_hint": "split,\n{ assume h : bounded S,\n  rcases h with \u27e8\u27e8u, h\u2082 : is_upper_bound S u\u27e9, \u27e8v, h\u2083 : is_lower_bound S v\u27e9\u27e9,\n  show \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  let b := max (u) (-v),\n  have h\u2084 : \u2203 (M : \u2115), b < M, sorry,\n  rcases h\u2084 with \u27e8M, h\u2084 : b < M\u27e9,\n  use M,\n  assume x : \u211d,\n  assume h\u2085 : x \u2208 S,\n  show |x| \u2264 M, rw abs_le,\n  show x \u2265 -M \u2227 x \u2264 M,\n  split,\n  { show x \u2265 -M,\n    calc\n    x \u2265 v     : h\u2083 _ h\u2085\n    ... \u2265 -b  : by { show -b \u2264 v, rw neg_le, apply le_max_right }\n    ... \u2265 -M   : by linarith, },\n  { show x \u2264 M,\n    sorry, } },\n{ assume h : \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  rcases h with \u27e8M, h\u2082 : \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M\u27e9,\n  show bounded S,\n  sorry, },", "textAfter": "\nend\n\nend exlean -- hide", "height": 65, "editorText": "split,\n{ assume h : bounded S,\n  rcases h with \u27e8\u27e8u, h\u2082 : is_upper_bound S u\u27e9, \u27e8v, h\u2083 : is_lower_bound S v\u27e9\u27e9,\n  show \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  let b := max (u) (-v),\n  have h\u2084 : \u2203 (M : \u2115), b < M, sorry,\n  rcases h\u2084 with \u27e8M, h\u2084 : b < M\u27e9,\n  use M,\n  assume x : \u211d,\n  assume h\u2085 : x \u2208 S,\n  show |x| \u2264 M, rw abs_le,\n  show x \u2265 -M \u2227 x \u2264 M,\n  split,\n  { show x \u2265 -M,\n    calc\n    x \u2265 v     : h\u2083 _ h\u2085\n    ... \u2265 -b  : by { show -b \u2264 v, rw neg_le, apply le_max_right }\n    ... \u2265 -M   : by linarith, },\n  { show x \u2264 M,\n    sorry, } },\n{ assume h : \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M,\n  rcases h with \u27e8M, h\u2082 : \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M\u27e9,\n  show bounded S,\n  sorry, },", "lineOffset": 37, "name": "bounded_iff", "statement": "bounded S \u2194 \u2203 (M : \u2115), \u2200 (x : \u211d), x \u2208 S \u2192 |x| \u2264 M"}, {"type": "lean", "content": "1751", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "1752", "hidden": true}, {"type": "lean", "content": "1753", "hidden": true}, {"type": "text", "content": "1754"}, {"type": "text", "content": "1755"}, {"type": "lean", "content": "1756", "hidden": true}, {"type": "lean", "content": "1757", "hidden": true}, {"type": "lean", "content": "1758", "hidden": true}, {"type": "text", "content": "1759"}, {"type": "axiom", "content": "1760", "name": "sq_lt_sq_of_nonneg_of_lt (h\u2081 : a < b) (h\u2082 : 0 \u2264 a) :", "sideBar": true}, {"type": "lean", "content": "1761", "hidden": false}, {"type": "text", "content": "1762"}, {"type": "theorem", "text": "1763", "lean": "lemma sqrt2_set_has_sup : has_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} :=\n", "sideBar": true, "firstProofLineNumber": 74, "firstProofHintLineNumber": 99, "lastProofHintLineNumber": 108, "lastProofLineNumber": 123, "textBefore": "import reals.bounded_iff -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 23: Existence of a square root of 2: finding a supremum \n\nIt is well known to school students that there is no rational number whose square is $2$.\nIn the next few levels, we will prove that there *is* a real number whose square is $2$.\nThese levels are somewhat challenging.\n\nThe idea is to describe a set whose supremum is a square root of $2$.\n-/\n \n/-\n**Proof outline**:\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$.\nClearly $S$ is non-empty and bounded above, thus it has a supremum. Call this $u$\n\nWe'll show $u^2 = 2$ by showing $u^2 \\le 2$ and $2 \\le u^2$.\n\nTo show $u^2 \\le 2$, assume, for a contradiction, that $2 < u^2$.\nOn this assumption, one can find an upper bound $t$ of $S$ such that $t < u$,\ncontradicting the assumption that $S$ has no smaller upper bound that $u$.\n\n\nTo show $2 \\le u^2$, assume, for a contradiciton, that $u ^ 2 < 2$.\nOn this assumption, one can find an element $x$ of $S$ such that $u < x$,\ncontradicting the assumption that $u$ is an upper bound of $S$.\n\u220e \n-/\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n/-\n## A useful result\n\nIn the proof below, you will need the result that if $0 \\le a$ and $a < b$, then\n$a^2 < b^2$. We call this result `sq_lt_sq_of_nonneg_of_lt`.\n-/\n\n/- Axiom : sq_lt_sq_of_nonneg_of_lt (h\u2081 : a < b) (h\u2082 : 0 \u2264 a) :\na ^ 2 < b ^ 2 :=\n-/\n\nexample (a b : \u211d) (h\u2081 : a < b) (h\u2082 : 0 \u2264 a) : a ^ 2 < b ^ 2 :=\nbegin\n  from sq_lt_sq_of_nonneg_of_lt h\u2081 h\u2082,\nend\n\n\n/-\n## Task\nLet $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$.\nShow that $S$ has a supremum.\n\nRemember to use the `norm_num` tactic for purely numerical results and the\n`linarith` tactic for arithemtic results involving variables.\n-/\n\n/- Theorem :\nLet $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$. Then $S$ has a\nsupremum.\n-/\nlemma sqrt2_set_has_sup : has_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} :=\nbegin\n", "proof": "  let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\n  show \u2203 (u : \u211d), is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u,\n  have h\u2081 : (0 : \u211d) \u2208 S,\n  { show (0 : \u211d) \u2264 0 \u2227 (0 : \u211d)^2 < 2,\n    split,\n    { norm_num },\n    { norm_num }, },\n  have h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\n  have h\u2083 : bounded_above S,\n  { use 2,\n    show \u2200 (x : \u211d), x \u2208 S \u2192 x \u2264 2,\n    assume x : \u211d,\n    assume h : x \u2208 S,\n    given h : 0 \u2264 x \u2227 x ^ 2 < 2,\n    cases h with k\u2081 k\u2082,\n    show x \u2264 2,\n    by_contra k,\n    have k\u2083 : 2 < x, linarith,\n    have : 2 ^ 2 < x ^ 2,\n    { apply sq_lt_sq_of_nonneg_of_lt,\n      { show 2 < x, from k\u2083, },\n      { show (0 : \u211d) \u2264 2, linarith, }, },\n    linarith, },\n  show has_sup S, from completeness h\u2082 h\u2083,\n/- hint\nlet S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nshow \u2203 (u : \u211d), is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u,\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ show (0 : \u211d) \u2264 0 \u2227 (0 : \u211d)^2 < 2,\n  sorry, },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry, },\nshow has_sup S, sorry,\n\n-/\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nshow \u2203 (u : \u211d), is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u,\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ show (0 : \u211d) \u2264 0 \u2227 (0 : \u211d)^2 < 2,\n  sorry, },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry, },\nshow has_sup S, sorry,\n", "textAfter": "\nend\n\nend exlean -- hide", "height": 50, "editorText": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nshow \u2203 (u : \u211d), is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u,\nhave h\u2081 : (0 : \u211d) \u2208 S,\n{ show (0 : \u211d) \u2264 0 \u2227 (0 : \u211d)^2 < 2,\n  sorry, },\nhave h\u2082 : S.nonempty, from nonempty_of_mem h\u2081,\nhave h\u2083 : bounded_above S,\n{ sorry, },\nshow has_sup S, sorry,\n", "lineOffset": 73, "name": "sqrt2_set_has_sup", "statement": "has_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2}"}, {"type": "lean", "content": "1764", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1765", "hidden": true}, {"type": "lean", "content": "1766", "hidden": true}, {"type": "text", "content": "1767"}, {"type": "lean", "content": "1768", "hidden": true}, {"type": "lean", "content": "1769", "hidden": true}, {"type": "lean", "content": "1770", "hidden": true}, {"type": "text", "content": "1771"}, {"type": "theorem", "text": "1772", "lean": "lemma sqrt2_set_ub_pos {u : \u211d} (h : is_upper_bound {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n0 < u :=\n", "sideBar": true, "firstProofLineNumber": 37, "firstProofHintLineNumber": 48, "lastProofHintLineNumber": 51, "lastProofLineNumber": 61, "textBefore": "import reals.sqrt2_supremum -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 24: Positivity of upper bound for the square root of 2 set\n-/\n \nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n\n/-\n## Task\nContinuing from the previous level, let\n$S$ be the set of non-negative real numbers such that $x ^ 2 < 2$.\n\nSuppose $u$ is an upper bound of $S$. Your task is to prove that $u$ is positive.\n\nI suggest a proof by contradiction. The Lean fragment below\nstarts your proof.\n-/\n\n/- Theorem :\nLet $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$. Suppose $u$ is an upper bound of $S$.\nThen $u$ is positive.\n-/\nlemma sqrt2_set_ub_pos {u : \u211d} (h : is_upper_bound {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n0 < u :=\nbegin\n", "proof": "  let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\n  by_contra k,\n  given k : \u00ac(0 < u),\n  have h\u2082 : u \u2264 0, linarith,\n  have h\u2083 : (1 : \u211d) \u2208 S,\n  { split,\n    { linarith },\n    { linarith, }, },\n  have h\u2084 : (1 : \u211d) \u2264 u, from h _ h\u2083,\n  linarith,\n/- hint\nlet S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nby_contra k,\ngiven k : \u00ac(0 < u),\nsorry,\n-/\n\n\n\n\n\n\n\n\n", "proof_hint": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nby_contra k,\ngiven k : \u00ac(0 < u),\nsorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 25, "editorText": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nby_contra k,\ngiven k : \u00ac(0 < u),\nsorry,", "lineOffset": 36, "name": "sqrt2_set_ub_pos", "statement": "{u : \u211d} (h : is_upper_bound {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n0 < u"}, {"type": "lean", "content": "1773", "hidden": true}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "1774", "hidden": true}, {"type": "lean", "content": "1775", "hidden": true}, {"type": "text", "content": "1776"}, {"type": "lean", "content": "1777", "hidden": true}, {"type": "lean", "content": "1778", "hidden": true}, {"type": "lean", "content": "1779", "hidden": true}, {"type": "lean", "content": "1780", "hidden": true}, {"type": "text", "content": "1781"}, {"type": "axiom", "content": "1782", "name": "two_lt_sub_one_div_sq_of_archi {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)", "sideBar": true}, {"type": "axiom", "content": "1783", "name": "nonneg_sub_one_div_nat_of_pos {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : (0 : \u211d) < u)", "sideBar": true}, {"type": "text", "content": "1784"}, {"type": "lean", "content": "1785", "hidden": false}, {"type": "text", "content": "1786"}, {"type": "lean", "content": "1787", "hidden": false}, {"type": "text", "content": "1788"}, {"type": "theorem", "text": "1789", "lean": "lemma sqrt2_set_sup_sq_le_2 (u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\nu ^ 2 \u2264 2 :=\n", "sideBar": true, "firstProofLineNumber": 165, "firstProofHintLineNumber": 195, "lastProofHintLineNumber": 222, "lastProofLineNumber": 236, "textBefore": "import reals.sqrt2_set_ub_pos -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 25: The supremum squared is at most 2\n\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nIn this level, you will show $u \\le 2$. The idea is to use assume that\n$2 < u ^2$ and thereby derive a contradiction. In particular, you will show that there is an upper bound $y$,\nof $S$ that is smaller than $u$.\n\nThe upper bound $y$ will take the form $u - 1 /n$ where $n$ is a natural number chosen so that\n$1/n < (u ^ 2 - 2) / (2u)$. The existence of a such a natural number $n$ is guaranteed by the corollary to\nthe Archimedean property of $\\mathbb R$.\n-/\n \nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n-- begin hide\n\nnamespace sqrt2_lemmas\n\nlemma goo {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)\n(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < u ^ 2 - (2 * u) * (1 / (n : \u211d)) :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,\n  suffices : (2 * u) * (1 / (n : \u211d)) < u ^2 - 2, linarith,\n  suffices : (2 * u) * (1 / (n : \u211d)) < (2 * u) * ((u ^2 - 2) / (2 *u)),\n  { have h\u2083 : (2 * u) * ((u ^2 - 2) / (2 *u)) =  u ^ 2 - 2,\n    { rw mul_comm, rw div_mul_cancel, linarith, },\n    rwa \u2190h\u2083, },\n  apply mul_lt_mul_of_pos_left,\n  { from h, },\n  { show 0 < 2 * u, linarith, },\nend\n\nlemma boo {n : \u2115} (u : \u211d) (hne : n \u2260 0) : -- don't change this\nu ^ 2 - (2 * u) * (1 / (n : \u211d))  \u2264 (u - 1 / (n : \u211d))^2 :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,\n  rw (show \u2200 (v : \u211d), (u - v)^2 = u ^2 - (2 * u) * v + v ^ 2, from \u03bb v, by ring ),\n  suffices : (u ^ 2 - 2 * u * (1 / \u2191n)) + 0 \u2264 (u ^ 2 - 2 * u * (1 / \u2191n)) + (1 / \u2191n) ^ 2,\n  { linarith, },\n  apply add_le_add,\n  { reflexivity, },\n  { rw [pow_two],\n    apply le_of_lt,\n    apply mul_pos; assumption, },\nend\n\nend sqrt2_lemmas\n\nlemma le_of_sq_le_sq_of_nonneg {a b : \u211d} (h\u2081 : 0 \u2264 b) (h\u2082 : a ^ 2 \u2264 b ^ 2) :\na \u2264 b :=\nbegin\n  by_contra k,\n  given k : \u00ac(a \u2264 b),\n  have h\u2083 : b < a, linarith,\n  have : b * b < a * a,\n  { from mul_self_lt_mul_self h\u2081 h\u2083, },\n  linarith,\nend\n\nlemma two_lt_sub_one_div_sq_of_archi {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)\n(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d))^2 :=\nbegin\n  have gtr := sqrt2_lemmas.goo hne upos h,\n  have er := sqrt2_lemmas.boo u hne,\n  linarith,\nend\n\nlemma nonneg_sub_one_div_nat_of_pos {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : (0 : \u211d) < u) \n(usqgt : 2 < u ^ 2)\n: (0 : R) \u2264 u - 1 / (n : \u211d) :=\nbegin\n  by_contra p, \n  have : u \u2264 1 / (n : \u211d), linarith,\n  have h\u2082 : 1 \u2264 (n : \u211d),\n  { rwa [\u2190nat.cast_one, nat.cast_le, nat.one_le_iff_ne_zero], },\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have h\u2084 : 1 / (n : \u211d) \u2264 1 / (1 : \u211d),\n  { rwa one_div_le_one_div npos zero_lt_one, },\n  have h\u2085 : u \u2264 1 / (1 : \u211d), linarith,\n  rw (show 1 / (1 : \u211d) = 1, from div_one 1) at h\u2085,\n  have : u * u \u2264 1 * 1, from mul_le_mul h\u2085 h\u2085 (le_of_lt upos) zero_le_one,\n  linarith,\nend\n\n\n-- end hide\n\n\n\n\n\n/-\n## Useful results\n\nIn your proof, you'll need a few results.\n-/\n\n/- Axiom : two_lt_sub_one_div_sq_of_archi {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)\n(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d))^2 \n-/\n\n/- Axiom : nonneg_sub_one_div_nat_of_pos {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : (0 : \u211d) < u) \n(usqgt : 2 < u ^ 2)\n: (0 : R) \u2264 u - 1 / (n : \u211d) \n\n-/\n\n\n/-\nThe result `two_lt_sub_one_div_sq_of_archi` proves $2 < (u - 1 /n)^2$ on the assumptions\n$n \\ne 0$, $0 < u$, and $1 / n < (u ^ 2 - 2) / (2  u)$.\n-/\n\nexample (u : \u211d) (n : \u2115) (hne : n \u2260 0) (upos : 0 < u) (h : 1 / (n : \u211d) < (u ^ 2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d)) ^ 2:=\nbegin\n  from two_lt_sub_one_div_sq_of_archi hne upos h,\nend\n\n/-\nThe result `nonneg_sub_one_div_nat_of_posi` proves $0 \\le u - 1/n$ on the assumptions\n$n \\ne 0$, $0 < u$, and $2 < u^2$.\n-/\n\nexample (u : \u211d) (n : \u2115) (hne : n \u2260 0) (upos : 0 < u) (usqgt : 2 < u ^ 2) : 0 \u2264 u - 1 / (n : \u211d) :=\nbegin\n  from nonneg_sub_one_div_nat_of_pos hne upos usqgt,\nend\n/-\n## Task\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nYour task is to show $u^2 \\le 2$ by completing the proof sketched out below. Use the lemmas mentioned above\nand any relevant lemmas from previous levels.\n-/\n\n/- Theorem :\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$\nbe a supremum of $S$. Then $u^2 \\le 2$.\n-/\nlemma sqrt2_set_sup_sq_le_2 (u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\nu ^ 2 \u2264 2 :=\nbegin\n", "proof": "  let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\n  rcases h with \u27e8h\u2082 : is_upper_bound S u, h\u2083 : no_smaller_upper_bound S u\u27e9,\n  by_contra k,\n  given k : \u00ac(u ^ 2 \u2264 2),\n  have h\u2084 : 2 < u ^ 2, linarith,\n  let t := (u ^ 2 - 2) / ((2 : \u211d) * u),\n  have upos : 0 < u, from sqrt2_set_ub_pos h\u2082,\n  have h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\n  rcases one_div_lt_of_pos h\u2085 with            -- This is the application of our corollary to the\n    \u27e8n, hne : n \u2260 0, h\u2085 : 1 / (n : \u211d) < t\u27e9,   -- Archimedean property of \u211d\n  set y := u - 1 / (n : \u211d) with hy,\n  have h\u2086 : is_upper_bound S y,               -- Start of proof that y is an upper bound of S\n  { assume x : \u211d,\n    assume hx : x \u2208 S,\n    rcases hx with \u27e8xnn : 0 \u2264 x,  xsqlt : x ^ 2 < 2\u27e9,\n    rw hy,\n    show x \u2264 u - 1 / (n : \u211d),\n    apply le_of_sq_le_sq_of_nonneg,\n    { show 0 \u2264 u - 1 / (n : \u211d), from nonneg_sub_one_div_nat_of_pos hne upos h\u2084, },\n    { show x ^ 2 \u2264 (u - 1 / (n : \u211d))^2,\n      have h\u2087 : 2 < (u - 1 / (n : \u211d))^2,\n        from two_lt_sub_one_div_sq_of_archi hne upos h\u2085,\n      linarith, }, },                       -- End of proof that y is an upper bound of S\n  have npos : (0 : \u211d) < n,                                  -- The results that 0 < n and \n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },   -- 0 < 1/ n are neeeded by linarith\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,        -- in the remainder of the proof.\n  have : y < u, linarith,\n  have : u \u2264 y, from h\u2083 _ h\u2086,\n  show false, linarith,\n/- hint\nlet S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, h\u2083 : no_smaller_upper_bound S u\u27e9,\nby_contra k,\ngiven k : \u00ac(u ^ 2 \u2264 2),\nhave h\u2084 : 2 < u ^ 2, linarith,\nlet t := (u ^ 2 - 2) / ((2 : \u211d) * u),\nhave upos : 0 < u, sorry,\n  have h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nrcases one_div_lt_of_pos h\u2085 with            -- This is the application of our corollary to the\n  \u27e8n, hne : n \u2260 0, h\u2085 : 1 / (n : \u211d) < t\u27e9,   -- Archimedean property of \u211d\nset y := u - 1 / (n : \u211d) with hy,\nhave h\u2086 : is_upper_bound S y,               -- Start of proof that y is an upper bound of S\n{ assume x : \u211d,\n  assume hx : x \u2208 S,\n  rcases hx with \u27e8xnn : 0 \u2264 x,  xsqlt : x ^ 2 < 2\u27e9,\n  rw hy,\n  show x \u2264 u - 1 / (n : \u211d),\n  apply le_of_sq_le_sq_of_nonneg,\n  { show 0 \u2264 u - 1 / (n : \u211d), sorry, },\n  { show x ^ 2 \u2264 (u - 1 / (n : \u211d))^2,\n    have h\u2087 : 2 < (u - 1 / (n : \u211d))^2, sorry,\n    linarith, }, },                         -- End of proof that y is an upper bound of S\nhave npos : (0 : \u211d) < n,                                    -- The results that 0 < n and \n{ rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },     -- 0 < 1/ n are neeeded by linarith\nhave : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,          -- in the remainder of the proof.\nhave : y < u, linarith,\nhave : u \u2264 y, sorry,\nshow false, linarith,\n-/\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, h\u2083 : no_smaller_upper_bound S u\u27e9,\nby_contra k,\ngiven k : \u00ac(u ^ 2 \u2264 2),\nhave h\u2084 : 2 < u ^ 2, linarith,\nlet t := (u ^ 2 - 2) / ((2 : \u211d) * u),\nhave upos : 0 < u, sorry,\n  have h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nrcases one_div_lt_of_pos h\u2085 with            -- This is the application of our corollary to the\n  \u27e8n, hne : n \u2260 0, h\u2085 : 1 / (n : \u211d) < t\u27e9,   -- Archimedean property of \u211d\nset y := u - 1 / (n : \u211d) with hy,\nhave h\u2086 : is_upper_bound S y,               -- Start of proof that y is an upper bound of S\n{ assume x : \u211d,\n  assume hx : x \u2208 S,\n  rcases hx with \u27e8xnn : 0 \u2264 x,  xsqlt : x ^ 2 < 2\u27e9,\n  rw hy,\n  show x \u2264 u - 1 / (n : \u211d),\n  apply le_of_sq_le_sq_of_nonneg,\n  { show 0 \u2264 u - 1 / (n : \u211d), sorry, },\n  { show x ^ 2 \u2264 (u - 1 / (n : \u211d))^2,\n    have h\u2087 : 2 < (u - 1 / (n : \u211d))^2, sorry,\n    linarith, }, },                         -- End of proof that y is an upper bound of S\nhave npos : (0 : \u211d) < n,                                    -- The results that 0 < n and \n{ rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },     -- 0 < 1/ n are neeeded by linarith\nhave : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,          -- in the remainder of the proof.\nhave : y < u, linarith,\nhave : u \u2264 y, sorry,\nshow false, linarith,", "textAfter": "\nend\n\nend exlean -- hide", "height": 72, "editorText": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, h\u2083 : no_smaller_upper_bound S u\u27e9,\nby_contra k,\ngiven k : \u00ac(u ^ 2 \u2264 2),\nhave h\u2084 : 2 < u ^ 2, linarith,\nlet t := (u ^ 2 - 2) / ((2 : \u211d) * u),\nhave upos : 0 < u, sorry,\n  have h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nrcases one_div_lt_of_pos h\u2085 with            -- This is the application of our corollary to the\n  \u27e8n, hne : n \u2260 0, h\u2085 : 1 / (n : \u211d) < t\u27e9,   -- Archimedean property of \u211d\nset y := u - 1 / (n : \u211d) with hy,\nhave h\u2086 : is_upper_bound S y,               -- Start of proof that y is an upper bound of S\n{ assume x : \u211d,\n  assume hx : x \u2208 S,\n  rcases hx with \u27e8xnn : 0 \u2264 x,  xsqlt : x ^ 2 < 2\u27e9,\n  rw hy,\n  show x \u2264 u - 1 / (n : \u211d),\n  apply le_of_sq_le_sq_of_nonneg,\n  { show 0 \u2264 u - 1 / (n : \u211d), sorry, },\n  { show x ^ 2 \u2264 (u - 1 / (n : \u211d))^2,\n    have h\u2087 : 2 < (u - 1 / (n : \u211d))^2, sorry,\n    linarith, }, },                         -- End of proof that y is an upper bound of S\nhave npos : (0 : \u211d) < n,                                    -- The results that 0 < n and \n{ rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },     -- 0 < 1/ n are neeeded by linarith\nhave : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,          -- in the remainder of the proof.\nhave : y < u, linarith,\nhave : u \u2264 y, sorry,\nshow false, linarith,", "lineOffset": 164, "name": "sqrt2_set_sup_sq_le_2", "statement": "(u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\nu ^ 2 \u2264 2"}, {"type": "lean", "content": "1790", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "1791", "hidden": true}, {"type": "lean", "content": "1792", "hidden": true}, {"type": "text", "content": "1793"}, {"type": "lean", "content": "1794", "hidden": true}, {"type": "lean", "content": "1795", "hidden": true}, {"type": "lean", "content": "1796", "hidden": true}, {"type": "lean", "content": "1797", "hidden": true}, {"type": "text", "content": "1798"}, {"type": "lean", "content": "1799", "hidden": false}, {"type": "text", "content": "1800"}, {"type": "theorem", "text": "1801", "lean": "lemma sqrt2_set_sup_sq_ge_2 (u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n2 \u2264 u^2 :=\n", "sideBar": true, "firstProofLineNumber": 125, "firstProofHintLineNumber": 149, "lastProofHintLineNumber": 157, "lastProofLineNumber": 173, "textBefore": "import reals.sqrt2_set_sup_sq_le_2 -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 26: The supremum squared is at least 2\n\nYou will now prove the other direction of the inequality you proved in the previous level.\n\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nIn this level, you will show $2 ^ \\le u^2$. You'll start by assuming $u ^2 < 2$, for a contradiction.\n\nIndeed, you'll find that $u$ is not an upper bound of $S$. To do this, you'll take $y$ to be $u + 1 / n$,\nwhere $n$ is a natural number chosen so that $1 / n < (2 - u ^ 2) / (2  u + 1)$. You can then prove that $y \\in S$,\nand that $u < y$.\n-/\n \nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n-- begin hide\n\nnamespace sqrt2_lemmas\n\nlemma add_sq_le_of_pos_of_ne_zero {n : \u2115} {u : \u211d} (hne : n \u2260 0) :\n(u + 1 / (n : \u211d))^2 \u2264 \nu ^ 2 + (1 / (n : \u211d)) * (2 * u + 1) :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero] }, \n  suffices : u ^2 + (2 * u) * (1 / (n : \u211d)) + (1 / (n : \u211d)) ^ 2 \u2264 \n    u ^ 2 + (1 / (n : \u211d)) * (2 * u + 1),\n  { rwa (show \u2200 (v : \u211d), (u + v)^2 = u ^2 + (2 * u) * v + v ^ 2, from \u03bb v, by ring ), },\n  rw add_assoc,\n  apply add_le_add_left,\n  rw [mul_add, mul_one],\n  have hnge1 : 1 \u2264 (n : \u211d),\n  { rwa [\u2190nat.cast_one, nat.cast_le, nat.one_le_iff_ne_zero], },\n  have : 1 / (n : \u211d)^2 \u2264 1 / (n : \u211d),\n  { rw one_div_le_one_div _ npos ,\n    { show (n : \u211d) \u2264 (n : \u211d) ^2,\n      suffices : (n : \u211d) * 1 \u2264 n * n,\n      { rw mul_one at this,\n        rwa [pow_two], },\n      from mul_le_mul_of_nonneg_left hnge1 (le_of_lt npos), },\n    { rw [pow_two],\n      apply mul_pos npos npos, } },\n  apply add_le_add,\n  { linarith },\n  { rwa one_div_pow 2, },\nend\n\n\nlemma sq_add_lt_two_of_archi {n : \u2115} {u : \u211d} (upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)):\nu ^2 + 1 / (n : \u211d) * (2*u + 1) < 2 :=\nbegin\n  suffices h\u2082 : u ^2 + 1 / (n : \u211d) * (2*u + 1) < u ^2 + (2 - u^2),\n  { rwa (show u ^2 + (2 - u^2) = 2, by linarith) at h\u2082,  },\n  apply add_lt_add_left,\n  have : 2 - u ^ 2 = ( (2 - u^2) / (2 * u + 1)) * (2 * u + 1),\n  { rw div_mul_cancel,\n    linarith,  },\n  rw this,\n  apply mul_lt_mul_of_pos_right,\n  { from h, },\n  { linarith, }\nend\n\nend sqrt2_lemmas\n\nlemma add_sq_lt_two_of_archi {n : \u2115} {u : \u211d} (hne : n \u2260 0)\n(upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)) :\n(u + 1/(n : \u211d)) ^2  < 2 :=\nbegin\n  from lt_of_le_of_lt\n    (sqrt2_lemmas.add_sq_le_of_pos_of_ne_zero hne)\n    (sqrt2_lemmas.sq_add_lt_two_of_archi upos h)\nend\n\n-- end hide\n\n/-\n## A useful result\n\nYou'll need the result `add_sq_lt_two_of_archi`. This proves $(u + 1 /n) ^2 < 2$, given the\nassumptions $n \\ne 0$, $0 < u$, and $1 / n < (2 - u ^ 2) / (2 u + 1)$.\n\nHere is an example.\n-/\n\nexample (n : \u2115) (u : \u211d) (hne : n \u2260 0) (upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)) :\n(u + 1/(n : \u211d)) ^2  < 2 :=\nbegin\n  from add_sq_lt_two_of_archi hne upos h,\nend\n\n/-\n## Task\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nYour task is to show $2 \\le u ^ 2$. I give you the first few lines of the proof. You'll need to use\nthe lemma `add_sq_lt_two_of_archi` and adapt the proof given in the previous level.\n\nNote that the structure of this proof will be different (indeed somewhat simpler) than that of the\nproof in the previous level. In this level, you'll be deriving a contradiction from the fact that\n$u$ is an upper bound of $S$. In the previous level, you needed to use the more complicated fact that\n$S$ has no smaller upper bound than $u$.\n-/\n\n\n/- Theorem :\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$\nbe a supremum of $S$. Then $2 \\le u ^2$.\n-/\nlemma sqrt2_set_sup_sq_ge_2 (u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n2 \u2264 u^2 :=\nbegin\n", "proof": "  let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\n  rcases h with \u27e8h\u2082 : is_upper_bound S u, -\u27e9,\n  by_contra k,\n  given k : \u00ac(2 \u2264 u ^ 2),\n  have h\u2084 : u ^ 2 < 2, linarith,\n  let t := ((2 : \u211d) - u ^ 2) / ((2 : \u211d) * u + 1),\n  have upos : 0 < u, from sqrt2_set_ub_pos h\u2082,\n  have h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\n  rcases one_div_lt_of_pos h\u2085 with           -- This is the application of our corollary to the\n    \u27e8n, hne : n \u2260 0, h\u2085 : 1 / (n : \u211d) < t\u27e9,   -- Archimedean property of \u211d.\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,\n  set y := u + 1 / (n : \u211d) with hy,\n  have h\u2086 : y \u2208 S,\n  { rw hy,\n    split,\n    { show 0 \u2264 u + 1 / (n : \u211d), linarith, },\n    { show (u + 1 / (n : \u211d)) ^ 2 < 2, from add_sq_lt_two_of_archi hne upos h\u2085, }, },\n  have h\u2087 : u < y, linarith,\n  given h\u2082 : \u2200 (x : \u211d), x \u2208 S \u2192 x \u2264 u,\n  have h\u2088 : y \u2264 u, from h\u2082 _ h\u2086,\n  show false, linarith,\n/- hint\nlet S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, -\u27e9,\nby_contra k,\ngiven k : \u00ac(2 \u2264 u ^ 2),\nhave h\u2084 : u ^ 2 < 2, linarith,\nlet t := ((2 : \u211d) - u ^ 2) / ((2 : \u211d) * u + 1),\nhave upos : 0 < u, from sqrt2_set_ub_pos h\u2082,\nhave h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nsorry,\n-/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, -\u27e9,\nby_contra k,\ngiven k : \u00ac(2 \u2264 u ^ 2),\nhave h\u2084 : u ^ 2 < 2, linarith,\nlet t := ((2 : \u211d) - u ^ 2) / ((2 : \u211d) * u + 1),\nhave upos : 0 < u, from sqrt2_set_ub_pos h\u2082,\nhave h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nsorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 49, "editorText": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nrcases h with \u27e8h\u2082 : is_upper_bound S u, -\u27e9,\nby_contra k,\ngiven k : \u00ac(2 \u2264 u ^ 2),\nhave h\u2084 : u ^ 2 < 2, linarith,\nlet t := ((2 : \u211d) - u ^ 2) / ((2 : \u211d) * u + 1),\nhave upos : 0 < u, from sqrt2_set_ub_pos h\u2082,\nhave h\u2085 : 0 < t, from div_pos (by linarith) (by linarith),\nsorry,", "lineOffset": 124, "name": "sqrt2_set_sup_sq_ge_2", "statement": "(u : \u211d) (h : is_sup {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2} u) :\n2 \u2264 u^2"}, {"type": "lean", "content": "1802", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "1803", "hidden": true}, {"type": "lean", "content": "1804", "hidden": true}, {"type": "text", "content": "1805"}, {"type": "lean", "content": "1806", "hidden": true}, {"type": "lean", "content": "1807", "hidden": true}, {"type": "lean", "content": "1808", "hidden": true}, {"type": "text", "content": "1809"}, {"type": "theorem", "text": "1810", "lean": "lemma exists_sqrt2 : \u2203 (u : \u211d), u ^ 2 = 2 :=\n", "sideBar": true, "firstProofLineNumber": 30, "firstProofHintLineNumber": 37, "lastProofHintLineNumber": 38, "lastProofLineNumber": 55, "textBefore": "import reals.sqrt2_set_sup_sq_ge_2 -- hide\n\n\nnamespace exlean -- hide\n\n/-\n# Real Numbers\n\n## Level 27: Proof of existence of a square root of 2\n-/\n \nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field set -- hide\n\n/-\n## Task\nYou've done all the hard work. It now remains to combine the results of the previous\nfew levels to prove the exists of a square root of 2!\n-/\n\n\n/- Theorem :\nThere is a real number $u$ such that $u ^ 2 = 2$.\n-/\nlemma exists_sqrt2 : \u2203 (u : \u211d), u ^ 2 = 2 :=\nbegin\n", "proof": "  let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\n  rcases sqrt2_set_has_sup with \u27e8u, h\u27e9,\n  use u,\n  apply le_antisymm,\n  { refine sqrt2_set_sup_sq_le_2 u h, },\n  { refine sqrt2_set_sup_sq_ge_2 u h, },\n/- hint\nlet S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nsorry,\n-/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nsorry,", "textAfter": "\nend\n\nend exlean -- hide", "height": 26, "editorText": "let S := {x : \u211d | 0 \u2264 x \u2227 x ^ 2 < 2},\nsorry,", "lineOffset": 29, "name": "exists_sqrt2", "statement": "\u2203 (u : \u211d), u ^ 2 = 2"}, {"type": "lean", "content": "1811", "hidden": true}]}], "parents": [4]}, {"name": "1812", "levels": [{"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "1813", "hidden": true}, {"type": "lean", "content": "1814", "hidden": true}, {"type": "lean", "content": "1815", "hidden": true}, {"type": "lean", "content": "1816", "hidden": true}, {"type": "lean", "content": "1817", "hidden": true}, {"type": "text", "content": "1818"}, {"type": "text", "content": "1819"}, {"type": "lean", "content": "1820", "hidden": false}, {"type": "text", "content": "1821"}, {"type": "lean", "content": "1822", "hidden": true}, {"type": "lean", "content": "1823", "hidden": false}, {"type": "lean", "content": "1824", "hidden": true}, {"type": "lean", "content": "1825", "hidden": false}, {"type": "lean", "content": "1826", "hidden": true}, {"type": "text", "content": "1827"}, {"type": "lean", "content": "1828", "hidden": true}, {"type": "theorem", "text": "1829", "lean": "theorem converges_const_comp (g : \u2115 \u2192 \u2115) :\nconverges_to (f \u2218 g) (5 : \u211d) :=\n", "sideBar": false, "firstProofLineNumber": 86, "lastProofLineNumber": 98, "textBefore": "import reals.sqrt2_exists -- hide\n\nnamespace exlean -- hide\n\nvariables {R : Type*} [myreal_field R] -- hide\n\nopen_locale myreal -- hide\n\nopen myreal_field -- hide\n\n/-\n# Sequences\n\n## Level 1: Convergence of a sequence\n\nA *sequence of real numbers* (henceforth a *sequence*) is simply \na function from $\\mathbb N$ to $\\mathbb R$.\n\nLet $a$ be a sequence. For $a$ to converge to a real number $w$\nmeans that:\n$$\n\\forall (\\varepsilon > 0), \\exists (N : \\mathbb N),\n\\forall (n > N), |a(n) - w |< \\varepsilon.\n$$\n\nThis is shorthand for:\n$$\n\\forall (\\varepsilon : \\mathbb R), \\varepsilon > 0 \\to\n\\exists (N : \\mathbb N), \\forall (n : \\mathbb N), \nn > N \\to |a(n) - w |< \\varepsilon.\n$$\n-/\n\n/-\nHere is the definition in Lean.\nNote that `\u03b5` is typed `\\e`.\n-/\n\n\ndef converges_to (a : \u2115 \u2192 \u211d) (w : \u211d) :=\n  \u2200 (\u03b5 > 0), \u2203 (N : \u2115), \u2200 (n > N), |a(n) - w| < \u03b5\n\n/-\nLet $f$ be the sequence defined by $f(n) := 5$. We'll show that\n$f$ converges to $5$.\n-/\n\nnamespace const_example -- hide\n\ndef f (n : \u2115) : \u211d := 5\n\n-- hide\n\nexample : converges_to f (5 : \u211d) :=\nbegin\n  assume (\u03b5 : \u211d) (\u03b5pos : \u03b5 > 0),\n  use 10,  -- There's nothing special about 10. \n  assume (n : \u2115) (h : n > 10),\n  show |f(n) - (5 : \u211d)| < \u03b5,\n  calc\n  | 5 - 5 | = 0 : by simp\n  ... < \u03b5       : \u03b5pos\nend\n\n\nend const_example -- hide\n\n/-\n## Task\n\nWith $f$ as above, suppose that $g : \\mathbb N \\to \\mathbb N$\nis a function. By adapting the argument above,\nprove that $f \\circ g$ converges to $5$.\n-/\n\nnamespace const_example -- hide\n\n\n/- Theorem : no-side-bar\nWith $f$ as above, suppose that $g : \\mathbb N \\to \\mathbb N$\nis a function. Then $f \\circ g$ converges to $5$.\n-/\ntheorem converges_const_comp (g : \u2115 \u2192 \u2115) :\nconverges_to (f \u2218 g) (5 : \u211d) :=\nbegin\n", "proof": "  assume (\u03b5 : \u211d) (\u03b5pos : \u03b5 > 0),\n  use 10,\n  assume (n : \u2115) (h : n > 10),\n  calc\n  | (f \u2218 g)(n) - (5 : \u211d)| \n      = |5 - 5|     : rfl\n  ... = 0           : by simp\n  ... < \u03b5           : \u03b5pos\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend const_example -- hide\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 85, "name": "converges_const_comp", "statement": "(g : \u2115 \u2192 \u2115) :\nconverges_to (f \u2218 g) (5 : \u211d)"}, {"type": "lean", "content": "1830", "hidden": true}, {"type": "lean", "content": "1831", "hidden": true}]}], "parents": [5]}, {"name": "1832", "levels": [{"name": "", "problemIndex": 22, "objects": [{"type": "lean", "content": "1833", "hidden": true}, {"type": "text", "content": "1834"}, {"type": "lean", "content": "1835", "hidden": true}, {"type": "lean", "content": "1836", "hidden": true}, {"type": "axiom", "content": "1837", "name": "strong_induction {P : \u2115 \u2192 Prop}", "sideBar": true}, {"type": "lean", "content": "1838", "hidden": true}, {"type": "text", "content": "1839"}, {"type": "text", "content": "1840"}, {"type": "text", "content": "1841"}, {"type": "text", "content": "1842"}, {"type": "text", "content": "1843"}, {"type": "lean", "content": "1844", "hidden": true}, {"type": "lean", "content": "1845", "hidden": false}, {"type": "text", "content": "1846"}, {"type": "tactic", "content": "1847", "name": "ring_exp", "sideBar": true}, {"type": "lean", "content": "1848", "hidden": false}, {"type": "text", "content": "1849"}, {"type": "text", "content": "1850"}, {"type": "text", "content": "1851"}, {"type": "lean", "content": "1852", "hidden": false}, {"type": "text", "content": "1853"}, {"type": "lean", "content": "1854", "hidden": false}, {"type": "theorem", "text": "1855", "lean": "theorem formula_for_g (n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n :=\n", "sideBar": false, "firstProofLineNumber": 247, "lastProofLineNumber": 281, "textBefore": "import tactic.linarith tactic.ring_exp tactic.modded strong_induction.basic -- hide\n\n/-\n# Strong Induction\n\n## Level 1: Strong induction\n\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\n/- Axiom : strong_induction {P : \u2115 \u2192 Prop}\n(h\u2081 : P(0))\n(h\u2082 : \u2200 (k : \u2115), (\u2200 m : \u2115, m \u2264 k \u2192 P(m)) \u2192 P (k + 1)) :\n\u2200 (n : \u2115), P(n)\n-/\n\nopen nat -- hide\n\n/-\nStrong induction is used to prove that a predicate $P$ holds for every natural number $n$.\nTo apply strong induction you need to prove:\n* [Base case] $P(0)$.\n* [Inductive step] For all $k : \u2115$, $P(k + 1)$ follows from the inductive hypothesis\nthat for all $m : \u2115$, if $m \\le k$, then $P(m)$ holds.\n-/\n\n/-\n### Strong induction example\n\nA sequence $f : \u2115 \u2192 \u2124$ is defined by $f(0) \u2254 2$, $f(1) \u2254 8$, and\n$f (n + 2) \u2254 8 f(n + 1) - 15 f(n)$.\n-/\n\n\n/-\nBy strong induction, we'll prove that $f(n) = 3^n + 5^n$, for every natural number $n$.\n\n\nTo start, we give a handwritten proof. In a less formal proof, there may be multiple\nbase cases. In the proof below, there is only one base case. However,  the induction step\nproceeds by considering separately the cases where $k = 0$ and where $k = p + 1$ for a\nnatural number $p$. The $k=0$ case corresponds to the 'additional base case' of proving\n$P(1)$ in a less formal proof.\n-/\n\n/-\n**Proof**:\n\nLet $P$ be the predicate defined so that\n$P(x)$ is $f(x) = 3 ^ x + 5 ^ x$.\n\n* Base case: We must show $P(0)$, namely, $f(0) = 3^0 + 5^0$.\n  This is true by definition of $f$.\n\n* Inductive step: Assume $k$ is a natural number. Assume\n  the inductive hypothesis: that for all natural numbers $m$, if\n  $m \\le k$, then $P(m)$.\n  We must show $P(k + 1)$.\n\n  Now $k$ is either $0$ or is of the form $p + 1$, for some natural\n  number $p$. Consider both cases separately.\n\n    * In the case where $k$ is $0$, we must show $P(0 + 1)$. Equally, that\n      $f(1) = 3^1 + 5 ^ 1$. This is true by definition of $f$.\n\n    * In the case where $k$ is $p+1$, the inductive hypothesis asserts\n      that for all natural numbers $m$, if $m \\le p + 1$, then\n      $P(m)$. We must show $P((p + 1) + 1)$.\n\n      Restating this, we know that for all natural numbers $m$,\n      if $m \\le p + 1$, then $f(m) = 3^m + 5^m$.\n\n      We must show $f(p + 2) = 3^{p + 2} + 5^{p + 2}$.\n\n      But,\n      $$\n      \\begin{align}\n      f(p + 2) &= 8f(p+1) - 15f(p) && \\text{[by definition of $f$]} \\\\\\\\\n      &= 8(3^{p+1}+5^{p+1}) - 15f(p) && \\text{[by the induction hypothesis, as $p + 1 \\le p + 1$]} \\\\\\\\\n      &= 8(3^{p+1}+5^{p+1}) - 15(3^p + 5^p) && \\text{[by the induction hypothesis, as $p \\le p + 1$]} \\\\\\\\\n      &= (24-15)3^p + (40 - 15)5^p && \\\\\\\\\n      &= 3^{p+2} + 5^{p+2}, &&\n      \\end{align}\n      $$\n\n      as required. \u220e\n-/\n\n\n/-\n### Strong induction in Lean\n\nAs an example of strong induction in Lean, we'll prove the result above.\nWe begin with a Lean definition of the function $f$.\n-/\n\nnamespace strong_sequence -- hide\n\ndef f : \u2115 \u2192 \u2124 \n| 0 := 2\n| 1 := 8\n| (n + 2) := 8 * f(n + 1) - 15 * f(n)\n\n/-\nThe above uses a defintion by *pattern matching* to construct a function `f : \u2115 \u2192 \u2124` to that\n`f(0) = 2`, `f(1) = 8`, and `f(n + 2) = 8 * f(n + 1) - 15 * f(n)`, for every natural number `n`.\n\nIn the Lean proof below, we start by definining the predicate `P` as an anonymous (or 'lambda') function.\nFor example `\u03bb x, x ^ 2` is the function that sends `x` to `x ^ 2`. We define `P` to be the predicate\nthat takes `x` to the proposition `f(x) = 3 ^ x + 5 ^ x`. Note `\u03bb` is typed `\\la` in Lean.\n\nHaving defined `P`, we prove both the base case (which I've called `base`) and the inductive step\n(which I've called `ind_step`). To conlude, we apply strong induction to these two hypotheses. \n\nIn the inductive step, we introduce the induction variable `k` and the induction hypothesis `ih`.\nNext, in a procedure common to proofs by induction, we consider cases for `k`.\n\nAs `k` is a natural number, either `k = 0` or `k` is the successor of some natural number `p`.\nIn the later case, we make things easy for ourselves by replacing `succ p` with `p + 1`.\n\nNote that we apply the induction hypothesis twice: once to `p + 1` and again to `p`.\n-/\n\n/- Tactic: ring_exp\n`ring_exp` is used to prove equations involving variable exponents.\n\n### Example\n```\nexample (x : \u2115) : \n  3 ^ x + 3 ^ (x + 1) = 4 * 3 ^ x :=\n  by ring_exp\n```\n-/\n\nexample (x : \u2115) : 3 ^ x + 3 ^ (x + 1) = 4 * 3 ^ x := by ring_exp\n\n\nexample (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,                    -- This is comment. It is ignored by Lean.\n  { show f(0) = 3 ^ 0 + 5 ^ 0,        -- Show P(0)\n    refl, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show f(1) = 3 ^ 1 + 5 ^ 1,      -- Show P(1)\n      refl, },\n    { given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 (f(m) = 3 ^ m + 5 ^ m),\n      show f(p + 2) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      calc\n      f(p + 2) = 8 * f(p + 1) - 15 * f(p)     : by refl\n      ... = 8*(3^(p + 1) + 5^(p+1)) - 15*f(p) : by rw ih (p + 1) (by linarith)\n      ... = 8*(3^(p + 1) + 5^(p+1)) -\n              15*(3^ p + 5 ^ p)               : by rw ih p (by linarith)\n      ... = 3 ^ (p + 2) + 5 ^ (p + 2)         : by ring_exp }, },\n  apply strong_induction base ind_step,\nend\n\n/-\nThe Lean proof is virtually a direct translation of the handwritten proof. There are two points\nworth noting.\n\n1.  The induction hypothesis, applied to a natural number `m`, requires a proof that `m \u2264 p + 1`.\n    In the proof by calculation, we consider the application `ih (p + 1) (by linarith)`. Here,\n    `p + 1` takes the place of `m` and `(by linarith)` automatically provides a proof of the\n    desired input `p + 1 \u2264 p + 1`. Likewise, in `ih p (by linarith)`, the text `(by linarith)`\n    produces a proof of `p \u2264 p + 1`.\n2.  The tactic `ring_exp` is used to do the 'algebra' in the last step. It can prove many\n    equations that involve variable exponents.\n-/\n\n/-\n### A backward alternative\n\nIn both the handwritten proof and the Lean proof, we ended with having to prove\n$f(p + 2) = 3^{p + 2} + 5^{p + 2}$ on the inductive hypothesis that for all natural numbers $m$,\nif $m \\le p + 1$, then $f(m) = 3^m + 5^m$. We did this by calculation.\n\nAn alternative is a backward proof, as below\n\n$$\n\\begin{align}\n&&      f(p + 2) &= 3^{p + 2} + 5^{p + 2}  && \\\\\\\\\n&\\iff & 8f(p + 1) - 15f(p) &= 3^{p + 2} + 5^{p + 2} && \\\\\\\n&\\iff & 8(3^{p + 1} + 5^{p + 1}) - 15f(p) &= 3^{p+2} + 5^{p+2} && \\text{[by the inductive hypothesis]}  \\\\\\\\\n&\\iff & 8(3^{p + 1} + 5^{p + 1}) - 15(3^p + 5^p) &= 3^{p+2} + 5^{p+2} && \\text{[by the inductive hypothesis]}  \\\\\\\\\n&\\iff & (24-15)3^p + (40-15)5^p &= 3^{p+2} + 5^{p+2}. &&\\text{[by algebra]}   \\\\\\\\\n\\end{align}\n$$\nThe last line is true by a simple numerical calculation.\n-/\n\n/-\nWe can write much the same proof in Lean. To save clutter our Lean proof below includes only\nthe justifications and does not show all the equations proved thereby.\n-/\n\nexample (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,                    -- The base case.\n  { show f(0) = 3 ^ 0 + 5 ^ 0,        \n    refl, },                          \n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show f(1) = 3 ^ 1 + 5 ^ 1,  \n      refl, },\n    { given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 (f(m) = 3 ^ m + 5 ^ m),\n      show f(p + 2) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      show 8 * f(p + 1) - 15 * f(p) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      rw ih (p + 1) (by linarith),  -- Replace f(p + 1) with 3^(p + 1) + 5^(p + 1)\n      rw ih p (by linarith),        -- Replace f(p) with 3^p + 5^p\n      ring_exp, }, },               -- Complete the inductive step by algebra\n  apply strong_induction base ind_step,\nend\n\n/-\n### Task\n\nA sequence $g : \\mathbb{N} \\to \\mathbb{Z}$ is defined by $g(0) \u2254 11$, $g(1) \u2254 26$, and\n$g(n + 2) \u2254 5g(n + 1) - 6g(n)$.\n\n* By adapting either of the `calc` or backward proofs above, prove that\n  $g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n* Do the same thing by hand.\n-/\n\ndef g : \u2115 \u2192 \u2124 \n| 0 := 11\n| 1 := 26\n| (n + 2) := 5 * g(n + 1) - 6 * g(n)\n\n/- Theorem : no-side-bar\n$g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n-/\ntheorem formula_for_g (n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n :=\nbegin\n", "proof": "  let P := \u03bb x, g(x) = 4 * 3 ^ x + 7 * 2 ^ x,\n  have base : P 0,\n  { show g(0) = 4 * 3 ^ 0 + 7 * 2 ^ 0,\n    refl, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    cases k with p,\n    { show g(1) = 4 * 3 ^ 1 + 7 * 2 ^ 1,\n      refl, },\n    { given ih : \u2200 (m : \u2115), m \u2264 p + 1 \u2192 (g(m) = 4 * 3 ^ m + 7 * 2 ^ m),\n      show g(p + 2) = 4 * 3 ^ (p + 2) + 7 * 2 ^ (p + 2),\n/-      show 5 * g(p + 1) - 6 * g(p) = 4 * 3 ^ (p + 2) + 7 * 2 ^ (p + 2),\n       rw ih (p + 1) (by linarith),\n      rw ih p (by linarith),\n      ring_exp, -/\n      calc\n      g(p + 2) = 5 * g(p + 1) - 6 * g(p) : by refl\n      ... = 5 * (4 * 3^(p + 1) + 7 * 2 ^ (p+1)) - 6 * g(p) : by rw ih (p + 1) (by linarith)\n      ... = 5*(4*3^(p + 1) + 7*2^(p+1)) - 6*(4*3^p + 7*2^p) : by rw ih p (by linarith)\n      ... = 4 * 3 ^ (p + 2) + 7 * 2 ^ (p + 2) : by ring_exp }, },\n  apply strong_induction base ind_step,\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend strong_sequence -- hide\n\n\n\nend exlean\n", "height": 35, "editorText": "sorry", "lineOffset": 246, "name": "formula_for_g", "statement": "(n : \u2115) : g(n) = 4 * 3 ^ n + 7 * 2 ^ n"}, {"type": "lean", "content": "1856", "hidden": true}, {"type": "lean", "content": "1857", "hidden": false}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1858", "hidden": true}, {"type": "text", "content": "1859"}, {"type": "lean", "content": "1860", "hidden": true}, {"type": "lean", "content": "1861", "hidden": true}, {"type": "lean", "content": "1862", "hidden": true}, {"type": "text", "content": "1863"}, {"type": "text", "content": "1864"}, {"type": "lean", "content": "1865", "hidden": false}, {"type": "text", "content": "1866"}, {"type": "lean", "content": "1867", "hidden": false}, {"type": "lean", "content": "1868", "hidden": true}, {"type": "lean", "content": "1869", "hidden": false}, {"type": "theorem", "text": "1870", "lean": "theorem three_mul_add_five_mul (n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t :=\n", "sideBar": false, "firstProofLineNumber": 122, "lastProofLineNumber": 166, "textBefore": "import tactic.linarith strong_induction.basic tactic.modded -- hide\n\n/-\n# Strong Induction\n\n## Level 2: Strong induction with a different base case\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\nopen nat -- hide\n\n/-\nOften we want to prove that a predicate holds for all sufficiently large natural numbers. Here,\nwe'll demonstrate that every natural number $n \\ge 2$ can be expressed in the form $n = 2 s + 3 t$\nfor natural numbers $s$ and $t$.\n\nOne approach to this is to think of the proof as involving strong induction where the base case\nis to prove the result for $n = 2$.\nThis approach requires creating a new and more general version of strong induction.\n\nInstead, our approach is to use the ordinary version of strong induction, but where the predicate\nasserts $c + 2 = 2 s + 3 t$. Clearly, to prove the result is to prove that this predicate holds\nfor *every* natural number.\n\n### An English-language proof\n\n**Theorem**: Every natural number $n \\ge 2$ can be expressed as $n = 2s + 3t$, for some\nnatural numbers $s$ and $t$.\n\n**Proof**: Let $n \\ge 2$ be a natural number. We must show there exist natural numbers $s$ and $t$\nsuch that $n = 2s + 3t$. But $n = c + 2$, for some natural number $c$. Thus, it suffices\nto prove there exists natural numbers $s$ and $t$ such that $c + 2 = 2s + 3t$.\n\nWe proceed by strong induction on $c$.\nLet $P$ denote the predicate defined so that $P(x)$ means there exists natural numbers $s$ and $t$\nsuch that $2 + x = 2s + 3t$.\n\n* Base case: we must show $P(0)$, that there exist integers $s$ and $t$ such that $0 + 2 = 2s + 3t$.\n  Clearly, taking $(s,t) = (1,0)$ suffices.\n\n* Inductive step: assume $k$ is a natural number. Assume the inductive hypothesis, that for\n  all natural numbers $m$, if $m \\le k$, then $P(m)$ holds. We must show $P(k + 1)$.\n\n  Now $k$ is either $0$ is has the form $p + 1$, for a natural number $p$. Consider both\n  cases separately.\n\n    * In the case where $k$ is $0$, we must show $P(0 + 1)$. That is, we must show\n      there exist natural numbers $s$ and $t$ such that $2 + 1 = 2s + 3t$.\n      Take $(s,t) = (0,1)$. Then the result is trivially true.\n    * In the case where $k$ is $p + 1$, the inductive hypothesis\n      states that for all natural numbers $m$, if $m \\le p + 1$, then $P(m)$ holds.\n      We must show $P(p + 2)$. That is, we must show there exist natural numbers $s$ and $t$\n      such that $2 + (p + 2) = 2s + 3t$.\n\n      As $p \\le p + 1$, we know $P(p)$ (from the inductive hypothesis). That is,\n      we know there exist natural numbers $x$ and $y$ such that $2 + p = 2x + 3y$.\n\n      But then,\n      $$\n      \\begin{align}\n      2 + (p + 2) &= (2 + p) + 2 \\\\\\\\\n      &= (2x + 3y) + 2 \\\\\\\\\n      &= 2(x + 1) + 3 y, \\\\\\\\\n      \\end{align}\n      $$\n      So we may take '$s$' to be $x + 1$ and '$t$' to be $y$. \u220e\n-/\n\n/-\n### A Lean proof\n\nTo begin the Lean proof, we convert the original problem, that of proving a result for all\n$n \\ge 2$, into a statement about all natural numbers $c$, where $n = c + 2$. \n\nTo translate between the original formulation and the new one, we use the result `le_iff_exists_add`.\nThis asserts `a \u2264 n` if and only if `\u2203 (c : \u2115), n = a + c`.\n-/\n\nexample (n a: \u2115) : a \u2264 n \u2194 \u2203 (c : \u2115), n = a + c := le_iff_exists_add\n\n\n/- \nThe remainder of the proof uses strong induction.\n-/\nexample (n : \u2115) (h : 2 \u2264 n) : \u2203 (s t : \u2115), n = 2 * s + 3 * t :=\nbegin\n  rw le_iff_exists_add at h, -- These two lines adjust the predicate\n  rcases h with \u27e8c, rfl\u27e9,     -- for the different base case.\n  show \u2203 (s t : \u2115), 2 + c = 2 * s + 3 * t,\n  -- hide\n  let P := \u03bb x, \u2203 (s t : \u2115), 2 + x = 2 * s + 3 * t,\n  have base : P 0,\n  { show \u2203 (s t : \u2115), 2 = 2 * s + 3 * t,    -- Show P(0)\n    use [1, 0],\n    show 2 = 2 * 1 + 3 * 0, norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show \u2203 (s t : \u2115), 3 = 2 * s + 3 * t,  -- Show P(1)\n      use [0, 1],\n      show 3 = 3 * 0 + 3 * 1, norm_num, },\n    show P(p + 2),                          -- Show P(p + 2)\n    given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 \u2203 (x y : \u2115), 2 + m = 2 * x + 3 * y,\n    have hpp : \u2203 (x y : \u2115), 2 + p = 2 * x + 3 * y, from ih p (by linarith),\n    rcases hpp with \u27e8x, y, hst : 2 + p = 2 * x + 3 * y\u27e9,\n    use [x + 1, y],\n    show 2 + (p + 2) = 2 * (x + 1) + 3 * y, linarith, },\n  apply strong_induction base ind_step,\nend\n\n/- Theorem : no-side-bar\nEvery natural number $n$ at least 8 can be expressed as $n = 3s + 5t$ for natural numbers $s$\nand $t$.\n-/\ntheorem three_mul_add_five_mul (n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t :=\nbegin\n", "proof": "  rw le_iff_exists_add at h, -- These two lines adjust for\n  rcases h with \u27e8c, rfl\u27e9,     -- the different base case.\n  show \u2203 (s t : \u2115), 8 + c = 3 * s + 5 * t,\n\n  let P := \u03bb x, \u2203 (s t : \u2115), 8 + x = 3 * s + 5 * t,\n  have base : P 0,\n  { use [1, 1],\n    norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n\n    show P(k + 1),\n    cases k with p,\n    { use [3, 0],\n      norm_num, },\n    cases p with y,\n    { use [0, 2],\n      norm_num, },\n    show P(y + 3),\n    given ih : \u2200 (m : \u2115), (m \u2264 y + 2) \u2192 \u2203 (s t : \u2115), 8 + m = 3 * s + 5 * t,\n    have hpy : \u2203 (s t : \u2115), 8 + y = 3 * s + 5 * t, from ih y (by linarith),\n    rcases hpy with \u27e8s, t, hst : 8 + y = 3 * s + 5 * t\u27e9,\n    use [s + 1, t],\n    show 8 + (y + 3) = 3 * (s + 1) + 5 * t,\n    linarith, },\n  apply strong_induction base ind_step,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 45, "editorText": "sorry", "lineOffset": 121, "name": "three_mul_add_five_mul", "statement": "(n : \u2115) (h : 8 \u2264 n) : \u2203 (s t : \u2115), n = 3 * s + 5 * t"}, {"type": "lean", "content": "1871", "hidden": true}]}, {"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "1872", "hidden": true}, {"type": "text", "content": "1873"}, {"type": "lean", "content": "1874", "hidden": true}, {"type": "text", "content": "1875"}, {"type": "lean", "content": "1876", "hidden": false}, {"type": "lean", "content": "1877", "hidden": true}, {"type": "text", "content": "1878"}, {"type": "lean", "content": "1879", "hidden": false}, {"type": "text", "content": "1880"}, {"type": "lean", "content": "1881", "hidden": false}, {"type": "text", "content": "1882"}, {"type": "lean", "content": "1883", "hidden": false}, {"type": "text", "content": "1884"}, {"type": "lean", "content": "1885", "hidden": false}, {"type": "lean", "content": "1886", "hidden": true}, {"type": "lean", "content": "1887", "hidden": true}, {"type": "text", "content": "1888"}, {"type": "hint", "content": "1889", "title": "1890"}, {"type": "hint", "content": "1891", "title": "1892"}, {"type": "theorem", "text": "1893", "lean": "lemma min_element_unique (h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y :=\n", "sideBar": true, "firstProofLineNumber": 103, "lastProofLineNumber": 120, "textBefore": "import data.set.basic strong_induction.basic tactic.linarith tactic.modded -- hide\n\n/-\n# Strong Induction\n\n## Level 3: Minimal elements\n-/\n\nnamespace exlean -- hide\n\n/-\nLet $S$ be a set of natural numbers. A natural number $n$ is said to be a _minimal element_ of $S$\nif $n \\in S$ and for every every $m \\in S$, $n \\le m$.\n-/\n\nexample (n : \u2115) (S : set \u2115) (h : min_element n S ) :\nn \u2208 S \u2227 (\u2200 (m : \u2115), m \u2208 S \u2192 n \u2264 m) := h\n\nnamespace min_element_example -- hide\n\n/-\nLet the function $f : \\mathbb N \\to \\mathbb N$ be given by $f(x) = 5 x + 7$ and let $T$ be the set\nof natural numbers $x$ for which $f(x) \\ge 400$.\n-/\n\ndef f (x : \u2115) := 5 * x + 7\n\ndef T : set \u2115 := {x : \u2115 | f x \u2265 400}\n\n/-\nWe'll show that $79$ is a minimal element of $T$. To do this, we split the target into two goals:\n1. to prove $79 \\in T$ and\n2. to prove that every element of $T$ is at least $79$.\n-/\n\nexample : min_element 79 T :=\nbegin\n  split, \n  { show 5 * 79 + 7 \u2265 400,\n    norm_num, }, -- This follows by arithmetic.\n  { show \u2200 (m : \u2115), 5 * m + 7 \u2265 400 \u2192 79 \u2264 m,\n    assume m : \u2115,\n    assume h : m \u2208 T,\n    linarith, },\nend\n\n/-\nIn the example above, we proved a `min_element` statement. In the next examples, we'll use\n`min_element` hypotheses.\n\nFirst, suppose $S$ is a set of natural numbers and that the natural number $x$ is a minimal\nelement of $S$. We can deduce that $x \\in S$.\n-/\n\nexample (S : set \u2115) (x : \u2115) (h : min_element x S) : x \u2208 S :=\nbegin\n  from h.left,\nend\n\n/-\nNow suppose $S$ is a set of natural numbers and that $8$ is a minimal element of $S$.\nWe'll show that $8 \\le s$, for all $s \\in S$.\n-/\n\nexample (S : set \u2115) (h : min_element 8 S) : \u2200 (s \u2208 S), 8 \u2264 s :=\nbegin\n  from h.right,\nend\n\nend min_element_example -- hide\n\nvariables {S : set \u2115} {x y : \u2115} -- hide\n\n/-\n### Task\n\nProve uniquenss of minimal element. For this level, you won't need induction.\n-/\n\n/- Hint : A useful lemma on inequalities\nThe Lean lemma `le_antisymm` asserts that `x = y` follows given `x \u2264 y` and `y \u2264 x`.\n-/\n\n/- Hint : A proof template\nTry this:\n```\nrcases h\u2081 with \u27e8hxin : x \u2208 S, hxmin : \u2200 (s \u2208 S), x \u2264 s\u27e9,\nrcases h\u2082 with \u27e8hyin : y \u2208 S, hymin : \u2200 (s \u2208 S), y \u2264 s\u27e9,\napply le_antisymm,\n{ show x \u2264 y,\n  sorry, },\n{ show y \u2264 x,\n  sorry },\n```\n\n-/\n\n/- Theorem : \nIf a set $S$ of natural numbers has a minimal element, then that element is unique.\n-/\nlemma min_element_unique (h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y :=\nbegin\n", "proof": "  rcases h\u2081 with \u27e8hxin : x \u2208 S, hxmin : \u2200 (s \u2208 S), x \u2264 s\u27e9,\n  rcases h\u2082 with \u27e8hyin : y \u2208 S, hymin : \u2200 (s \u2208 S), y \u2264 s\u27e9,\n  apply le_antisymm,\n  { from hxmin y hyin, },\n  { from hymin x hxin, },\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 102, "name": "min_element_unique", "statement": "(h\u2081 : min_element x S) (h\u2082 : min_element y S) : x = y"}, {"type": "lean", "content": "1894", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "1895", "hidden": true}, {"type": "text", "content": "1896"}, {"type": "lean", "content": "1897", "hidden": true}, {"type": "lean", "content": "1898", "hidden": true}, {"type": "lean", "content": "1899", "hidden": true}, {"type": "text", "content": "1900"}, {"type": "text", "content": "1901"}, {"type": "lean", "content": "1902", "hidden": false}, {"type": "hint", "content": "1903", "title": "1904"}, {"type": "hint", "content": "1905", "title": "1906"}, {"type": "tactic", "content": "1907", "name": "tidy", "sideBar": true}, {"type": "hint", "content": "1908", "title": "1909"}, {"type": "hint", "content": "1910", "title": "1911"}, {"type": "hint", "content": "1912", "title": "1913"}, {"type": "theorem", "text": "1914", "lean": "lemma well_ordering_principle {S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S :=\n", "sideBar": true, "firstProofLineNumber": 104, "lastProofLineNumber": 148, "textBefore": "import data.set.basic tactic.norm_num tactic.linarith strong_induction.basic tactic.modded -- hide\n\n/-\n# Strong Induction\n\n## Level 4: The Well Ordering Principle\n-/\n\nnamespace exlean -- hide\n\nopen_locale classical -- hide\n\nopen set nat --hide\n\n/-\nIn the previous level, we show that if a set $S$ of natural numbers has a minimal element, then\nthat element is unique.\n\nIn this level, you'll show that every non-empty set of natural numbers has a minimal element. The\n(challenging) proof requires strong induction.\n-/\n\n/-\n### Nonempty sets\n\nIn Lean, a set `S` is nonempty if `\u2203 x, x \u2208 S`.\n\nAs an example, consider the set $\\\\{x : \\mathbb N \\mid x ^ 2 + 2x + 15 = 0\\\\}$. We'll show this set\nis nonempty.\n-/\n\n\nexample : set.nonempty {x : \u2115 | x * x + 2 * x = 15} :=\nbegin\n  use 3, -- Take 3 for `x`.\n  show 3 * 3 + 2 * 3 = 15,\n  norm_num,\nend\n\n\n/- Hint : How to start!\nStart with proof by contradiction. Type `by_contra h\u2081`.\nThen push the negation through the quantifiers with `push_neg at h\u2081`.\n-/\n\n/- Hint : How to introduce strong induction\nIf you've taken the hint above, your goal now will be to prove `false`. This isn't evidently \nsomething amenable to strong induction!\n\nHowever, you can show that it suffices to prove `\u2200 (x : \u2115), x \u2209 S` by filling in the `sorry` below\n(the `tidy`  tactic can help with this).\n```\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ sorry, },\n```\nThis leaves you with the goal of proving, by strong induction, that `\u2200 (x : \u2115), x \u2209 S`.\n-/\n\n/- Tactic: tidy\nThe `tidy` tactic calls on a small set of other tactics to try to close the goal.\nIf a goal can be proved in a fairly straightforward manner from the assumptions, the\n`tidy` tactic can sometimes find a proof.\n-/\n\n/- Hint: Using the `tidy` tactic\nThe `tidy` tactic calls on a small set of other tactics to try to close the goal.\nIn this problem, if you have proved there is a natural number that is less that 0,\n`tidy` can derive a contradiction.\n-/\n\n/- Hint : Proving inequalities\nRecall that you can use `linarith` to prove inequalities. For example,\nif you know `m < k + 1` (for natural numbers `m` and `k`), then you can\nintroduce the hypothesis `hm : m \u2264 k` via\n```\nhave hm : m \u2264 k, by linarith,\n```\n-/\n\n/- Hint : A proof template\nIf you get stuck, try the following:\n```\nby_contra h\u2081,\ngiven h\u2081 : \u00ac\u2203(n : \u2115), (n \u2208 S \u2227 (\u2200 (m \u2208 S), n \u2264 m)),\npush_neg at h\u2081,\ngiven h\u2081 : \u2200 (n : \u2115), n \u2208 S \u2192 (\u2203 (m : \u2115), m \u2208 S \u2227 m < n),\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ rcases h with \u27e8d, h : d \u2208 S\u27e9,\n  sorry, },\nlet P := \u03bb x, x \u2209 S,\nhave base : P 0,\n{ sorry, },\nhave ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n{ sorry, },\napply strong_induction base ind_step,\n```\n-/\n\n/- Theorem :\nEvery nonempty set of natural numbers has a minimal element.\n-/\nlemma well_ordering_principle {S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S :=\nbegin\n", "proof": "  by_contra h\u2081,\n  given h\u2081 : \u00ac\u2203(n : \u2115), (n \u2208 S \u2227 (\u2200 (m \u2208 S), n \u2264 m)),\n  push_neg at h\u2081,\n  given h\u2081 : \u2200 (n : \u2115), n \u2208 S \u2192 (\u2203 (m : \u2115), m \u2208 S \u2227 m < n),\n  suffices hs : \u2200 (x : \u2115), x \u2209 S,\n  { rcases h with \u27e8d, h : d \u2208 S\u27e9,\n    from hs d h, },\n  let P := \u03bb x, x \u2209 S,\n  have base : P 0,\n  { show 0 \u2209 S,\n    assume h\u2083 : 0 \u2208 S,\n    have h\u2084 : \u2203 (m : \u2115), m \u2208 S \u2227 m < 0, from h\u2081 0 h\u2083,\n    tidy, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P(m),\n    given ih : \u2200 (m : \u2115), m \u2264 k \u2192 m \u2209 S,\n    show k + 1 \u2209 S,\n    assume h\u2082 : k + 1 \u2208 S, \n    have h\u2083 : \u2203 (m : \u2115), m \u2208 S \u2227 m < k + 1, from h\u2081 (k + 1) h\u2082,\n    rcases h\u2083 with \u27e8m, h\u2084 : m \u2208 S, h\u2085 : m < k + 1\u27e9,\n    have hm : m \u2264 k, by linarith,\n    from ih m hm h\u2084, },\n  apply strong_induction base ind_step,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 45, "editorText": "sorry", "lineOffset": 103, "name": "well_ordering_principle", "statement": "{S : set \u2115} (h : S.nonempty) : \u2203 (n : \u2115), min_element n S"}, {"type": "lean", "content": "1915", "hidden": true}]}]}, {"name": "1916", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "1917", "hidden": true}, {"type": "text", "content": "1918"}, {"type": "lean", "content": "1919", "hidden": true}, {"type": "lean", "content": "1920", "hidden": true}, {"type": "text", "content": "1921"}, {"type": "tactic", "content": "1922", "name": "use", "sideBar": true}, {"type": "lean", "content": "1923", "hidden": false}, {"type": "tactic", "content": "1924", "name": "norm_num", "sideBar": true}, {"type": "text", "content": "1925"}, {"type": "text", "content": "1926"}, {"type": "theorem", "text": "1927", "lean": "theorem six_dvd_seventy_two : (6 : \u2124) \u2223 72 :=\n", "sideBar": false, "firstProofLineNumber": 65, "lastProofLineNumber": 71, "textBefore": "import tactic.ring tactic.modded -- hide\n\n/-\n#  Divisibility\n\n## Level 1: The definition of divisibility\n\nThe notation `x \u2223 y` means `\u2203 (m : \u2124), y = x * m`. Here, the symbol, `\u2223` is typed `\\|` or `\\mid`.\n-/\n\n\nnamespace exlean -- hide\n\ndef myint_dvd : \u2124 \u2192 \u2124 \u2192 Prop := \u03bb (x y : \u2124), \u2203 (m : \u2124), y = x * m -- hide\n\n/-\nFor example, we will prove that `5 \u2223 10`. We begin by nothing that the target is to show\n`\u2203 (m : \u2124), 10 = 5 * m`. \n\nIt remains to *find* an `m` that works. Let's use `2`. After that, we must prove `10 = 5 * 2`. But\nthis follows by definition of multiplication. A `norm_num` proof works.\n-/\n\n/- Tactic : use\nIf the target is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the target to\n`\u22a2 P y`.\n\n### Example\nWith a target `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the target to `\u22a2 18 + 5 = 23`.\n-/\n\nexample : (5 : \u2124) \u2223 10 :=\nbegin\n  show \u2203 (m : \u2124), 10 = 5 * m,\n  use 2, -- \u22a2 10 = 5 * 2\n  norm_num,\nend\n\n/- Tactic : norm_num\n\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n-/\n\n/-\nIf you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n-/\n\n/-\n### Tasks\n* By making a minor variation to the proof above, show that `6 \u2223 72`.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem : no-side-bar\n`6 divides 72`\n-/\ntheorem six_dvd_seventy_two : (6 : \u2124) \u2223 72 :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 72 = 6 * m,\n  use 12, -- \u22a2 72 = 6 * 12 \n  norm_num,\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 7, "editorText": "sorry", "lineOffset": 64, "name": "six_dvd_seventy_two", "statement": "(6 : \u2124) \u2223 72"}, {"type": "lean", "content": "1928", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "1929", "hidden": true}, {"type": "text", "content": "1930"}, {"type": "lean", "content": "1931", "hidden": true}, {"type": "text", "content": "1932"}, {"type": "hint", "content": "1933", "title": "1934"}, {"type": "theorem", "text": "1935", "lean": "theorem dvd_refl (a : \u2124) : a \u2223 a :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 37, "textBefore": "import tactic.linarith divisibility.dvd_definition -- hide\n\n/-\n#  Divisibility\n\n## Level 2: Reflexivity of divisibility\n-/\n\nnamespace exlean --hide\n\n/-\nIn this short level, your task is to prove reflexvity of the divisiblity relation.\n-/\n\n/- Hint : How to start the proof\nAs in the previous level, a good starting point is to rephrase the target\nof showing `a \u2223 a` using the definition of divisibility. That is, you must\nshow $\\exists m,\\ a = am$.\n\nYou are left with the task of proving an existentially-quantified statement.\nTherefore, you must exhibit an integer $m$ together with a proof of $a = am$.\n-/\n\n/- Theorem :\n`a \u2223 a`, for every integer `a`.\n-/\ntheorem dvd_refl (a : \u2124) : a \u2223 a :=\nbegin\n", "proof": "  show \u2203 m, a = a * m,\n  use 1, -- \u22a2 a = a * 1\n  norm_num,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 28, "name": "dvd_refl", "statement": "(a : \u2124) : a \u2223 a"}, {"type": "lean", "content": "1936", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "1937", "hidden": true}, {"type": "text", "content": "1938"}, {"type": "lean", "content": "1939", "hidden": true}, {"type": "text", "content": "1940"}, {"type": "theorem", "text": "1941", "lean": "theorem dvd_zero (a : \u2124) : a \u2223 0 :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 32, "textBefore": "import tactic.linarith divisibility.dvd_refl -- hide\n\n/-\n#  Divisibility\n\n## Level 3: Every number is a factor of zero\n-/\n\nnamespace exlean --hide\n\n\n\n/-\n### Task\nProve that every number is a factor of zero. You can do this using the style of proof required\nfor the previous two levels.\n-/\n\n/- Theorem :\nLet `a` be an integer. Then `a \u2223 0`.\n-/\ntheorem dvd_zero (a : \u2124) : a \u2223 0 :=\nbegin\n", "proof": "  show \u2203 (m : \u2124), 0 = a * m,\n  use 0, -- \u22a2 0 = a * 0\n  norm_num,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 9, "editorText": "sorry", "lineOffset": 23, "name": "dvd_zero", "statement": "(a : \u2124) : a \u2223 0"}, {"type": "lean", "content": "1942", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "1943", "hidden": true}, {"type": "text", "content": "1944"}, {"type": "lean", "content": "1945", "hidden": true}, {"type": "text", "content": "1946"}, {"type": "text", "content": "1947"}, {"type": "lean", "content": "1948", "hidden": true}, {"type": "axiom", "content": "1949", "name": "dvd_add", "sideBar": true}, {"type": "lean", "content": "1950", "hidden": false}, {"type": "tactic", "content": "1951", "name": "cases", "sideBar": true}, {"type": "tactic", "content": "1952", "name": "linarith", "sideBar": true}, {"type": "text", "content": "1953"}, {"type": "text", "content": "1954"}, {"type": "theorem", "text": "1955", "lean": "theorem dvd_mul_of_dvd_left (h : a \u2223 b) (c : \u2124) : a \u2223 b * c :=\n", "sideBar": true, "firstProofLineNumber": 107, "lastProofLineNumber": 127, "textBefore": "import tactic.linarith divisibility.dvd_zero tactic.modded -- hide\n\n/-\n#  Divisibility\n\n## Level 4: A multiplication lemma\n-/\n\nnamespace exlean --hide\n\n/-\nIn the last level, you *proved* a divisibility statement. In this level, you'll *decompose* given\ndivisibility statements.\n\nTo prove a statement of the form `x \u2223 y` is to prove an existentially-quantified statement.\nYou do this by exists introduction (the `use` tactic in Lean).\n\nOn the other hand, if `h` is the hypothesis `a \u2223 b`, then `h` is a proof of the\nexistentially-quantified statement `\u2203 (m : \u2124), b = a * m`. You can decompose `h`into to an integer\n`k` and a hypothesis `h\u2082 : b = a * k` via `cases h with m h\u2082`.\nIn handwritten mathematics, this is exists elimination.\n-/\n\n/-\n### An addition result\n\nBelow, I present a proof that given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, then `a \u2223 b + c` follows.\n\nThe use of `given` tactics isn't strictly necessary, but is useful\nin ensuring you understand the definitions.\n-/\n\nvariables {a b c d : \u2124} -- hide\n\n/- Axiom : dvd_add\n(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c\n-/\ntheorem dvd_add (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c :=\nbegin\n  given h\u2081 : \u2203 m\u2081, b = a * m\u2081,\n  -- By definition, `h\u2081 : \u2203 m\u2081, b = a * m\u2081`\n  cases h\u2081 with m\u2081 h\u2083, -- This gives `m\u2081 : \u2124` and\n  given h\u2083 : b = a * m\u2081, -- `h\u2083 : b = a * m\u2081`.\n  cases h\u2082 with m\u2082 h\u2084, -- This gives `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n  show \u2203 m, b + c = a * m,\n  use (m\u2081 + m\u2082), -- Take `m\u2081 + m\u2082` for `m`.\n  show b + c = a * (m\u2081 + m\u2082),\n  calc\n  b + c = (a * m\u2081) + (a * m\u2082) : by rw [h\u2083, h\u2084]\n    ... = a * (m\u2081 + m\u2082)       : by linarith,\nend\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n-/\n\n\n/- Tactic : linarith\n`linarith` proves many 'algebraic' equations and inequalities. For example, it can prove\n`(x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2`. It can pr\n-/\n\n/-\nExtracing the comments from the above gives a handwritten proof:\n\n> From `h_1` and `h_2`, we are given `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`, and we are given  `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n> We must show `\u2203 (m : \u2124), b + c = a * m`.\n>\n> Take `m\u2081 + m\u2082` for `m`. We must show `b + c = a * (m\u2081 + m\u2082)`.\n> But\n> $$\n> \\begin{align}\n> b + c &= (a \\times m_1) + (a \\times m_2) && \\text{[from $h_3,\\ h_4$]} \\\\\\\\\n>  & = a \\times (m_1 + m_2), && \n> \\end{align}\n> $$\n> completing the proof. \u220e\n-/\n\n/-\n### Tasks\n* Adapting the Lean proof above, show that if `h : a \u2223 b`, then `a \u2223 b * c` for all integers `c`.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem :\nLet `a, b` be integers. Given `h : a \u2223 b`, we have `a \u2223 b * c`, for all integers `c`.\n-/\ntheorem dvd_mul_of_dvd_left (h : a \u2223 b) (c : \u2124) : a \u2223 b * c :=\nbegin\n", "proof": "  show \u2203 m, b * c = a * m,\n  given h : \u2203 n, b = a * n,\n  cases h with n h\u2082,\n  given h\u2082 : b = a * n,\n  use n * c,\n  show b * c = a * (n * c),\n  calc\n  b * c = (a * n) * c : by rw h\u2082\n    ... = a * (n * c) : by linarith,\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 106, "name": "dvd_mul_of_dvd_left", "statement": "(h : a \u2223 b) (c : \u2124) : a \u2223 b * c"}, {"type": "lean", "content": "1956", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "1957", "hidden": true}, {"type": "text", "content": "1958"}, {"type": "lean", "content": "1959", "hidden": true}, {"type": "text", "content": "1960"}, {"type": "text", "content": "1961"}, {"type": "hint", "content": "1962", "title": "1963"}, {"type": "hint", "content": "1964", "title": "1965"}, {"type": "lean", "content": "1966", "hidden": true}, {"type": "theorem", "text": "1967", "lean": "lemma zero_dvd_iff : 0 \u2223 a \u2194 a = 0 :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 71, "textBefore": "import tactic.linarith divisibility.dvd_mul_of_dvd_left -- hide\n\n/-\n#  Divisibility\n\n## Level 5: Numbers divisible by zero\n-/\n\nnamespace exlean --hide\n\n/-\nWhich numbers are divisible by zero? You'll prove that a number is divisible by zero if and only \nif that number is itself zero.\n-/\n\n\n/-\n### Tasks\nLet $a$ be an integer. Prove that $a$ is divisibile by $0$ if and only if $a = 0$.\n-/\n\n/- Hint: A proof template\nTry this to begin with.\n```\nsplit,\n{ show 0 \u2223 a \u2192 a = 0,\n  sorry, },\n{ show a = 0 \u2192 0 \u2223 a,\n  sorry, },\n```\n-/\n\n/- Hint : Proof ideas\n\nWhile completing the proof of each `sorry`, ask yourself: what *kind* of statement am I being\nasked to prove? What is the context? Remember you can rephrase hypotheses using `given`\nand rephrase the target using `show`.\n\nYou can decompose an existentially-quantified hypothesis using `cases` (as in the previous level).\nThe `linarith` tactic will use any equations and inequalities in the context to try to prove the\ntarget.\n-/\n\nvariables {a : \u2124} -- hide\n\n/- Theorem :\nLet $a$ be an integer. Then $a$ is divisibile by $0$ if and only if $a = 0$.\n-/\nlemma zero_dvd_iff : 0 \u2223 a \u2194 a = 0 :=\nbegin\n", "proof": "  split,\n  { show 0 \u2223 a \u2192 a = 0,\n    assume h : 0 \u2223 a,\n    given h : \u2203 (m : \u2124), a = 0 * m,\n    cases h with m h,\n    given h : a = 0 * m,\n    show a = 0, linarith, },\n  { show a = 0 \u2192 0 \u2223 a,\n    assume h : a = 0,\n    use 0,\n    show a = 0 * 0, linarith, },\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 50, "name": "zero_dvd_iff", "statement": "0 \u2223 a \u2194 a = 0"}, {"type": "lean", "content": "1968", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "1969", "hidden": true}, {"type": "text", "content": "1970"}, {"type": "lean", "content": "1971", "hidden": true}, {"type": "lean", "content": "1972", "hidden": true}, {"type": "text", "content": "1973"}, {"type": "text", "content": "1974"}, {"type": "theorem", "text": "1975", "lean": "theorem mul_dvd_mul (h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 47, "textBefore": "import tactic.linarith divisibility.zero_dvd_iff-- hide\n\n/-\n#  Divisibility\n\n## Level 6: A second multiplication lemma\n-/\n\nnamespace exlean --hide\n\n\nvariables {a b c d : \u2124} -- hide\n\n/-\n### Tasks\n* Adapting the Lean proof of `dvd_add` from a previous level, show that if `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, then\n`a * c \u2223 b * d`.\n\n* Write the same proof by hand.\n-/\n\n/-\n### Typing subscripts\n\nIn Lean, type `h\u2081` as `h\\1`.\n-/\n\n/- Theorem :\nLet `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n-/\ntheorem mul_dvd_mul (h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d :=\nbegin\n", "proof": "  rcases h\u2081 with \u27e8m\u2081, h\u2081 : b = a * m\u2081\u27e9,\n  rcases h\u2082 with \u27e8m\u2082, h\u2082  : d = c * m\u2082\u27e9,\n  show \u2203 (m : \u2124), b * d = (a * c) * m,\n  use (m\u2081 * m\u2082),\n  show b * d = (a * c) * (m\u2081 * m\u2082),\n  calc\n  b * d = (a * m\u2081) * (c * m\u2082)  : by rw [h\u2081, h\u2082]\n    ... = (a * c) * (m\u2081 * m\u2082)  : by linarith,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 32, "name": "mul_dvd_mul", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : c \u2223 d) : a * c \u2223 b * d"}, {"type": "lean", "content": "1976", "hidden": true}]}, {"name": "", "problemIndex": 17, "objects": [{"type": "lean", "content": "1977", "hidden": true}, {"type": "text", "content": "1978"}, {"type": "lean", "content": "1979", "hidden": true}, {"type": "text", "content": "1980"}, {"type": "text", "content": "1981"}, {"type": "lean", "content": "1982", "hidden": true}, {"type": "lean", "content": "1983", "hidden": false}, {"type": "text", "content": "1984"}, {"type": "text", "content": "1985"}, {"type": "lean", "content": "1986", "hidden": false}, {"type": "text", "content": "1987"}, {"type": "lean", "content": "1988", "hidden": false}, {"type": "text", "content": "1989"}, {"type": "lean", "content": "1990", "hidden": false}, {"type": "tactic", "content": "1991", "name": "apply", "sideBar": true}, {"type": "text", "content": "1992"}, {"type": "text", "content": "1993"}, {"type": "theorem", "text": "1994", "lean": "theorem dvd_mul_add_mul (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t :=\n", "sideBar": true, "firstProofLineNumber": 143, "lastProofLineNumber": 154, "textBefore": "import tactic.linarith divisibility.mul_dvd_mul -- hide\n\n/-\n#  Divisibility\n\n## Level 7: Divisibility of linear combinations\n-/\n\nnamespace exlean --hide\n\n/-\nHere are some of the properties of the divisibility relation that you've seen so far:\n\n* [Definition] `a \u2223 b` means `\u2203 (m : \u2124), b = a * m`.\n\n* [Reflexivity] `dvd_refl : a \u2223 a`.\n\n* `dvd_add` given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b + c`.\n\n* `dvd_mul_of_dvd_left` given `h : a \u2223 b`, we have `a \u2223 b * c`, for any `c : \u2124`.\n\nIn this level, you will *use* those results to prove other theorems.\n\nAs an example, let's consider how you might prove a new addition result.\n\n**Theorem**: $a \\mid (b + c) + d$ follows given that $a$ divides $b$, $c$, and $d$.\n-/\n\n/-\nHere is a 'forward' proof.\n\n**Proof**: From $a \\mid b$ and $a \\mid c$, we have $a \\mid b + c$. Using this, with the proof\nof $a\\mid d$, gives a proof of $a \\mid (b + c) + d$. \u220e\n\nI call this a 'forward' proof as it invovles adding hypotheses to the context until we have\nenough hypotheses to complete the goal.\n\nHere is the same proof in Lean.\n-/\n\nvariables {a b c d s t : \u2124} -- hide\n\nexample (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  have h\u2084 : a \u2223 b + c, from dvd_add h\u2081 h\u2082,\n  show a \u2223 (b + c) + d, from dvd_add h\u2084 h\u2083,\nend\n\n/-\nContrast this with a 'backward' proof of the same result.\n\n**Proof**: By properties of divisibility, it suffices to show $a \\mid b + c$ and $a \\mid d$.\nTo prove the first of these, it suffices to show $a \\mid b$ and $a \\mid c$. Both of these\nare assumptions. The last requirement, that $a \\mid d$, is also an assumption. \u220e\n\nI call this proof 'backward' as it breaks the main goal into smaller subgoals and deals with\neach of those in turn.\n-/\n\n/-\nHow do we do this in Lean?\n\nIf we had proof of `a \u2223 (b + c)` and a proof of `a \u2223 d`, we could feed these into `dvd_add` to\ngive a proof of `a \u2223 (b + c) + d`.\n\nTo do this backward, `apply dvd_add` transforms the goal of proving `a \u2223 (b + c)` into\ntwo subgoals: to prove `a \u2223 b + c` and to prove `a \u2223 d`.\n\nThe resulting proof is longer, but has the advantage that no additional hypotheses are added\nto the context. It is often mentally easier to break down a large goal into smaller goals\nthan to construct a proof from the ground up.\n-/\n\nexample (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add,    -- 2 goals `\u22a2 a \u2223 b + c` and `\u22a2 a \u2223 d`\n  { show a \u2223 b + c, -- Goal 1.  \n    apply dvd_add,  -- 2 subgoals `\u22a2 a \u2223 b` and `\u22a2 a \u2223 c`\n    { show a \u2223 b, \n      from h\u2081, },\n    { show a \u2223 c,\n      from h\u2082, }, },\n  { show a \u2223 d,     -- Goal 2.\n    from h\u2083, },\nend\n\n/-\nThe same proof can be written more concisely via a forward application of `dvd_add` in the first\ngoal.\n-/\n\nexample (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add,    \n  { show a \u2223 b + c,\n    from dvd_add h\u2081 h\u2082, },\n  { show a \u2223 d,\n    from h\u2083, },\nend\n\n/-\nOr, to be *really* terse, you can do everything forward. As a downside, the proof is harder to\nunderstand.\n-/\n\nexample (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  from dvd_add (dvd_add h\u2081 h\u2082) h\u2083,\nend\n\n/- Tactic : apply\nMost theorems have conditions under which they hold. For example, `dvd_add` states that\n`a \u2223 b + c` given the conditions `a \u2223 b` and `a \u2223 c`. If the target is `\u22a2 a \u2223 b + c`, then\ntyping `apply dvd_add` creates two new goals: (1) to prove `a \u2223 b` and (2) to prove `a \u2223 c`.\n\nThe use of `apply` can be shortened. If the hypotheses `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c` are in the\ncontext, then the target `a \u2223 b + c` can be proved with `apply dvd_add h\u2081 h\u2082`.\n-/\n\n/-\n### Tasks\n* By applying some of the results above, prove that if `a \u2223 b` and `a \u2223 c`, then `a` divides any\nlinear combination of `b` and `c`. That is, `a \u2223 b * s + c * t`, for all integers `s` and `t`. \n\n* Write the same proof by hand.\n\n* Give a backward proof if you've already written a forward proof. And vice-versa.\n-/\n\n/-\nIf you were writing this proof by hand, you might start by saying that it suffices (by `dvd_add`)\nto prove `a \u2223 b * s` and `a \u2223 c * t`. To do this in Lean, type `apply dvd_add`. Here's an\nexample of this kind of reasoning.\n-/\n\n\n\n/- Theorem :\nGiven `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b * s + c * t`, for all integers `s` and `t`.\n-/\ntheorem dvd_mul_add_mul (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t :=\nbegin\n", "proof": "  apply dvd_add,\n  { apply dvd_mul_of_dvd_left h\u2081, },\n  { apply dvd_mul_of_dvd_left h\u2082, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 12, "editorText": "sorry", "lineOffset": 142, "name": "dvd_mul_add_mul", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b * s + c * t"}, {"type": "lean", "content": "1995", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "1996", "hidden": true}, {"type": "text", "content": "1997"}, {"type": "lean", "content": "1998", "hidden": true}, {"type": "lean", "content": "1999", "hidden": true}, {"type": "theorem", "text": "2000", "lean": "theorem dvd_trans (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 37, "textBefore": "import tactic.linarith divisibility.dvd_mul_add_mul-- hide\n\n/-\n#  Divisibility\n\n## Level 8: Transtivity of divisibility\n-/\n\nnamespace exlean --hide\n\nvariables {a b c : \u2124} -- hide\n\n/- Theorem :\nLet `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : b \u2223 c`, we have `a \u2223 c`.\n-/\ntheorem dvd_trans (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c :=\nbegin\n", "proof": "  rcases h\u2081 with \u27e8m\u2081, h\u2081 : b = a * m\u2081\u27e9,\n  rcases h\u2082 with \u27e8m\u2082, h\u2082 : c = b * m\u2082\u27e9,\n  show \u2203 (m : \u2124), c = a * m,\n  use m\u2081 * m\u2082,\n  show c = a * (m\u2081 * m\u2082),\n  calc\n  c   = b * m\u2082          : by rw h\u2082\n  ... = (a * m\u2081) * m\u2082   : by rw h\u2081\n  ... = a * (m\u2081 * m\u2082)   : by rw mul_assoc\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 17, "name": "dvd_trans", "statement": "(h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c"}, {"type": "lean", "content": "2001", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "2002", "hidden": true}, {"type": "text", "content": "2003"}, {"type": "lean", "content": "2004", "hidden": true}, {"type": "lean", "content": "2005", "hidden": true}, {"type": "text", "content": "2006"}, {"type": "lean", "content": "2007", "hidden": true}, {"type": "axiom", "content": "2008", "name": "dvd_antisymm (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) :", "sideBar": true}, {"type": "lean", "content": "2009", "hidden": true}, {"type": "lean", "content": "2010", "hidden": true}, {"type": "text", "content": "2011"}, {"type": "lean", "content": "2012", "hidden": false}, {"type": "text", "content": "2013"}, {"type": "lean", "content": "2014", "hidden": false}, {"type": "text", "content": "2015"}, {"type": "lean", "content": "2016", "hidden": false}, {"type": "tactic", "content": "2017", "name": "split", "sideBar": true}, {"type": "hint", "content": "2018", "title": "2019"}, {"type": "hint", "content": "2020", "title": "2021"}, {"type": "theorem", "text": "2022", "lean": "lemma dvd_right_iff_eq (h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c :=\n", "sideBar": false, "firstProofLineNumber": 102, "lastProofLineNumber": 144, "textBefore": "import tactic.linarith divisibility.dvd_trans  -- hide\n\n/-\n# Divisibility\n\n## Level 9: Antisymmetry\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nThe divisibility relation is antisymmetric.\nThat is, suppose `a` and `b` are non-negative integers such that\n`a \u2223 b`, and `b \u2223 a`, then `a = b`.\n-/\nvariables {a b c d : \u2124} -- hide\n\n/- Axiom : dvd_antisymm (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) :\na = b\n-/\ntheorem dvd_antisymm (H1 : 0 \u2264 a) (H2 : 0 \u2264 b) : a \u2223 b \u2192 b \u2223 a \u2192 a = b :=  -- hide\ndvd_antisymm H1 H2                                                        -- hide\n\n\n/-\nIn Lean, this result is called `dvd_antisymm`. We can apply it forward\nto give a proof of `a = b` from hypotheses `h\u2081 : 0 \u2264 a`, `h\u2082 : 0 \u2264 b`,\n`h\u2083 : a \u2223 b`, and `h\u2084 : b \u2223 a`.\n-/\n\nexample (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  from dvd_antisymm h\u2081 h\u2082 h\u2083 h\u2084,\nend\n\n/-\nThis presupposed we have proved the necessary hypotheses. In some\ncases, it is easier to apply the result backwards.\n-/\nexample (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  apply dvd_antisymm h\u2081 h\u2082,\n  { show a \u2223 b,\n    from h\u2083, },\n  { show b \u2223 a,\n    from h\u2084, },\nend\n\n\n/-\nIn this level, we'll prove an if and only if (`\u2194`) statement. To split an `\u2194` statement into two\nimplications, use the `split` tactic.\n\nIn the example below, the initial goal is $\\vdash a = 2b + c \\leftrightarrow c = a - 2b$. After using the\n`split` tactic, we have two new goals: (1) $\\vdash a = 2b + c \\to c = a - 2b$ and \n(2) $\\vdash c = a - 2b \\to a = 2b + c$.\n-/\n\nexample : a = 2 * b + c \u2194 c = a - 2 * b :=\nbegin\n  split, \n  { show (a = 2 * b + c) \u2192 (c = a - 2 * b),\n    assume h : a = 2 * b + c,\n    show c = a - 2 * b, linarith },\n  { show (c = a - 2 * b) \u2192 (a = 2 * b + c),\n    assume h : c = a - 2 * b,\n    show a = 2 * b + c, linarith, },\nend\n\n/- Tactic : split\n\nThe `split` tactic splits a 'compound' target into multiple goals. \n\nFor example, `split` turns the target `\u22a2 p \u2194 q` into two goals: (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n\nEqually, if the target is `\u22a2 p \u2227 q`, then `split` creates goals (1) `\u22a2 p` and (2) `\u22a2 q`.\n-/\n\n/- Hint : Specialzing a universally-quantified statement.\n\nSuppose `P` is a predicate. Recall that if `h : \u2200 (x : \u03b1), P(x)` and if `y : \u03b1`, then\n`specialize h y` replaces `h` with `P(y)`.\n-/\n\n/- Hint : Decomposing a `\u2194` statement.\n\nSuppose `h : p \u2194 q`. Then the tactic `cases h with h\u2082 h\u2083` replaces `h` with `h\u2082 : p \u2192 q` and\n`h\u2083 : q \u2192 p`.\n-/\n\n\n/- Theorem : no-side-bar\nThe proposition $\\forall(a : \\mathbb Z), b \\mid a \\leftrightarrow c \\mid a$ holds\nif and only if $b = c$.\n-/\nlemma dvd_right_iff_eq (h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c :=\nbegin\n", "proof": "  split,\n  { show (\u2200 (a : \u2124), b \u2223 a  \u2194 c \u2223 a) \u2192 b = c,\n    assume h : \u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a,\n    show b = c,\n    apply dvd_antisymm h\u2081 h\u2082,\n    { show b \u2223 c,\n      specialize h c,\n      given h : b \u2223 c \u2194 c \u2223 c,\n      cases h with h\u2083 h\u2084,\n      given h\u2084 : c \u2223 c \u2192 b \u2223 c, \n      apply h\u2084,\n      show c \u2223 c,\n      apply dvd_refl, },\n    { show c \u2223 b,\n      specialize h b,\n      given h : b \u2223 b \u2194 c \u2223 b,\n      cases h with h\u2083 h\u2084,\n      given h\u2083 : b \u2223 b \u2192 c \u2223 b,\n      apply h\u2083,\n      show b \u2223 b,\n      apply dvd_refl, }, },\n  { show b = c \u2192 (\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a),\n    assume h : b = c,\n    assume a : \u2124,\n    show b \u2223 a \u2194 c \u2223 a,\n    rw h,  },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\nend exlean -- hide\n", "height": 43, "editorText": "sorry", "lineOffset": 101, "name": "dvd_right_iff_eq", "statement": "(h\u2081 : 0 \u2264 b) (h\u2082 : 0 \u2264 c) :\n(\u2200 (a : \u2124), b \u2223 a \u2194 c \u2223 a) \u2194 b = c"}, {"type": "lean", "content": "2023", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2024", "hidden": true}, {"type": "text", "content": "2025"}, {"type": "lean", "content": "2026", "hidden": true}, {"type": "text", "content": "2027"}, {"type": "lean", "content": "2028", "hidden": false}, {"type": "text", "content": "2029"}, {"type": "lean", "content": "2030", "hidden": false}, {"type": "text", "content": "2031"}, {"type": "theorem", "text": "2032", "lean": "theorem four_common_divisor_48_60 : common_divisor 48 60 4 :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 55, "textBefore": "import tactic.linarith divisibility.dvd_antisymm  -- hide\n\n/-\n# Divisibility\n\n## Level 10: Common divisor basics\n-/\n\nnamespace exlean -- hide\n\n/-\nLet $m$, $n$, and $d$ be integers. For $d$ to be a _common divisor_ of $m$ and $n$ means that\n$d \\mid m$ and $d \\mid n$.\n-/\n\ndef common_divisor (m n d : \u2124) := (d \u2223 m) \u2227 (d \u2223 n)\n\n/-\nUsing the above definition, we'll show that $5$ is a common divisor of $20$ and $30$.\n-/\nexample : common_divisor 20 30 5 :=\nbegin\n  split, -- We'll show 1) `5 \u2223 20` and 2) `5 \u2223 30`.\n  { use 4,  -- 1) `\u22a2 5 \u2223 20`, it suffices to show `20 = 5 * 4`.\n    norm_num, }, -- This holds by arithmetic.\n  { use 6,  -- 2) `\u22a2 30 = 5 * 6`, it suffices to show `\u22a2 30 = 5 * 6`.\n    norm_num, }, -- This holds by arithmetic.\nend\n\n/-\n### Tasks\n\n* Adapt the Lean proof above to show that $4$ is a common divisor of $48$ and $60$.\n\n* Give a handwritten proof of the same result.\n\n-/\n\n\n/- Theorem : no-side-bar\n$4$ is a common divisor of $48$ and $60$.\n-/\ntheorem four_common_divisor_48_60 : common_divisor 48 60 4 :=\nbegin\n", "proof": "  split,\n  { use 12,\n    norm_num, },\n  { use 15,\n    norm_num, },\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 44, "name": "four_common_divisor_48_60", "statement": "common_divisor 48 60 4"}, {"type": "lean", "content": "2033", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2034", "hidden": true}, {"type": "text", "content": "2035"}, {"type": "lean", "content": "2036", "hidden": true}, {"type": "text", "content": "2037"}, {"type": "lean", "content": "2038", "hidden": true}, {"type": "lean", "content": "2039", "hidden": false}, {"type": "hint", "content": "2040", "title": "2041"}, {"type": "theorem", "text": "2042", "lean": "theorem common_divisor_of_common_divisor_of_dvd\n(h\u2081 : common_divisor a b d) (h\u2082 : c \u2223 d) : common_divisor a b c :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 68, "textBefore": "import tactic.linarith divisibility.common_divisors  -- hide\n\n/-\n# Divisibility\n\n## Level 11: Common divisor results\n-/\n\nnamespace exlean -- hide\n\n/-\n### Tasks\n\nIn this level, you'll *decompose* the hypothesis that `d` is a common divisor of `a` and `b` to\nprove that `c` is a common divisor of `a` and `b`, under the hypothesis that `c \u2223 d`.\n\nAs `common_divisor a b d` is a conjunctive (an 'and') statement, it can be decomposed into\nits constituent parts using the `cases` tactic. See the example below.\n-/\n\nvariables {d a b c s t : \u2124} -- hide\n\n\nexample (h\u2081 : common_divisor a b d) : common_divisor a (a * s + b * t) d :=\nbegin\n  cases h\u2081 with hda hdb, -- `hda : d \u2223 a`, `hdb : d \u2223 b`.\n  given hda : d \u2223 a,\n  given hdb : d \u2223 b,\n  show (d \u2223 a) \u2227 (d \u2223 a * s + b * t),\n  split, -- 2 goals: (1) `\u22a2 d \u2223 a` and (2) `\u22a2 d \u2223 a * s + b * t`.\n  { show d \u2223 a,\n    from hda, }, -- (1) follows from `hda`\n  { show d \u2223 a * s + b * t,\n    apply dvd_mul_add_mul hda hdb, }, -- (2) follows from\n  -- our previous result on divisibility of linear combinations.\nend\n\n/- Hint : A useful result\nThe transitivity of divisibility, `dvd_trans` is your friend.\n\n-/\n\n/- Theorem : no-side-bar\nGiven `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n-/\ntheorem common_divisor_of_common_divisor_of_dvd\n(h\u2081 : common_divisor a b d) (h\u2082 : c \u2223 d) : common_divisor a b c :=\nbegin\n", "proof": "  given h\u2081 : (d \u2223 a) \u2227 (d \u2223 b),\n  cases h\u2081 with hda hdb,\n  given hda : d \u2223 a,\n  given hdb : d \u2223 b, \n  show (c \u2223 a) \u2227 (c \u2223 b),\n  split,\n  { show c \u2223 a,\n    apply dvd_trans h\u2082 hda, },\n  { show c \u2223 b,\n    apply dvd_trans h\u2082 hdb },  \n\n  \n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 49, "name": "common_divisor_of_common_divisor_of_dvd", "statement": "(h\u2081 : common_divisor a b d) (h\u2082 : c \u2223 d) : common_divisor a b c"}, {"type": "lean", "content": "2043", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "2044", "hidden": true}, {"type": "text", "content": "2045"}, {"type": "lean", "content": "2046", "hidden": true}, {"type": "lean", "content": "2047", "hidden": true}, {"type": "text", "content": "2048"}, {"type": "text", "content": "2049"}, {"type": "lean", "content": "2050", "hidden": false}, {"type": "text", "content": "2051"}, {"type": "lean", "content": "2052", "hidden": false}, {"type": "text", "content": "2053"}, {"type": "text", "content": "2054"}, {"type": "text", "content": "2055"}, {"type": "lean", "content": "2056", "hidden": true}, {"type": "hint", "content": "2057", "title": "2058"}, {"type": "theorem", "text": "2059", "lean": "theorem uniqueness_of_greatest_common_divisor (k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor m n d)\n(h\u2082 : greatest_common_divisor m n e) : d = e :=\n", "sideBar": true, "firstProofLineNumber": 74, "lastProofLineNumber": 102, "textBefore": "import tactic.linarith divisibility.common_divisors2  -- hide\n\n/-\n# Divisibility\n\n## Level 12: Greatest common divisors\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nRecall that for $d$ to be a common divisor of $a$ and $b$ means that $d \\mid a$ and $d \\mid b$.\n-/\n\n\n/-\nTo say that $m$ and $n$ have no greater common divisor than $d$\nmeans that for every integer $e$, if $e$ is a common divisor of $m$\nand $n$, then $e \\mid d$.\n-/\n\ndef no_greater_common_divisor (m n d : \u2124) :=\n\u2200 (e : \u2124), common_divisor m n e \u2192 e \u2223 d\n\n/-\nFor $d$ to be a _greatest common divisor_ of $m$ and $n$ means that\n* $d$ is a common divisor of $m$ and $n$ and\n* $m$ and $n$ have no greater common divisor than $d$.\n-/\n\n\n\ndef greatest_common_divisor (m n d : \u2124) := (common_divisor m n d) \u2227 \n  no_greater_common_divisor m n d\n\n/-\nThere are similarities between this definition and the definition of infimum in the\nreal number world. As with infima (and suprema), we can prove that there is (up to sign)\na unique greatest common divisor of two integers.\n-/\n\n/-\n**Warning**: the definition `greatest_common_divisor` is a predicate, not an ordinary function.\nSo, `greatest_common_divisor m n d` is the *proposition* that $d$ is a greatest common\ndivisor of $m$ and $n$. It is *not* an integer.\n\n-/\n\n\n/-\n### Task\n\nShow that if the non-negative integers $d$ and $e$ are both greatest common divisors of $m$ and $n$,\nthen $d = e$.\n-/\n\nvariables {d e m n : \u2124} -- hide\n\n/- Hint : Proving an equality\nRecall that `apply dvd_antisymm k\u2081 k\u2082,` will reduce the goal to two goals (1) `\u22a2 d \u2223 e` and\n(2) `\u22a2 e \u2223 d`.\n-/\n\n/- Theorem :\nIf the non-negative integers $d$ and $e$ are both greatest common divisors of $m$ and $n$,\nthen $d = e$.\n-/\ntheorem uniqueness_of_greatest_common_divisor (k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor m n d)\n(h\u2082 : greatest_common_divisor m n e) : d = e :=\nbegin\n", "proof": "  rcases h\u2081 with \u27e8hdcomm : common_divisor m n d, hdgreat : no_greater_common_divisor m n d\u27e9,\n  rcases h\u2082 with \u27e8hecomm : common_divisor m n e, hegreat : no_greater_common_divisor m n e\u27e9,\n  show d = e,\n  apply dvd_antisymm k\u2081 k\u2082,\n  { show d \u2223 e,\n    specialize hegreat d,\n    given hegreat : common_divisor m n d \u2192 d \u2223 e,\n    apply hegreat,\n    show common_divisor m n d, from hdcomm, },\n  { show e \u2223 d,\n    specialize hdgreat e,\n    given hdgreat : common_divisor m n e \u2192 e \u2223 d,\n    apply hdgreat,\n    show common_divisor m n e, from hecomm, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 29, "editorText": "sorry", "lineOffset": 73, "name": "uniqueness_of_greatest_common_divisor", "statement": "(k\u2081 : 0 \u2264 d) (k\u2082 : 0 \u2264 e)\n(h\u2081 : greatest_common_divisor m n d)\n(h\u2082 : greatest_common_divisor m n e) : d = e"}, {"type": "lean", "content": "2060", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2061", "hidden": true}, {"type": "text", "content": "2062"}, {"type": "lean", "content": "2063", "hidden": true}, {"type": "lean", "content": "2064", "hidden": true}, {"type": "text", "content": "2065"}, {"type": "hint", "content": "2066", "title": "2067"}, {"type": "theorem", "text": "2068", "lean": "theorem greatest_common_divisor_zero (a : \u2124) :\ngreatest_common_divisor a 0 a :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 55, "textBefore": "import tactic.linarith divisibility.gcd_uniqueness -- hide\n\n/-\n# Divisibility\n\n## Level 13: Greatest common divisor of an integer and zero\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nAs a next example of theorems regarding greatest common divisors, you will prove\nthat the greatest common divisor of $a$ and $0$ is $a$, for any integer $a$.\n\nThat is, you will prove:\n\n* $a$ is a common divisor or $a$ and $0$ and\n* there is no greater common divisor of $a$ and $0$ than $a$.\n-/\n\n\n/- Hint : Starting the proof\nRecall that `greatest_common_divisor d a b` is a conjunctive statement. Thus, you can\nsplit the goal in two using the `split` tactic.\n-/\n\n\n/- Theorem :\n`a` is a greatest common divisor of `a` and `0`, for every integer `a`.\n-/\ntheorem greatest_common_divisor_zero (a : \u2124) :\ngreatest_common_divisor a 0 a :=\nbegin\n", "proof": "  split,\n  { from \u27e8dvd_refl a, dvd_zero a\u27e9, },\n  intros e h,\n  from h.left,\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 35, "name": "greatest_common_divisor_zero", "statement": "(a : \u2124) :\ngreatest_common_divisor a 0 a"}, {"type": "lean", "content": "2069", "hidden": true}]}, {"name": "", "problemIndex": 23, "objects": [{"type": "lean", "content": "2070", "hidden": true}, {"type": "text", "content": "2071"}, {"type": "lean", "content": "2072", "hidden": true}, {"type": "lean", "content": "2073", "hidden": true}, {"type": "lean", "content": "2074", "hidden": true}, {"type": "text", "content": "2075"}, {"type": "text", "content": "2076"}, {"type": "lean", "content": "2077", "hidden": false}, {"type": "text", "content": "2078"}, {"type": "lean", "content": "2079", "hidden": false}, {"type": "text", "content": "2080"}, {"type": "lean", "content": "2081", "hidden": false}, {"type": "text", "content": "2082"}, {"type": "lean", "content": "2083", "hidden": true}, {"type": "lean", "content": "2084", "hidden": false}, {"type": "text", "content": "2085"}, {"type": "lean", "content": "2086", "hidden": false}, {"type": "text", "content": "2087"}, {"type": "tactic", "content": "2088", "name": "rcases", "sideBar": true}, {"type": "lean", "content": "2089", "hidden": false}, {"type": "text", "content": "2090"}, {"type": "hint", "content": "2091", "title": "2092"}, {"type": "hint", "content": "2093", "title": "2094"}, {"type": "theorem", "text": "2095", "lean": "theorem greatest_common_divisor_comm (h : greatest_common_divisor a b d) :\ngreatest_common_divisor b a d :=\n", "sideBar": true, "firstProofLineNumber": 192, "lastProofLineNumber": 214, "textBefore": "import tactic.linarith divisibility.gcd_zero -- hide\n\n/-\n# Divisibility\n\n## Level 14: Commutativity of greatest common divisor\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\nvariables {a b d c : \u2124} -- hide\n\n/-\nSuppose $a$, $b$, and $d$ are integers. We've seen how to *prove* that $d$ is a greatest common\ndivisor of $a$ and $b$. If instead we are *given* that $d$ is a greatest common divisor of $a$ and\n$b$, what can we do with this information?\n\n**Theorem**: Suppose $c \\mid d$ and suppose that $d$ is a greatest common divisor of $a$ and $b$.\nThen $c$ is a common divisor of $a$ and $b$.\n\n**Proof**: As $d$ is a greatest common divisor of $a$ and $b$, we have that $d$ is a common\ndivisor of $a$ and $b$. Thus, $d \\mid a$ and $d \\mid b$. But $c \\mid d$. So, by the transitivity\nof divisibility (applied twice), we have $c \\mid a$ and $c \\mid b$.\n\nThus, $c$ is a common divisor of $a$ and $b$. \u220e\n-/\n\n/-\nThere are several ways to prove this in Lean. Suppose `hcd` is the hypothesis that `c \u2223 d`\nand that `h` is the hypothesis `greatest_common_divisor a b d`.\nWe can decompose `h` into `h\u2081 : common_divisor a b d` and `h\u2082  : no_greater_common_divisor a b d`\nvia  `cases h with h\u2081 h\u2082`.\n\nThen `h\u2081` can be further decomposed via `cases h\u2081 with hda hdb` into `hda : d \u2223 a` and\n`hdb : d \u2223 b`.\n\nThe target `common_divisor a b d` is a conjunction (an and statement) that can be proved backward\nvia `split`.\n-/\n\nexample (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  cases h with h\u2081 h\u2082,\n  given h\u2081 : common_divisor a b d,\n  cases h\u2081 with hda hdb,\n  given hda : d \u2223 a,\n  given hdb : d \u2223 b,\n  show common_divisor a b c,\n  split,\n  { show c \u2223 a, from dvd_trans hcd hda, }, \n  { show c \u2223 b, from dvd_trans hcd hdb, },\nend\n\n/-\nRather than using `cases` to extract named hypotheses, we can drill down into `h` directly\nusing left and right 'and elimination'.\n\nAs `h` is the proof of an and statement, `h.left` is a proof of `common_divisor a b d`, which means\n`(d \u2223 a) \u2227 (d \u2223 b)`. Thus, `h.left.right` is a proof `d \u2223 b`.\n-/\n\nexample (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  have hda : d \u2223 a, from h.left.left,\n  have hdb : d \u2223 b, from h.left.right,\n  split,\n  { show c \u2223 a, from dvd_trans hcd hda, }, \n  { show c \u2223 b, from dvd_trans hcd hdb, },\nend\n\n/-\nFor a one-line proof, we can use `and.intro` rather than `split`, thereby giving a forward proof\nof the and statement `common_divisor a b c`.\n-/\n\nexample (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  from and.intro (dvd_trans hcd h.left.left) (dvd_trans hcd h.left.right),\nend\n\n/-\n### The `rcases` tactic\n\nAn alternative approach is to use `rcases` (short for 'recursive cases'). This combines the\nease-of-use of `cases` with the readability of a forward proof.\n\nI'll start with a simple example from propositional logic.\n-/\n\nvariables (p q r : Prop) -- hide\n\nexample (h : p \u2227 q) : q \u2227 p :=\nbegin\n  rcases h with \u27e8hp : p, hq : q\u27e9,\n  show q \u2227 p, from and.intro hq hp,\nend\n\n/-\nAbove, the line `rcases h with \u27e8hp : p, hq : q\u27e9` decomposes `h : p \u2227 q` into two hypotheses:\n`hp : p` and `hq : q`. This has exactly the same effect as `cases h with hp hq`.\n\nHere, the 'French quotes' `\u27e8` and `\u27e9` are typed `\\<` and `\\>`.\n\nThere's not much point using `rcases` for a simple example like this. Its power becomes apparent\nwith more complicated examples.\n-/\n\nexample (h : (p \u2227 q) \u2227 r) : r \u2227 q :=\nbegin\n  rcases h with \u27e8\u27e8hp, hq\u27e9, hr\u27e9,\n  show r \u2227 q, from and.intro hr hq,\nend\n\n/-\nAs we don't need the hypothesis `hp` in the example above, We could instead have used the pattern\n`\u27e8\u27e8-, hq\u27e9, hr\u27e9`. The `-` tells `rcases` not to introduce the proof of `p` as a hypothesis.\n\n`rcases` can do many more things. See the Tactic sidebar for details.\n\nFor now, we'll use `rcases` to prove the theorem stated at the top of this level.\n-/\n\n/- Tactic : rcases\nUsed for recursive elimination.\n\n## Examples\n* If `h : a \u2227 b` then `rcases h with \u27e8h\u2081 : a, h\u2082 : b\u27e9` replaces `h` with two hypotheses,\n`h\u2081 : a` and `h\u2082 : b`.\n\n* If `h : \u2203 (x : X), P(x)`, then `rcases h with \u27e8x, h\u2082 : P(x)\u27e9` replaces `h` with `x : X`\nand `h\u2082 : P(x)`.  \n\n* If `h : a \u2228 b`, then `rcases h with (h\u2081 : a) | (h\u2082 : b)` replaces the goal with two new goals,\none with a hypothesis `h\u2081 : a` and one with a hypothesis `h\u2082 : b`.\n\n* If `h : a = b`, then `rcases h with rfl` replaces every occurence of `b` in the context\nwith `a`.\n\n* These rules can be used recursively. Thus if `\u2203 (x : \u2115), Q(x) \u2228 (P(x) \u2227 y = 2 * x)`,\nthen `rcases h with \u27e8x, (h\u2082 : Q(x)) | \u27e8h\u2083 : P(x), rfl\u27e9 \u27e9` replaces `h` and creates two new goals.\nEach goal contains `x : \u2115`. The context of the first goal contains contains `h\u2082 : Q(x)`.\nIn the second goal, every instance of `y` is replaced with `2 * x`. The context of the\nsecond goal  contains `h\u2083: P(x)`.\n-/\n\nexample (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  rcases h with \u27e8\u27e8hda : d \u2223 a, hdb : d \u2223 b \u27e9, -\u27e9,\n  show (c \u2223 a) \u2227 (c \u2223 b),\n  split,\n  { show c \u2223 a,\n    from dvd_trans hcd hda,},\n  { show c \u2223 b,\n    from dvd_trans hcd hdb, },\nend\n\n/-\n### Task\nProve that if $d$ is the greatest common divisor of $a$ and $b$, then $d$ is the greatest\ncommon divisor of $b$ and $a$. You may wish to use the `rcases` tactic to decompose the\nhypothesis.\n-/\n\n/- Hint : A proof template\nYou can begin with the `rcases` tactic.\n```\nrcases h with \u27e8\u27e8hda : d \u2223 a, hdb : d \u2223 b\u27e9, hngt : no_greater_common_divisor a b d\u27e9,\nshow ((d \u2223 b) \u2227 (d \u2223 a)) \u2227 (no_greater_common_divisor b a d),\nsorry,\n```\n-/\n\n/- Hint : Showing `e \u2223 d`\nAt some point in the proof, you will need to show `e \u2223 d`. Note that this can be seen as the\nconclusion of the statement `no_greater_common_divisor a b d`, which should be the hypothesis\n`hngt` if you followed my proof template above.\n\nIn detail, `hngt : \u2200 (e : \u2124), common_divisor a b e \u2192 e \u2223 d`.\nUsing `apply hngt` will thereby change the goal of proving `e \u2223 d` into the goal of proving\n`common_divisor a b e`.\n-/\n\n/- Theorem :\nIf $d$ is a greatest common divisor of $a$ and $b$, then $d$ is a greatest common divisor of\n$b$ and $a$.\n-/\ntheorem greatest_common_divisor_comm (h : greatest_common_divisor a b d) :\ngreatest_common_divisor b a d :=\nbegin\n", "proof": "  rcases h with \u27e8\u27e8hda, hdb\u27e9, hgt\u27e9,\n  split,\n  { from \u27e8hdb, hda\u27e9, },\n  intros e h,\n  apply hgt,\n  from \u27e8h.right, h.left\u27e9,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 23, "editorText": "sorry", "lineOffset": 191, "name": "greatest_common_divisor_comm", "statement": "(h : greatest_common_divisor a b d) :\ngreatest_common_divisor b a d"}, {"type": "lean", "content": "2096", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "2097", "hidden": true}, {"type": "text", "content": "2098"}, {"type": "lean", "content": "2099", "hidden": true}, {"type": "lean", "content": "2100", "hidden": true}, {"type": "text", "content": "2101"}, {"type": "lean", "content": "2102", "hidden": true}, {"type": "axiom", "content": "2103", "name": "division (a b : \u2124) (h : b \u2260 0) :", "sideBar": true}, {"type": "lean", "content": "2104", "hidden": true}, {"type": "lean", "content": "2105", "hidden": true}, {"type": "lean", "content": "2106", "hidden": false}, {"type": "lean", "content": "2107", "hidden": true}, {"type": "text", "content": "2108"}, {"type": "lean", "content": "2109", "hidden": false}, {"type": "text", "content": "2110"}, {"type": "hint", "content": "2111", "title": "2112"}, {"type": "hint", "content": "2113", "title": "2114"}, {"type": "hint", "content": "2115", "title": "2116"}, {"type": "hint", "content": "2117", "title": "2118"}, {"type": "theorem", "text": "2119", "lean": "lemma division_unique (h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < |b|)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < |b|)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082 :=\n", "sideBar": true, "firstProofLineNumber": 154, "lastProofLineNumber": 207, "textBefore": "import tactic.linarith divisibility.gcd_comm  -- hide\n\n/-\n# Divisibility\n\n## Level 15: Division\n-/\n\nnamespace exlean -- hide\n\nopen int -- hide\n\n/-\nThe division lemma states that if `a` and `b` are integers with `b \u2260 0`, then there exist integers\n`q` and `r` for which `a = b * q + r` and `0 \u2264 r < |b|`.\n\nThe quantity `q` is called the quotient and `r` is called the remainder.\n\nIn Lean, the absolute value of `b` may be written `abs b` or `|b|`.\n-/\n\nvariables (a b : \u2124) -- hide\n\n/- Axiom : division (a b : \u2124) (h : b \u2260 0) :\n\u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|)\n-/\nlemma division (h : b \u2260 0) : \u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|) :=     -- hide\n\u27e8a/b, a % b, by rw [add_comm, mod_add_div a b], mod_nonneg a h, mod_lt a h\u27e9  -- hide\n\nexample (h : b \u2260 0) : \u2203 (q r : \u2124), 700 = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|) :=\nbegin\n  apply division 700 b h,\nend\n\nvariables {q\u2081 r\u2081 q\u2082 r\u2082 : \u2124} -- hide\n\n/-\n### Task\nIn this level, your task is to show uniqueness of the quotient and remainder.\nMore precisely, suppoer you have integers $a$ and $b$ with $b \\ne 0$. Suppose\n$a = bq_1 + r_2$ and $a = bq_2 + r_2$ for integers $q_1, q_2, r_1, r_2$ such that\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$. Then $q_1 = q_2$ and $r_1 = r_2$.\n\n**Warning**: this level is challenging. Feel free to skip it.\n\nThe following lemma will be useful.\n-/\n\nlemma abs_sub_lt {x y c : \u2124} (h\u2081 : 0 \u2264 x \u2227 x < c) (h\u2082 : 0 \u2264 y \u2227 y < c) : |x - y| < c :=\nbegin\n  rw abs_sub_lt_iff,\n  split;\n  linarith,\nend\n\n/-\nOther useful results include:\n\n* `abs_mul a b : |a * b| = |a| * |b|`\n* `abs_nonneg a : 0 \u2264 |a|`\n* `abs_pos : 0 < |a| \u2194 a \u2260 0`\n* `sub_neq_zero : a - b \u2260 0 \u2194 a \u2260 b`\n* `le_mul_of_one_le_right : 0 \u2264 b \u2192 1 \u2264 a \u2192 b \u2264 b * a`.\n* `abs_pos : 0 < |a| \u2194 a \u2260 0`.\n* `sub_ne_zero : x - y \u2260 0 \u2194 x \u2260 y`\n-/\n\n\n\n/- Hint : A sketch 'handwritten' proof\nIf you were proving this by hand, you might start by noting that\n$r_1 = r_2 + b(q_2 - q_1)$ and that $r_1 - r_2 = b(q_2 - q_1)$. The variable $a$ and the equations\ninvolving $a$ can thereafter by ignored.\n\nConsider separately the cases $q_2 = q_1$ and $q_2 \\ne q_1$.\n\nIn the first case, where $q_2 = q_1$, we can\nwe can replace replace $r_1$ with $r_2 + b(q_2 -q_1)$ and $q_2$ with $q_1$ in the target so\nthat our goal is to prove $q_1 = q_1$ and $r_2 + b(q_2 - q_2) = r_2$. Each of these equations\nis clearly true.\n\nThe more difficult case to consider is when $q_2 \\ne q_1$. As this hypothesis contradicts the target,\nit's evident that we should proceed by ex falso.\n\nFrom $r_1 - r_2 = b(q_2 - q_1)$, we have that $|b| |q_2 - q_1| = |b(q_2 - q_1)| = |r_2 - r_1|$.\nBut $0 \\le |r_1| < |b|$ and $0 \\le |r_2| < |b|$, so $|r_2 - r_1| < |b|$.\n\nThus, $|b||q_2 - q_1| < |b|$. This contradicts $q_2 \\ne q_1$.\n-/\n\n\n/- Hint : Ideas for the Lean proof\nYou can begin by decomposing the hypotheses.\n```\nrcases h\u2081 with \u27e8heq\u2081 : a = b * q\u2081 + r\u2081, hineq\u2081 : 0 \u2264 r\u2081 \u2227 r\u2081 < |b|\u27e9,\nrcases h\u2082 with \u27e8heq\u2082 : a = b * q\u2082 + r\u2082, hineq\u2082 : 0 \u2264 r\u2082 \u2227 r\u2082 < |b|\u27e9,\n```\n\nYou can introduce some useful equations into the context via\n```\nhave h\u2084 : r\u2081 = r\u2082  + b * (q\u2082 - q\u2081), by linarith only [heq\u2081, heq\u2082],\nhave h\u2085 : r\u2081 - r\u2082  = b * (q\u2082 - q\u2081), linarith only [h\u2084],\nclear heq\u2081 heq\u2082,\n```\n\nHere, the `clear` line removes the named hypotheses from the context. It isn't necessary but it\nhelps in keepingthe proof tidy and efficient.\n\nYou'll then need to consider separately the cases `q\u2082 = q\u2081` and `q\u2082 \u2260 q\u2081`.\nYou can do this with `by_cases heq : q\u2082 = q\u2081`.\n\nAs some point, you'll want to prove `|r\u2081 - r\u2082| < |b|`. This sort of statement is the\nconclusion of `abs_sub_lt`.\n-/\n\n/- Hint : Getting the final contradiction via `le_mul_of_one_le_right`\nIf you followed my sketch proof above, you'll know that the second case of the proof\ninvolves assuming $q_2 \\ne q_1$, deriving $|b||q_2 - q_1| < |b|$ and thereby deriving\na contradiction. But what is this contradiction?\n\nBy applying `le_mul_of_one_le_right`, you can prove `|b| \u2264 |b| * |q\u2082 - q\u2081|`, which clearly\ncontradicts `|b| * |q\u2082 - q\u2081| < |b|`.\n\nThus, you can try\n```\nhave lt2 : |b| \u2264 |b| * |q\u2082 - q\u2081|,\n{ apply le_mul_of_one_le_right,\n  { show 0 \u2264 |b|, sorry },\n  { show 1 \u2264 |q\u2082 - q\u2081|, sorry },\n```\nafter which `linarith` will find the contradiction. It remains to complete the `sorry`s.\nThe tricky part of this is the second `sorry`. see below for a hint.\n-/\n\n/- Hint : Proving `1 \u2264 |q\u2082 - q\u2081|`\nIf you followed the hints above, you'll be left with proving `1 \u2264 |q\u2082 - q\u2081|`.\nOne way to do this is first to introduce a proof of `0 < |q\u2082 - q\u2081|` and then use linarith:\n```\nhave hqpos : 0 < |q\u2082 - q\u2081|,\n{ sorry },\nlinarith,\n```\nTo complete this last `sorry`, rewrite the target using `abs_pos` and `sub_ne_zero`.\n-/\n\n/- Theorem :\nLet $a, b$ be integers with $b \u2260 0$. If $a = b q_1 + r_1 = b q_2  + r_2$, where\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$, then $q_1 = q_2$ and $r_1 = r_2$.\n-/\nlemma division_unique (h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < |b|)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < |b|)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082 :=\nbegin\n", "proof": "/-   cases h\u2081 with hx\u2081 hx\u2082,\n  cases h\u2082 with hy\u2081 hy\u2082,\n  rw hx\u2081 at hy\u2081,\n  have h\u2084 : r\u2081 - r\u2082 = b * (q\u2082 - q\u2081), linarith,\n  by_cases h\u2085 : q\u2081 = q\u2082,\n  { split,\n    { exact h\u2085, },\n    { rw [h\u2085.symm, show q\u2081 - q\u2081 = 0, by linarith, mul_zero] at h\u2084,\n      linarith, }, },\n  { exfalso,\n    have p\u2081 : abs (r\u2081 - r\u2082) = abs b * abs (q\u2082 - q\u2081), rw [h\u2084, abs_mul],\n    have p\u2082 : 0 < abs (q\u2082 - q\u2081),\n    { rw abs_pos,\n      intro p\u2083,\n      apply h\u2085,\n      linarith, },\n    have p\u2083 : abs b \u2264 abs (r\u2081 - r\u2082),\n    { rw p\u2081, \n      exact le_mul_of_one_le_right (abs_nonneg _) p\u2082, },\n    have p\u2084 := abs_sub_lt hx\u2082 hy\u2082,\n    linarith, }, -/\n\n  rcases h\u2081 with \u27e8heq\u2081 : a = b * q\u2081 + r\u2081, hineq\u2081 : 0 \u2264 r\u2081 \u2227 r\u2081 < |b|\u27e9,\n  rcases h\u2082 with \u27e8heq\u2082 : a = b * q\u2082 + r\u2082, hineq\u2082 : 0 \u2264 r\u2082 \u2227 r\u2082 < |b|\u27e9,\n  have h\u2084 : r\u2081 = r\u2082  + b * (q\u2082 - q\u2081), by linarith only [heq\u2081, heq\u2082],\n  have h\u2085 : r\u2081 - r\u2082  = b * (q\u2082 - q\u2081), linarith only [h\u2084],\n  clear heq\u2081 heq\u2082,\n  by_cases hq : q\u2082 = q\u2081,\n  { rw [h\u2084, hq],\n    from and.intro rfl (by linarith only []), },\n  given hq : q\u2082 \u2260 q\u2081,\n  exfalso,\n  have hlt : |b| * |q\u2082 - q\u2081| < |b|,\n  { rw [\u2190abs_mul, \u2190h\u2085],\n    from abs_sub_lt hineq\u2081 hineq\u2082, },\n  clear hineq\u2081 hineq\u2082 h\u2084 h\u2085,\n  have lt2 : |b| \u2264 |b| * |q\u2082 - q\u2081|,\n  { apply le_mul_of_one_le_right,\n    { show 0 \u2264 |b|, from abs_nonneg _},\n    { show 1 \u2264 |q\u2082 - q\u2081|,\n      have hqpos : 0 < |q\u2082 - q\u2081|,\n      { rwa [abs_pos, sub_ne_zero], },\n      linarith, }, },\n  linarith,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 54, "editorText": "sorry", "lineOffset": 153, "name": "division_unique", "statement": "(h : b \u2260 0)\n(h\u2081 : a = b * q\u2081 + r\u2081 \u2227 (0 \u2264 r\u2081 \u2227 r\u2081 < |b|)) \n(h\u2082 : a = b * q\u2082 + r\u2082 \u2227 (0 \u2264 r\u2082 \u2227 r\u2082 < |b|)) : q\u2081 = q\u2082 \u2227 r\u2081 = r\u2082"}, {"type": "lean", "content": "2120", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2121", "hidden": true}, {"type": "text", "content": "2122"}, {"type": "lean", "content": "2123", "hidden": true}, {"type": "text", "content": "2124"}, {"type": "lean", "content": "2125", "hidden": false}, {"type": "text", "content": "2126"}, {"type": "text", "content": "2127"}, {"type": "lean", "content": "2128", "hidden": false}, {"type": "lemma", "text": "2129", "lean": "lemma five_nmid_sixty_two : \u00ac ((5 : \u2124) \u2223 62) :=\n", "sideBar": false, "firstProofLineNumber": 60, "lastProofLineNumber": 80, "textBefore": "import tactic.linarith divisibility.division -- hide\n\n/-\n# Divisibility\n\n## Level 16: Non-divisibility examples\n-/\n\nnamespace exlean -- hide\n\n/-\nIn any particular numerical example, it's easy to show divisibility. For example, here's a proof\nthat $7 \\mid 42$.\n-/\n\nexample : (7 : \u2124) \u2223  42 :=\nbegin\n  show \u2203 (m : \u2124), 42 = 7 * m,\n  use 6,\n  norm_num,\nend\n\n/-\nBut how can we prove non-divisibility? How would you prove $7 \\nmid 31$?\n\nThe idea is to use the uniqueness of division result. Suppose (for a contradiction), that\n$h: 7 \\mid 31$. Decomposing $h$ gives $m : \\mathbb Z$ and $h : 31 = 7m = 7m + 0$.\n\nBut (as you may easily verify), we have $h_2 : 31 = 7 \\times 4 + 3$.\n\nUsing $h$ and $h_2$ in the uniquness of division result, we infer $m = 4$ and $0 = 3$. This\nlatter is a contradiction.\n-/\n\n/-\nHere we use the semi-colon `;` 'tactic combinator'. This is a time-saving measure that applies\nthe following tactic to each remaining goal. In our application, the tactic `tidy` is used\nto complete each of the three goals that arise from the application of `division_unique 31 7`.\n-/\n\nexample : \u00ac((7 : \u2124) \u2223 31) :=\nbegin\n  assume h : (7 : \u2124) \u2223 31,\n  cases h with m h, -- We have `m : \u2124` and `h : 31 = 7 * m`.\n  have h\u2081 : (31 : \u2124) = 7 * m + 0, linarith,\n  have h\u2082 : (31 : \u2124) = 7 * 4 + 3, norm_num,\n\n  have k\u2081 : m = 4 \u2227 (0 : \u2124) = 3,\n  { apply division_unique 31 7;\n    tidy, },\n  linarith, -- `k\u2081` gives a contradiction.\nend\n\n\n/- Lemma : no-side-bar\n5 does not divide sixty-two.\n-/\nlemma five_nmid_sixty_two : \u00ac ((5 : \u2124) \u2223 62) :=\nbegin\n", "proof": "  assume h : (5 : \u2124) \u2223 62,\n  cases h with m hm,\n  have h\u2081 : 62 = m * 5 + 0, linarith,\n  have h\u2082 : (62 : \u2124) = 12 * 5 + 2, norm_num,\n  \n  have k\u2081 : m = 12 \u2227 (0 : \u2124) = 2,\n  { apply division_unique 62 5;\n    tidy, },\n  linarith,\n\n\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 59, "name": "five_nmid_sixty_two", "statement": "\u00ac ((5 : \u2124) \u2223 62)"}, {"type": "lean", "content": "2130", "hidden": true}]}, {"name": "", "problemIndex": 18, "objects": [{"type": "lean", "content": "2131", "hidden": true}, {"type": "text", "content": "2132"}, {"type": "lean", "content": "2133", "hidden": true}, {"type": "text", "content": "2134"}, {"type": "lean", "content": "2135", "hidden": true}, {"type": "lean", "content": "2136", "hidden": false}, {"type": "lean", "content": "2137", "hidden": true}, {"type": "text", "content": "2138"}, {"type": "lean", "content": "2139", "hidden": false}, {"type": "text", "content": "2140"}, {"type": "lean", "content": "2141", "hidden": false}, {"type": "text", "content": "2142"}, {"type": "lean", "content": "2143", "hidden": false}, {"type": "text", "content": "2144"}, {"type": "lean", "content": "2145", "hidden": false}, {"type": "lean", "content": "2146", "hidden": true}, {"type": "text", "content": "2147"}, {"type": "lean", "content": "2148", "hidden": true}, {"type": "theorem", "text": "2149", "lean": "lemma bezout1 (a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor a b d) \u2227 (d = a * s + b * t) :=\n", "sideBar": true, "firstProofLineNumber": 166, "lastProofLineNumber": 212, "textBefore": "import tactic.linarith strong_induction.well_ordering_principle divisibility.division -- hide\n\n/-\n# Divisibility\n\n## Level 17: B\u00e9zout's lemma (version 1)\n-/\n\nnamespace exlean -- hide\n\n/-\n**Warning**: this is a challenging level! Feel free to move on to the next level if you get stuck.\n\nLet $a$ and $b$ be integers. B\u00e9zout's lemma asserts that there exists an integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$ and such that $d = as + bt$, for some integers \n$s$ and $t$.\n\nIn this level, you'll prove B\u00e9zout's lemma via the well-ordering principle. If you haven't already\ndone so, please try the level on the well-ordering principle from the 'Strong Induction' world.\n\nThe proof contains several components. First, we need to consider the set\n$\\\\{y : \\mathbb N \\mid (0 < y) \\land (\\exists (s\\ t\\ : \\mathbb Z),\\, |a s + b t|  = y)\\\\}$.\n\nWe call this set `set_T a b`.\n-/\n\n-- begin hide\nopen int \n\nvariables {a b : \u2124} {k : \u2115}\n\nnamespace gcd_set\n-- end hide \n\ndef set_T (a b : \u2124) := {y : \u2115 | 0 < y \u2227 \u2203 (s t : \u2124), nat_abs (a * s + b * t)  = y}\n\n-- begin hide\nlemma lin_combo_of_min_element (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), \u2191k = a * x + b * y :=\nbegin\n  rcases h with \u27e8\u27e8hkpos, s, t, hst\u27e9, hkmin\u27e9,\n  rw nat_abs_eq_iff at hst,\n  cases hst,\n  { use [s, t],\n    from hst.symm, },\n  { use [-s, -t],\n    linarith, },\nend\n\nlemma dvd_of_min_element (a b : \u2124) (k : \u2115) (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  rcases lin_combo_of_min_element h with \u27e8x, y, hxy\u27e9,\n  rcases h with \u27e8\u27e8hkpos, hst\u27e9, hkmin\u27e9,\n  clear hst,\n  rcases division a k (show (k : \u2124) \u2260 0, by linarith) with \u27e8q, r, hqr, hrnonneg, hrlt\u27e9,\n  by_cases hrzero : r = 0,\n  { use q,\n    rw [hqr, hrzero, add_zero], },\n  exfalso,\n  have hrinT : r.nat_abs \u2208 set_T a b,\n  { rw [set_T, set.mem_set_of_eq],\n    split,\n    { apply nat_abs_pos_of_ne_zero hrzero,  },\n    { use [1 - x * q, - y * q],\n      congr,\n      rw [(show r = a - k * q, by linarith), hxy],\n      linarith, }, },\n  specialize hkmin (nat_abs r) hrinT,\n  have : nat_abs r < k,\n  { rw \u2190nat_abs_of_nat k, \n    apply nat_abs_lt_nat_abs_of_nonneg_of_lt hrnonneg, \n    rwa coe_nat_abs at hrlt, },\n  linarith, \nend\n\nlemma set_T_nonempty (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  use nat_abs a,\n  rw [set_T, set.mem_set_of_eq],\n  split,\n  { apply nat_abs_pos_of_ne_zero h, },\n  use [1, 0],\n  rw [mul_one, mul_zero, add_zero],\nend\n\nlemma set_T_comm : (set_T b a) = (set_T a b) :=\nbegin\n  suffices h\u2082 : \u2200 (m n : \u2124), set_T m n \u2286 set_T n m,\n  { ext y,\n    from \u27e8\u03bb h, h\u2082 b a h, \u03bb h, h\u2082 a b h\u27e9, },\n  rintros m n y \u27e8ypos, s, t, h\u27e9,\n  apply and.intro ypos _,\n  use [t,s],\n  rwa add_comm,\nend\n-- end hide\n\n/-\nYou'll need to use the following lemmas concerning this set.\n* `lin_combo_of_min_element`\n* `dvd_of_min_element`\n* `set_T_nonempty`\n* `set_T_comm`\n\nThe use of these lemmas is shown below.\n-/\n\n\n\nexample (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), (k : \u2124) = a * x + b * y :=\nbegin\n  from lin_combo_of_min_element h,\nend\n\n/-\n\n-/\n\nexample (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  from dvd_of_min_element a b k h,\nend\n\n\n/-\n\n-/\nexample (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  from set_T_nonempty h,\nend\n\n/-\n\n-/\nexample : (set_T b a) = (set_T a b) :=\nbegin\n  from set_T_comm,\nend\n\n\n\nend gcd_set -- hide\n\n/-\n### An overview of the proof\nThere are two cases to consider: either $a = 0$ or $a \\ne 0$.\nIn the first case, the result follows in a relatively straightforward manner, using\nsome of the results we've proved already concerning greatest common divisors.\n\nIn the second case, the idea is to show that the minimal element of the set `set_T a b`\nwill be the greatest common divisor of $a$ and $b$. We can extract the minimal element of\nthis set via the well-ordering principle.\n\nThe remainder of the proof uses the lemmas above and our previous material on divisibility.\n-/\n\nopen gcd_set -- hide\n\n/- Theorem :\nB\u00e9zout's lemma (version 1). Every pair of integers $a$ and $b$ has a greatest common divisor $d$\nthat can be written as $d = as + bt$, for some integers $s$ and $t$.\n-/\nlemma bezout1 (a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor a b d) \u2227 (d = a * s + b * t) :=\nbegin\n", "proof": "  by_cases ha : a = 0,\n  { given ha : a = 0,\n    subst ha,\n    use [b, 0, 1],\n    split,\n    { apply greatest_common_divisor_comm,\n      apply greatest_common_divisor_zero, },\n    { norm_num, }, },\n  { given ha : a \u2260 0,\n    have h\u2082 : (set_T a b).nonempty := set_T_nonempty ha,\n    rcases (well_ordering_principle h\u2082) with \u27e8n, h\u2083 : min_element n (set_T a b)\u27e9,\n    clear h\u2082,\n    have h\u2082 : \u2203 (x y : \u2124), (n : \u2124) = a * x + b * y, from lin_combo_of_min_element h\u2083,\n    rcases h\u2082 with \u27e8s, t, h\u2082 : (n : \u2124) = a * s + b * t\u27e9,\n    use [n, s, t],\n    split,\n    { split,\n      { show common_divisor a b n,\n        split,\n        { from dvd_of_min_element a b n h\u2083, },\n        apply dvd_of_min_element b a n,\n        rwa (set_T_comm), },\n      { assume e : \u2124,\n        assume h : common_divisor a b e,\n        rw h\u2082,\n        from dvd_mul_add_mul h.left h.right, }, },\n    { from h\u2082, }, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\nend exlean -- hide", "height": 47, "editorText": "sorry", "lineOffset": 165, "name": "bezout1", "statement": "(a b : \u2124) :\n\u2203 (d s t : \u2124), (greatest_common_divisor a b d) \u2227 (d = a * s + b * t)"}, {"type": "lean", "content": "2150", "hidden": true}]}, {"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "2151", "hidden": true}, {"type": "text", "content": "2152"}, {"type": "lean", "content": "2153", "hidden": true}, {"type": "text", "content": "2154"}, {"type": "lean", "content": "2155", "hidden": true}, {"type": "lean", "content": "2156", "hidden": true}, {"type": "axiom", "content": "2157", "name": "neg_dvd_of_dvd", "sideBar": true}, {"type": "lean", "content": "2158", "hidden": false}, {"type": "axiom", "content": "2159", "name": "neg_dvd", "sideBar": true}, {"type": "lean", "content": "2160", "hidden": false}, {"type": "axiom", "content": "2161", "name": "dvd_neg_of_dvd", "sideBar": true}, {"type": "lean", "content": "2162", "hidden": false}, {"type": "hint", "content": "2163", "title": "2164"}, {"type": "theorem", "text": "2165", "lean": "lemma gcd_neg (h : greatest_common_divisor a b d) :\ngreatest_common_divisor a b (-d) :=\n", "sideBar": true, "firstProofLineNumber": 73, "lastProofLineNumber": 93, "textBefore": "import tactic.linarith divisibility.bezout -- hide\n/-\n# Divisibility\n\n## Level 18: The negative of a greatest common divisor\n-/\n\nnamespace exlean -- hide\n\n/-\nIn preparation for another version of B\u00e9zout's lemma, we first need a result about greatest common\ndivisors.\n\n### Task\nSuppose $d$ is a greatest common divisor of $a$ and $b$. Prove that $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n\nSome of the following results on divisibility will be useful.\n-/\n\nopen int -- hide\n\nvariables {a b d : \u2124} -- hide\n\n/- Axiom : neg_dvd_of_dvd\n(h : d \u2223 a) : -d \u2223 a\n-/\nlemma neg_dvd_of_dvd (h : d \u2223 a) : -d \u2223 a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 a = -d * -m`,\n  rw h\u2082, -- `\u22a2 d * m = -d * -m`,\n  ring, -- This follows by algebra.\nend\n\n/- Axiom : neg_dvd\n-d \u2223 a \u2194 d \u2223 a\n-/\nlemma neg_dvd : -d \u2223 a \u2194 d \u2223 a :=\nbegin\n  split,\n  { assume h : -d \u2223 a,\n    rw \u2190neg_neg d,\n    from neg_dvd_of_dvd h, },\n  { assume h : d \u2223 a,\n    from neg_dvd_of_dvd h, },\nend\n\n/- Axiom : dvd_neg_of_dvd\n(h : d \u2223 a) : d \u2223 -a\n-/\nlemma dvd_neg_of_dvd (h : d \u2223 a) : d \u2223 -a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 - a = d * -m`,\n  rw h\u2082, -- `\u22a2 -(d * m) = d * -m`,\n  ring, -- This follows by algebra.\nend\n\n\n/- Hint : Approaching the proof\nThe basic ideas behind this proof are similar to those from the previous level on\ncommutativity of greatest common divisor.\n-/\n\n/- Theorem :\nSuppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n-/\nlemma gcd_neg (h : greatest_common_divisor a b d) :\ngreatest_common_divisor a b (-d) :=\nbegin\n", "proof": "  rcases h with \u27e8\u27e8hda, hdb\u27e9, hngt\u27e9,\n  split,\n  { split;\n    rwa neg_dvd, },\n  assume e : \u2124,\n  assume h : common_divisor a b e,\n  apply dvd_neg_of_dvd,\n  from hngt _ h,\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 72, "name": "gcd_neg", "statement": "(h : greatest_common_divisor a b d) :\ngreatest_common_divisor a b (-d)"}, {"type": "lean", "content": "2166", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "2167", "hidden": true}, {"type": "text", "content": "2168"}, {"type": "lean", "content": "2169", "hidden": true}, {"type": "text", "content": "2170"}, {"type": "lean", "content": "2171", "hidden": true}, {"type": "lean", "content": "2172", "hidden": true}, {"type": "text", "content": "2173"}, {"type": "lean", "content": "2174", "hidden": true}, {"type": "hint", "content": "2175", "title": "2176"}, {"type": "lean", "content": "2177", "hidden": false}, {"type": "theorem", "text": "2178", "lean": "lemma bezout (a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor a b d \u2227 0 \u2264 d \u2227 (d = a * s + b * t) :=\n", "sideBar": true, "firstProofLineNumber": 65, "lastProofLineNumber": 92, "textBefore": "import tactic.linarith divisibility.gcd_neg -- hide\n/-\n# Divisibility\n\n## Level 19: B\u00e9zout's lemma (version 2)\n-/\n\nnamespace exlean -- hide\n\n/-\nYou'll show that for all integers $a$ and $b$, there exists a *non-negative integer* $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n\nThis is a slight variant of our previous version of B\u00e9zout's lemma. The only difference being the\nnonnegativity of $d$. The simplest apporach to this problem is to use the result `bezout1`\ntogether with our result `gcd_neg` from the last level.\n-/\n\nopen int -- hide\n\nvariables (a b : \u2124) -- hide\n\n/-\nThe lemma `nonneg_or_nonneg_neg'` will be useful.\n-/\n\n-- begin hide\nlemma nonneg_or_nonneg_neg' (a : \u2124) : (0 \u2264 a) \u2228 (0 \u2264 -a) :=\nbegin\n  by_cases h : 0 \u2264 a,\n  { left, from h, },\n  { right,\n    linarith, },\nend\n-- end hide\n\n/- Hint : Starting the proof\n\nYou can start by decomposing `bezout1 a b`.\n```\nrcases (bezout1 a b) with \u27e8e, x, y, hgcd, heq\u27e9,\ngiven hgcd : greatest_common_divisor a b e,\ngiven heq : e = a * x + b * y,\nsorry,\n```\n\nIf you do this unthinkingly, you might suspect the next step would be to take `d` to be `e`.\nBut `e` might not be nonnegative.\n\nThus, you shoud proceed by cases on `nonneg_or_nonneg_neg e`. For example,\n```\ncases (nonneg_or_nonneg_neg' e) with hnn hnp,\n```\n-/\n\nexample : 0 \u2264 a \u2228 0 \u2264 -a := nonneg_or_nonneg_neg' a\n\n/- Theorem :\nFor all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n-/\nlemma bezout (a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor a b d \u2227 0 \u2264 d \u2227 (d = a * s + b * t) :=\nbegin\n", "proof": "  rcases bezout1 a b with \u27e8e, u, v, hgcd, heq\u27e9,\n  cases (nonneg_or_nonneg_neg' e) with ha hna,\n  { use [e, u, v],\n    from \u27e8hgcd, ha, heq\u27e9 },\n  { use [-e, -u, -v],\n    have h\u2082 : greatest_common_divisor a b (-e), from gcd_neg hgcd,\n    from \u27e8h\u2082, hna, by linarith\u27e9, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\n\nend exlean -- hide", "height": 28, "editorText": "sorry", "lineOffset": 64, "name": "bezout", "statement": "(a b : \u2124) :\n\u2203 (d s t : \u2124), greatest_common_divisor a b d \u2227 0 \u2264 d \u2227 (d = a * s + b * t)"}, {"type": "lean", "content": "2179", "hidden": true}]}, {"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "2180", "hidden": true}, {"type": "text", "content": "2181"}, {"type": "lean", "content": "2182", "hidden": true}, {"type": "text", "content": "2183"}, {"type": "lean", "content": "2184", "hidden": true}, {"type": "axiom", "content": "2185", "name": "greatest_common_divisor_gcd (a b : \u2124) :", "sideBar": true}, {"type": "lean", "content": "2186", "hidden": true}, {"type": "text", "content": "2187"}, {"type": "lean", "content": "2188", "hidden": false}, {"type": "hint", "content": "2189", "title": "2190"}, {"type": "lean", "content": "2191", "hidden": true}, {"type": "text", "content": "2192"}, {"type": "hint", "content": "2193", "title": "2194"}, {"type": "hint", "content": "2195", "title": "2196"}, {"type": "hint", "content": "2197", "title": "2198"}, {"type": "lean", "content": "2199", "hidden": true}, {"type": "theorem", "text": "2200", "lean": "lemma euclid_basic (b q r : \u2124) : gcd (b * q + r) b = gcd b r:=\n", "sideBar": true, "firstProofLineNumber": 140, "firstProofHintLineNumber": 141, "lastProofHintLineNumber": 144, "lastProofLineNumber": 181, "textBefore": "import tactic.linarith divisibility.bezout2  -- hide\n\n/-\n# Divisibility\n\n## Level 20: The Euclidean algorithm - basic step\n-/\n\nnamespace exlean -- hide\n\n/-\nAs a result of B\u00e9zout's lemma, we can define a *function* `gcd` such that `gcd a b` is\nthe greatest common divisor of `a` and `b`.\n-/\n\n-- begin hide\nnoncomputable theory\n\nlemma gcd_exists (a b : \u2124) : \u2203 (d : \u2124), (greatest_common_divisor a b d \u2227 0 \u2264 d) :=\nbegin\n  rcases bezout a b with \u27e8d, s, t, h, h\u2082, h\u2083\u27e9,\n  from \u27e8d, h, h\u2082\u27e9,\nend\n\nnoncomputable def gcd (a b : \u2124) := classical.some (gcd_exists a b)\n\nnoncomputable def egcd (a b : \u2124) := classical.some (bezout a b)\n-- end hide\n\n/- Axiom : greatest_common_divisor_gcd (a b : \u2124) :\n(greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n-/\n\n-- begin hide\nlemma greatest_common_divisor_gcd (a b : \u2124) :\n(greatest_common_divisor a b (gcd a b)) \u2227 (0 \u2264 gcd a b) :=\nbegin\n  apply @classical.some_spec _ (\u03bb d, (greatest_common_divisor a b d) \u2227 (0 \u2264 d)),\nend\n-- end hide\n\n/-\nThe lemma `greatest_common_divisor_gcd` asserts that `gcd a b` is a greatest common divisor of `a`\nand `b` and that `0 \u2264 gcd a b`\n-/\n\nexample (a b : \u2124) : (greatest_common_divisor a b (gcd a b)) \u2227 (0 \u2264 gcd a b) :=\nbegin\n  from greatest_common_divisor_gcd a b,\nend\n\n/- Hint : Under the hood: how is `gcd` defined?\nYou may be wondering how `gcd` is defined in Lean. Essentially, I use the Axiom of Choice.\nThe details are unimportant to your understanding of this mathematical topic, but the intrepid\nmay read on!\n\nLean provides two functions, `classical.some` and `classical.some_spec` that are, in a sense,\ngeneralisations of the Axiom of Choice. The functions work in harmony with each other.\n\nLet `P` be a predicate on a type `\u03b1`. Then the function\n`classical.some` produces a term of type `\u03b1` given the proof of `\u2203 d, P(d)`, for a predicate `P`.\nIn our case, `P` is the predicate defined so `P(d)` means `greatest_common_divisor a b d \u2227 0 \u2264 d`,\nfor fixed integers `a` and `b`. From B\u00e9zout's theorem, we can prove\n```\nh : \u2203 (d : \u2124), greatest_common_divisor a b d \u2227 0 \u2264 d\n```\nWe define `gcd a b` to be the integer produced by `classical.some h`.\n\nThe discussion above says nothing about the properties of the integer produced by\n`classical.some h`. This is where `classical.some_spec` enters the picture. The theorem\n`classical.some_spec` asserts `P(classical.some h)`.\n\nWrite `d` for `gcd a b`. Then `d` is the integer producesd by `classical.some h`. Hence `P(d)`\nholds. By definition of `P`, this means `greatest_common_divisor a b d \u2227 0 \u2264 d`.\n\nThis is the theorem we call `greatest_common_divisor_gcd`.\n\nBut why use the Axiom of Choice? In general, one should only use the Axiom of Choice (and related\nprinciples) if it is unavoidable. Unfortunately, functions defined via the Axiom of Choice are\nnot computable. There is a better way to define the gcd (essentially using Euclid's algorithm),\nbut this approach works better for teaching purposes.\n-/\n\n\nopen int -- hide\n\n/-\n### Task\nSuppose $a = bq + r$. Show that $\\gcd(a,b) = \\gcd(b,r)$. This result is a crucial component of\nEuclid's algorithm for computing greatest common divisors.\n\nThe result isn't easier, but it should not be as difficult s some of the 'challenging' levels.\n-/\n\n/- Hint : Starting the proof and setting variables\nAs usual, we'll use `rcases` to decompose the hypotheses. We'll also label commonly-arising\nquantities via the `set` tactic.\n```\nset a := b * q + r with ha,\nrcases (greatest_common_divisor_gcd a b) with \u27e8\u27e8\u27e8hda, hdb\u27e9, hngtd\u27e9, hdnn\u27e9,\nrcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8heb, her\u27e9, hngte\u27e9, henn\u27e9,\nset d := gcd a b,\nset e := gcd b r,\n```\nThe `set` lines above provide a convenient shorthand, replacing `gcd a b` everywhere with `d`,\nfor example. In the first `set` line, we use `with ha` to introduce into\nthe context `ha : a = b * q + r`. This is necessary if we ever need to replace `a` with\n`b * q + r`.\n-/\n\n/- Hint : How do I prove equality?\nHere, you have to prove $d = e$, where $d = \\gcd(a,b)$ and $e = \\gcd(b,r)$. Since this is a \nproblem about divisibility, it's a good idea to use antisymmetry of divisibility.\n```\napply dvd_antisymm hdnn henn,\n```\nwhere `hdnn : 0 \u2264 d` and `henn : 0 \u2264 e`, as derived in the hint above.\n\nDoing this introduces two new goals: to prove `d \u2223 e` and to prove `e \u2223 d`.\nThe fact that $e$ is the greatest common divisor of $b$ and $r$ will help in proving the first\ngoal. A similar approach works for the second goal.\n-/\n\n/- Hint : How do I prove $d \\mid r$?\nIn the second goal (for instance), you'll at some point need to prove $d \\mid r$. You know\n$d \\mid a$ and $d \\mid b$. You can first prove (by `linarith`) that `r = a * 1 + b * (-q)`\nand rewrite using this equation. Then it remains to prove `d \u2223 a * 1 + b * (-q)`. A lemma\nfrom a previous level will complete this goal.\n-/\n\nvariables {a : \u2124}  -- hide\n\n/- Theorem :\nSuppose $a$, $b$, $q$, $r$ are integers and that $a = bq + r$.\n\nThen $\\gcd(a, b) = \\gcd(b, r)$.\n-/\nlemma euclid_basic (b q r : \u2124) : gcd (b * q + r) b = gcd b r:=\nbegin\n", "proof": "/- hint\nrcases (greatest_common_divisor_gcd (b*q + r) b) with \u27e8\u27e8\u27e8hxa, hxb\u27e9, hxgt\u27e9, hxnn\u27e9,\nrcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8hyb, hyr\u27e9, hygt\u27e9, hynn\u27e9,\nset x := gcd(b * q + r) b,\nset y := gcd b r,\n-/\n  set a := b * q + r with ha,\n  rcases (greatest_common_divisor_gcd a b) with \u27e8\u27e8\u27e8hda, hdb\u27e9, hngtd\u27e9, hdnn\u27e9,\n  rcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8heb, her\u27e9, hngte\u27e9, henn\u27e9,\n  set d := gcd a b,\n  set e := gcd b r,\n  apply dvd_antisymm hdnn henn,\n  { apply hngte,\n    split,\n    { show d \u2223 b, from hdb, },\n    show d \u2223 r,\n    rw (show r = a * 1 + b * (-q), by linarith),\n    from dvd_mul_add_mul hda hdb, },\n  apply hngtd,\n  split,\n  { show e \u2223 a,\n    rw ha,\n    from dvd_add (dvd_mul_of_dvd_left heb _) her,  },\n  show e \u2223 b, from heb,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "rcases (greatest_common_divisor_gcd (b*q + r) b) with \u27e8\u27e8\u27e8hxa, hxb\u27e9, hxgt\u27e9, hxnn\u27e9,\nrcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8hyb, hyr\u27e9, hygt\u27e9, hynn\u27e9,\nset x := gcd(b * q + r) b,\nset y := gcd b r,", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 42, "editorText": "rcases (greatest_common_divisor_gcd (b*q + r) b) with \u27e8\u27e8\u27e8hxa, hxb\u27e9, hxgt\u27e9, hxnn\u27e9,\nrcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8hyb, hyr\u27e9, hygt\u27e9, hynn\u27e9,\nset x := gcd(b * q + r) b,\nset y := gcd b r,", "lineOffset": 139, "name": "euclid_basic", "statement": "(b q r : \u2124) : gcd (b * q + r) b = gcd b r"}, {"type": "lean", "content": "2201", "hidden": true}]}, {"name": "", "problemIndex": 21, "objects": [{"type": "lean", "content": "2202", "hidden": true}, {"type": "text", "content": "2203"}, {"type": "lean", "content": "2204", "hidden": true}, {"type": "text", "content": "2205"}, {"type": "lean", "content": "2206", "hidden": true}, {"type": "lean", "content": "2207", "hidden": true}, {"type": "text", "content": "2208"}, {"type": "lean", "content": "2209", "hidden": false}, {"type": "text", "content": "2210"}, {"type": "axiom", "content": "2211", "name": "gcd_eq_greatest_common_divisor", "sideBar": true}, {"type": "lean", "content": "2212", "hidden": true}, {"type": "text", "content": "2213"}, {"type": "lean", "content": "2214", "hidden": false}, {"type": "axiom", "content": "2215", "name": "gcd_zero (a : \u2124) :", "sideBar": true}, {"type": "lean", "content": "2216", "hidden": true}, {"type": "text", "content": "2217"}, {"type": "lean", "content": "2218", "hidden": false}, {"type": "text", "content": "2219"}, {"type": "lean", "content": "2220", "hidden": false}, {"type": "text", "content": "2221"}, {"type": "hint", "content": "2222", "title": "2223"}, {"type": "lemma", "text": "2224", "lean": "lemma three_forty_gcd_23 : gcd 340 23 = 1 :=\n", "sideBar": false, "firstProofLineNumber": 117, "lastProofLineNumber": 132, "textBefore": "import tactic.linarith divisibility.euclid_basic  -- hide\n\n/-\n# Divisibility\n\n## Level 21: The Euclidean algorithm\n-/\n\nnamespace exlean -- hide\n\n/-\nUsing the result `euclid_basic` from our previous level, we can *compute* greatest common divisors.\n-/\n\nopen int -- hide\n\nvariables (a b d q r x y: \u2124)  -- hide\n\n/-\nAs an example, we'll compute $\\gcd(100,7)$. As a first step, we'll use `euclid_basic` to justify\nthe assertion that $\\gcd(100,7) = \\gcd(7, 2)$. The reason for this is that \n$100 = 7 \\times 14 + 2$, so $\\gcd(7 \\times 14 + 2, 7) = \\gcd(7, 2)$, by `euclid_basic`.\n\nHere ia a proof in Lean.\n-/\n\nexample : gcd 100 7 = gcd 7 2 := euclid_basic 7 14 2\n\n/-\nIn the above proof, note that the arguments  $7$, $14$, and $2$ correspond to the calculation\n$100 = 7 \\times 14 + 2$.\n-/\n\n\n/- Axiom : gcd_eq_greatest_common_divisor\n (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d\n-/\n-- begin hide\nlemma gcd_eq_greatest_common_divisor {a b d : \u2124} (h\u2081 : greatest_common_divisor a b d) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\nbegin\n  rcases (greatest_common_divisor_gcd a b) with \u27e8hxgreat, hxnn\u27e9,\n  from uniqueness_of_greatest_common_divisor hxnn h\u2082 hxgreat h\u2081,\nend\n-- end hide\n\n/-\nIn later worlds, we'll have occasion to use the lemma `gcd_eq_greatest_common_divisor`. This states\nthat if $d$ is a greatest common divisor of $a$ and $b$ and if $d$ is non-negative, then\n$\\gcd(a,b) = d$.\n-/\n\nexample (h\u2081 : greatest_common_divisor a b d) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\ngcd_eq_greatest_common_divisor h\u2081 h\u2082\n\n/- Axiom : gcd_zero (a : \u2124) : \ngcd a 0 = |a|\n-/\n-- begin hide\nlemma gcd_zero : gcd a 0 = |a| :=\nbegin\n  refine gcd_eq_greatest_common_divisor  _ (abs_nonneg a),\n  rcases abs_cases a with \u27e8habs, hineq\u27e9 | \u27e8habs, hineq\u27e9; rw habs,\n  { apply greatest_common_divisor_zero, },\n  { split,\n    { split,\n      { rw neg_dvd, },\n      { apply dvd_zero, }, },\n    { rintros e \u27e8ha, _\u27e9,\n      apply dvd_neg_of_dvd ha, }, },\nend\n-- end hide\n\n/-\nWe'll apply this process repeatedly until we reach $\\gcd(a, 0)$, for some integer $a$. We then\nuse the lemma `gcd_zero`.\n-/\n\nexample : gcd a 0 = abs a := gcd_zero a\n\n/-\nBelow is a Lean proof that 1 is a greatest common divisor of 7 and 100.\n-/\n\nexample : gcd 100 7 = 1 :=\nbegin\n  calc gcd 100 7\n      = gcd 7 2 : euclid_basic 7 14 2\n  ... = gcd 2 1 : euclid_basic 2  3 1\n  ... = gcd 1 0 : euclid_basic 1  2 0\n  ... = 1       : gcd_zero 1,\nend\n\n/-\n### Task\n\nAdapt the proof above to show that $\\gcd(340, 23) = 1$. The proof is nothing more than a few lines\nof calculation.\n-/\n\n/- Hint : A proof template\nTry this:\n```\ncalc gcd 340 23\n    = gcd 23 18 : euclid_basic 23 14 18\n... = 1         : sorry\n```\nYou will need to add about 5 additional lines of calculation and, finally, to replace `sorry` with\n`gcd_zero 1`.\n\n-/\n\n/- Lemma : no-side-bar\n$\\gcd(340, 23) = 1$\n-/\nlemma three_forty_gcd_23 : gcd 340 23 = 1 :=\nbegin\n", "proof": "  calc gcd 340 23\n      = gcd 23 18 : euclid_basic 23 14 18\n  ... = gcd 18  5 : euclid_basic 18  1  5\n  ... = gcd  5  3 : euclid_basic  5  3  3\n  ... = gcd  3  2 : euclid_basic  3  1  2\n  ... = gcd  2  1 : euclid_basic  2  1  1\n  ... = gcd  1  0 : euclid_basic  1  2  0\n  ... = 1         : gcd_zero 1,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 116, "name": "three_forty_gcd_23", "statement": "gcd 340 23 = 1"}, {"type": "lean", "content": "2225", "hidden": true}]}], "parents": [8]}, {"name": "2226", "levels": [{"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "2227", "hidden": true}, {"type": "text", "content": "2228"}, {"type": "lean", "content": "2229", "hidden": true}, {"type": "lean", "content": "2230", "hidden": true}, {"type": "lean", "content": "2231", "hidden": true}, {"type": "text", "content": "2232"}, {"type": "lean", "content": "2233", "hidden": true}, {"type": "axiom", "content": "2234", "name": "mod_def (x y : \u2124) :", "sideBar": true}, {"type": "lean", "content": "2235", "hidden": true}, {"type": "text", "content": "2236"}, {"type": "lean", "content": "2237", "hidden": false}, {"type": "text", "content": "2238"}, {"type": "text", "content": "2239"}, {"type": "theorem", "text": "2240", "lean": "theorem sixty_cong_37_mod_11 : 60 \u2261 38 [MOD 11] :=\n", "sideBar": false, "firstProofLineNumber": 72, "lastProofLineNumber": 82, "textBefore": "import divisibility.euclidean_algorithm tactic.norm_cast -- hide\n\n/-\n#  Congruences\n\n## Level 1: The definition of congruence\n\nThe notation `a \u2261 b [MOD n]`, read '`a` is congruent to `b` modulo `n`' means `n \u2223 b - a`. \n\nType `\u2261` as `\\==`.\n-/\n\n\nnamespace exlean -- hide\n\ndef modeq (n a b : \u2124) := n \u2223 b - a  -- hide\n\nnotation a ` \u2261 `:50 b ` [MOD `:50 n `]`:0 := modeq n a b -- hide\n\n/-\nIf you forget this definition or ever want to replace `a \u2261 b [MOD n]` with the definition in a proof, use\nthe result `mod_def`.\n-/\n\nvariables {a b n : \u2124} -- hide\n\n/- Axiom : mod_def (x y : \u2124) :\na \u2261 b [MOD n] \u2194 n \u2223 b - a\n-/\nlemma mod_def : a \u2261 b [MOD n] \u2194 n \u2223 b - a := by refl -- hide\n\n/-\nFor example, we will prove that `17 \u2261 45 [MOD 7]`. The `rw` and `show` lines here are\nunnecessary, but may be helpful in understanding how to apply definitions.\n\nIn the first line, we rewrite `\u22a2 17 \u2261 45 [MOD 7]` using the definition of congruence to give\n`\u22a2 7 \u2223 45 - 17`.\n\nUsing the definition of divisibility, this becomes `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`.\n\nTo prove this existentially-quantified statement, we take `m` to be `4`. The result follows by\narithmetic.\n-/\n\nexample : 17 \u2261 45 [MOD 7] :=\nbegin\n  rw mod_def, -- show `7 \u2223 45 - 17`.\n  show \u2203 (m : \u2124), 45 - 17 = 7 * m,\n  use 4,      -- Take 'm' to be 4. `\u22a2 45 - 17 = 7 * 4`,\n  norm_num,\nend\n\n/-\nIf you were to write the proof 'by hand', you might write the following:\n\n> By definition, we must prove `7 \u2223 45 - 17`. That is, that `45 - 17 = 7 * m`, for some `m`.\n> This holds if one takes `m` to be `4`.\n-/\n\n/-\n### Tasks\n* By making a minor variation to the proof above, show that `60 \u2261 38 [MOD 11] `.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem : no-side-bar\n`60 \u2261 38 [MOD 11]` \n-/\ntheorem sixty_cong_37_mod_11 : 60 \u2261 38 [MOD 11] :=\nbegin\n", "proof": "  use (-2),\n  norm_num,\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 71, "name": "sixty_cong_37_mod_11", "statement": "60 \u2261 38 [MOD 11]"}, {"type": "lean", "content": "2241", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2242", "hidden": true}, {"type": "text", "content": "2243"}, {"type": "lean", "content": "2244", "hidden": true}, {"type": "text", "content": "2245"}, {"type": "lean", "content": "2246", "hidden": true}, {"type": "text", "content": "2247"}, {"type": "lean", "content": "2248", "hidden": false}, {"type": "text", "content": "2249"}, {"type": "lemma", "text": "2250", "lean": "lemma reduction_of_500_mod_63 :\n\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < |63|) :=\n", "sideBar": false, "firstProofLineNumber": 51, "lastProofLineNumber": 65, "textBefore": "import congruences.mod_def -- hide\n\n/-\n#  Congruences\n\n## Level 2: Reduction of an integer modulo $n$\n-/\n\nnamespace exlean -- hide\n\n/-\nLet $x$ and $n$ be integers with $n \\ne 0$. One can find an integer $a$ in the range $0 \\le a < |n|$\nsuch that $x \\equiv a \\pmod n$.\n\nThis is sometimes called _reduction_ of $x$ modulo $n$.\n-/\n\nvariables {x a n : \u2124} -- hide\n\n/-\nWe'll find a number $a$ such that $321 \\equiv a \\pmod{12}$ and such that $0 \\le a < |12|$\n\nFor $a$, I'll take the remainder on dividing $321$ by $12$. Note that\n$321 = q \\times 12 + r$, where $q = 26$ and $r = 9$.\n-/\n\nexample : \u2203 (a : \u2124), 321 \u2261 a [MOD 12] \u2227 ((0 \u2264 a) \u2227 (a < |12|)) :=\nbegin\n  use 9,          -- `\u22a2 321 \u2261 9 [MOD 12] \u2227 ((0 \u2264 9) \u2227 (9 < |12|))`\n  split,\n  { rw mod_def,   -- By definition, we must show `63 \u2223 59 - 600`.\n    norm_num, },\n  tidy,           -- Prove `(0 \u2264 9) \u2227 (9 < |12|)`.\nend\n\n/-\n### Task\n\nAdapting the proof above, show that there is an integer $a$ such that\n$500 \\equiv a \\pmod{63}$ with $0 \\le a < |63|$.\n\n-/\n\n/- Lemma : no-side-bar\nThere is an integer $a$ such that $500 \\equiv a \\pmod{63}$ with\n$0 \\le a < |63|$.\n-/\nlemma reduction_of_500_mod_63 :\n\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < |63|) :=\nbegin\n", "proof": "  use 59,\n  split,\n  { use -7,\n    norm_num, },\n  tidy,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 15, "editorText": "sorry", "lineOffset": 50, "name": "reduction_of_500_mod_63", "statement": "\u2203 a, 500 \u2261 a [MOD 63] \u2227 (0 \u2264 a) \u2227 (a < |63|)"}, {"type": "lean", "content": "2251", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "2252", "hidden": true}, {"type": "text", "content": "2253"}, {"type": "lean", "content": "2254", "hidden": true}, {"type": "text", "content": "2255"}, {"type": "lean", "content": "2256", "hidden": true}, {"type": "axiom", "content": "2257", "name": "mod_refl {a : \u2124} :", "sideBar": true}, {"type": "lean", "content": "2258", "hidden": false}, {"type": "text", "content": "2259"}, {"type": "text", "content": "2260"}, {"type": "lean", "content": "2261", "hidden": false}, {"type": "text", "content": "2262"}, {"type": "hint", "content": "2263", "title": "2264"}, {"type": "theorem", "text": "2265", "lean": "lemma mod_symm (h : a \u2261 b [MOD n]) : b \u2261 a [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 79, "lastProofLineNumber": 98, "textBefore": "import congruences.reduction1 -- hide\n\n/-\n#  Congruences\n\n## Level 3: Reflexivity and symmetry of mod\n-/\n\n\nnamespace exlean -- hide\n\n\n/-\nAs a first proper theorem on congruences, we'll show that `\u2261` is a reflexive relation.\n-/\n\nvariables {a b n : \u2124} -- hide\n\n/- Axiom : mod_refl {a : \u2124} :\na \u2261 a [MOD n]\n-/\nlemma mod_refl : a \u2261 a [MOD n] :=\nbegin\n  show n \u2223 a - a,\n  rw (show a - a = 0, by norm_num),\n  show n \u2223 0,\n  apply dvd_zero,\nend\n\n/-\nA handwritten proof might be:\n\n> By definition of congruence, it suffices to prove $n \\mid a - a$. That is, to prove $n \\mid 0$.\n> But every integer divides zero. \u220e\n-/\n\n/-\nAlternatively, the result can be proved directly from the definitions, without using previous\nresults on divisibility.\n-/\n\nexample : a \u2261 a [MOD n] :=\nbegin\n  show \u2203 m, a - a = n * m,\n  use 0,\n  show a - a = n * 0, by norm_num,\nend\n\n/-\n### Tasks\n* Show that `\u2261` is a symmetric relation.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Two approaches to the proof\n\nIn the problem below, you are _given_ a congruence `h : a \u2261 b [MOD n]`, which corresponds\nto the statement `n \u2223 b - a`.\nYou need to show `b \u2261 a [MOD n]`. That is, to show `n \u2223 a - b`. There are two approaches to this\nproblem.\n\n* You could rewrite the target to one of proving `n \u2223 -(b - a)` and then use\n  a result from the divisibility world.\n\n* Alternatively, you could note that `h` is a proof of `\u2203 m, b - a = n`\n  To extract information\n  from this statement, use either `cases` or `rcases`.\n\n  For example, write `cases h with m h\u2082` to produce an integer `m` and the hypothesis\n  `h\u2082 : b - a = n * m`.\n-/\n\n/- Theorem :\nThe relation `\u2261` is symmetric.\n-/\nlemma mod_symm (h : a \u2261 b [MOD n]) : b \u2261 a [MOD n] :=\nbegin\n", "proof": "\n  show n \u2223 a - b,\n  given h : n \u2223 b - a,\n  rw (show a - b = -(b - a), by norm_num),\n  apply dvd_neg_of_dvd h,\n\n/-   cases h with m h\u2082,\n  use -m,\n  linarith, -/\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 78, "name": "mod_symm", "statement": "(h : a \u2261 b [MOD n]) : b \u2261 a [MOD n]"}, {"type": "lean", "content": "2266", "hidden": true}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "2267", "hidden": true}, {"type": "text", "content": "2268"}, {"type": "lean", "content": "2269", "hidden": true}, {"type": "lean", "content": "2270", "hidden": true}, {"type": "text", "content": "2271"}, {"type": "text", "content": "2272"}, {"type": "lean", "content": "2273", "hidden": false}, {"type": "text", "content": "2274"}, {"type": "lean", "content": "2275", "hidden": false}, {"type": "text", "content": "2276"}, {"type": "hint", "content": "2277", "title": "2278"}, {"type": "hint", "content": "2279", "title": "2280"}, {"type": "theorem", "text": "2281", "lean": "lemma mod_trans (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 99, "lastProofLineNumber": 112, "textBefore": "import congruences.mod_refl_symm -- hide\n\n/-\n#  Congruences\n\n## Level 4: Transitivity of mod\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\nYour next task is to prove that `\u2261` is transitive. That is, assuming `a \u2261 b [MOD n]` and\n`b \u2261 c [MOD n]` to prove `a \u2261 c [MOD n]`. The clever way to do this is to invoke an appropriate\nresult you've already seen concerning divisibility. \n-/\n\n/-\nAs an example of the kind of technique you'll need, we'll give a proof that $a \\mid b + 2c + d$\ngiven $h_1 : a \\mid b + c$ and $h_2 : a \\mid c + d$.\n\nFirst we note $h_3 : b + 2c + d = (b + c) + (c + d)$. Rewriting with $h_3$, the goal becomes\n$\\vdash a \\mid (b + c) + (c + d)$. Applying the 'addition of divisibility' result, it suffices\nto prove two new goals (1) $a \\mid b + c$ and (2) $a \\mid c + d$. The first of these goals follows\nfrom $h_1$ and the second from $h_2$.\n\nNote the use of the `apply` tactic to construct new goals from the conditions of the `dvd_add`\ntheorem.\n-/\n\nexample (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  have h\u2083 : b + 2 * c + d = (b + c) + (c + d), linarith,\n  rw h\u2083,\n  show a \u2223 (b + c) + (c + d),\n  apply dvd_add,\n  { show a \u2223 b + c, from h\u2081 },\n  { show a \u2223 c + d, from h\u2082 },\nend\n\n/-\nWe can prove the same result more briefly by (a) dispensing with additional hypothesis `h\u2083` and\nrewriting 'in place' via 'show' and (b) giving `apply` the desired conditions without the need\nto introduce additional goals.\n-/\n\nexample (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  rw (show b + 2 * c + d = (b + c) + (c + d), by linarith),\n  apply dvd_add h\u2081 h\u2082,\nend\n\n\n\n/-\n### Tasks\n* Show that `\u2261` is a transitive relation.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Starting the problem\nStart by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n\nYou can then either decompose the hypothesis and do some arithmetic or you can use a\nresult from the divisibility world.\n-/\n\n/- Hint : A clever rewriting\nIf you took the hint above, the target will be `\u22a2 n \u2223 c - a`. If you want to use a result\nfrom the divisibility world, a clever idea is to write `c - a` as `(c - b) + (b - a)`.\n\nOne way to do this is via:\n```\nhave h\u2083 : c - a = (c - b) + (b - a), by linarith,\nrw h\u2083,\n```\n\nAlternatively,\n```\nrw (show c - a = (c - b) + (b - a), by linarith),\n```\nThe latter approach obviates the need for an additional hypothesis.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n-/\n\n/- Theorem :\nThe relation `\u2261` is transitive.\n-/\nlemma mod_trans (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show c - a = (c - b) + (b - a), by linarith),\n  apply dvd_add h\u2082 h\u2081,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 98, "name": "mod_trans", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : b \u2261 c [MOD n]) :\na \u2261 c [MOD n]"}, {"type": "lean", "content": "2282", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2283", "hidden": true}, {"type": "text", "content": "2284"}, {"type": "lean", "content": "2285", "hidden": true}, {"type": "lean", "content": "2286", "hidden": true}, {"type": "text", "content": "2287"}, {"type": "hint", "content": "2288", "title": "2289"}, {"type": "lemma", "text": "2290", "lean": "lemma modeq_zero_iff' : 0 \u2261 a [MOD n] \u2194 n \u2223 a :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 60, "textBefore": "import congruences.mod_trans -- hide\n\n/-\n#  Congruences\n\n## Level 5: A condition for an integer to be congruent to zero\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a n : \u2124} -- hide\n\n/-\n### Tasks\n* Let $a$ and $n$ be integers. Prove, by hand, that $0 \\equiv a \\pmod n$ if and only if $n \\mid a$.\n\n\n* Write the same proof in Lean.\n-/\n\n\n\n/- Hint : Rewriting with easy equations\nAt some point in your proof, you may want to replace `a - 0` with `a`.\nWe can easily prove `a - 0 = a` using `linarith`, so you can do the\nreplacement with\n```\nrw (show a - 0 = a, by linarith)\n```\nAs it happens, the proof of `a - 0 = a` is known to Lean as `sub_zero`,\nso you could alternatively do `rw sub_zero`.\n-/\n\n\n/- Lemma :\nLet $a$ be an integer. Then $0 \\equiv a \\pmod n \\leftrightarrow n \\mid a$.\n-/\nlemma modeq_zero_iff' : 0 \u2261 a [MOD n] \u2194 n \u2223 a :=\nbegin\n", "proof": "  rw [mod_def, sub_zero],\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 19, "editorText": "sorry", "lineOffset": 41, "name": "modeq_zero_iff'", "statement": "0 \u2261 a [MOD n] \u2194 n \u2223 a"}, {"type": "lean", "content": "2291", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2292", "hidden": true}, {"type": "text", "content": "2293"}, {"type": "lean", "content": "2294", "hidden": true}, {"type": "lean", "content": "2295", "hidden": true}, {"type": "text", "content": "2296"}, {"type": "hint", "content": "2297", "title": "2298"}, {"type": "hint", "content": "2299", "title": "2300"}, {"type": "theorem", "text": "2301", "lean": "lemma mod_mul_right (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 60, "textBefore": "import congruences.modeq_zero_iff   -- hide\n\n/-\n#  Congruences\n\n## Level 6: Multiplying a congruence on the right\n-/\n\n\nnamespace exlean -- hide\n\n\nvariables {a b c n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]`, show `a * c \u2261 b * c [MOD n]`. As in the previous level, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n-/\n\n/- Hint : Starting the problem\nStart by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n-/\n\n/- Hint : Factoring\nThe expression `b * c - a * c` in the target can be factored to `(b - a) * c` using the technique\nshown in a previous level, namely,\n```\nrw (show b * c - a * c = (b - a) * c, by linarith),\n```\n\nIn fact, this factoring result is built in to Lean's mathematical library as the lemma `sub_mul`.\nSo you could, alternatively, use `rw \u2190sub_mul`.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n-/\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]`, the congruence `a * c \u2261 b * c [MOD n]` follows.\n-/\nlemma mod_mul_right (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw \u2190sub_mul,\n  apply dvd_mul_of_dvd_left h,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 46, "name": "mod_mul_right", "statement": "(h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n]"}, {"type": "lean", "content": "2302", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "2303", "hidden": true}, {"type": "text", "content": "2304"}, {"type": "lean", "content": "2305", "hidden": true}, {"type": "lean", "content": "2306", "hidden": true}, {"type": "text", "content": "2307"}, {"type": "theorem", "text": "2308", "lean": "lemma mod_add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 37, "textBefore": "import congruences.mod_mul_right -- hide\n\n/-\n#  Congruences\n\n## Level 7: Adding congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a + c \u2261 b + d [MOD n]`. As before, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n-/\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a + c \u2261 b + d [MOD n]` follows.\n-/\nlemma mod_add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show b + d - (a + c) = (b - a) + (d - c), by linarith),\n  apply dvd_add h\u2081 h\u2082,\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 11, "editorText": "sorry", "lineOffset": 26, "name": "mod_add", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na + c \u2261 b + d [MOD n]"}, {"type": "lean", "content": "2309", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2310", "hidden": true}, {"type": "text", "content": "2311"}, {"type": "lean", "content": "2312", "hidden": true}, {"type": "lean", "content": "2313", "hidden": true}, {"type": "text", "content": "2314"}, {"type": "hint", "content": "2315", "title": "2316"}, {"type": "hint", "content": "2317", "title": "2318"}, {"type": "theorem", "text": "2319", "lean": "lemma mod_mul (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 57, "textBefore": "import congruences.mod_add -- hide\n\n/-\n#  Congruences\n\n## Level 8: Multiplying congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {a b c d n : \u2124} -- hide\n\n/-\n### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a * c \u2261 b * d [MOD n]`.\n\n* Write the same proof by hand.\n\nThe nicest way to do this is by using two different divisibility results.\n-/\n\n/- Hint: Starting the proof\nAs before, start by converging the congruences to divisibility statements using `rw mod_def at *`.\n-/\n\n/- Hint: A cunning rewrite\nYour next task is to rewrite the goal from `n \u2223 b * d - a * c` to something of the form\n`n \u2223 p + q`, for appropriate `p` and `q`. You can then use `apply dvd_add`.\n\nYou should then `apply` another of the divisibility results to each of the\nresulting goals.\n-/\n\n\n/- Theorem :\nGiven `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a * c \u2261 b * d [MOD n]` follows.\n-/\nlemma mod_mul (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n] :=\nbegin\n", "proof": "  rw mod_def at *,\n  rw (show b * d - (a * c) = (b - a) * d + (d - c) * a, by linarith),\n  apply dvd_add,\n  { apply dvd_mul_of_dvd_left h\u2081, },\n  { apply dvd_mul_of_dvd_left h\u2082, },\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 40, "name": "mod_mul", "statement": "(h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) :\na * c \u2261 b * d [MOD n]"}, {"type": "lean", "content": "2320", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2321", "hidden": true}, {"type": "text", "content": "2322"}, {"type": "lean", "content": "2323", "hidden": true}, {"type": "lean", "content": "2324", "hidden": true}, {"type": "text", "content": "2325"}, {"type": "text", "content": "2326"}, {"type": "lemma", "text": "2327", "lean": "lemma modeq_of_dvd_of_modeq (h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m] :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 47, "textBefore": "import congruences.mod_mul  -- hide\n\n/-\n#  Congruences\n\n## Level 9: Reduction of congruences\n-/\n\nnamespace exlean -- hide\n\nvariables {n m a b : \u2124} -- hide\n\n/-\nWe've seen the idea of reducing an integer $x$ modulo $n$. This means finding an integer $a$\nsuch that $x \\equiv a \\pmod n$ with $0 \\le a < |n|$.\n\nThe word 'reduction' has another meaning in the study of congruences.\n\nSuppose $a$, $b$, $n$ and $m$ are integers with $m \\mid n$. Suppose $a \\equiv b \\pmod n$.\nIt follows that $a \\equiv b \\pmod m$. This is called the _reduction of the congruence_\n$a \\equiv \\pmod n$, modulo $m$.\n-/\n\n/-\n### Task\nProve the reduction result mentioned above. You should be able to do this in one line by employing\nan appropriate result from Divisibility World.\n\n-/\n\n/- Lemma :\nGiven $m \\mid n$ and $a \\equiv b \\pmod n$, the congruence $a \\equiv b \\pmod m$ follows.\n-/\nlemma modeq_of_dvd_of_modeq (h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m] :=\nbegin\n", "proof": "  from dvd_trans h\u2081 h\u2082,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 12, "editorText": "sorry", "lineOffset": 35, "name": "modeq_of_dvd_of_modeq", "statement": "(h\u2081 : m \u2223 n) (h\u2082 : a \u2261 b [MOD n]) : a \u2261 b [MOD m]"}, {"type": "lean", "content": "2328", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2329", "hidden": true}, {"type": "text", "content": "2330"}, {"type": "lean", "content": "2331", "hidden": true}, {"type": "text", "content": "2332"}, {"type": "lean", "content": "2333", "hidden": true}, {"type": "hint", "content": "2334", "title": "2335"}, {"type": "theorem", "text": "2336", "lean": "lemma reduction (h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 54, "textBefore": "import congruences.mod_reduction -- hide\n/-\n#  Congruences\n\n## Level 10: Reduction of integers in general\n-/\n\nnamespace exlean -- hide\n\n/-\nWe now return to the other meaning of reduction. You will show that for all integers $x$ and $n$\nwith $n \\ne 0$, there exists an integer $a$ in the range $0 \\le a < |n|$ such that\n$x \\equiv a \\pmod n$.\n\nThe statement above has some similarity with the `division` lemma, as seen in Divisibility World.\n-/\n\nvariables {x a n : \u2124} -- hide\n\n/- Hint : A proof template\nStart by applying `division` to `x n h` and then decomposing the result:\n```\nrcases division x n h with \u27e8q, r, h\u2082 : x = n * q + r, h\u2083 : 0 \u2264 r, h\u2084 : r < |n|\u27e9,\nsorry,\n```\n-/\n\n/- Theorem :\nFor every non-zero integer $n$, there exists an integer $a$ such that $x \\equiv a \\pmod n$ with\n$0 \\le a < |n|$.\n-/\nlemma reduction (h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n) :=\nbegin\n", "proof": "  rcases (division x n h) with \u27e8m, r, hn, hrange\u27e9,\n  use r,\n  split,\n  { rw hn,\n    have h\u2082 : n * m + r \u2261 0 + r [MOD n],\n    { apply mod_add,\n      { use -m,\n        linarith, },\n      { apply mod_refl, }, },\n    rwa zero_add at h\u2082, },\n  from hrange,\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 33, "name": "reduction", "statement": "(h : n \u2260 0) : \u2203 (a : \u2124), (x \u2261 a [MOD n]) \u2227 (0 \u2264 a) \u2227 (a < abs n)"}, {"type": "lean", "content": "2337", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2338", "hidden": true}, {"type": "text", "content": "2339"}, {"type": "lean", "content": "2340", "hidden": true}, {"type": "lean", "content": "2341", "hidden": true}, {"type": "text", "content": "2342"}, {"type": "text", "content": "2343"}, {"type": "hint", "content": "2344", "title": "2345"}, {"type": "lemma", "text": "2346", "lean": "lemma dvd_of_modeq_mul_of_common_divisor (h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor a n d) : \nd \u2223 b :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 54, "textBefore": "import congruences.reduction2  -- hide\n\n/-\n#  Congruences\n\n## Level 11: A necessary condition for solving a linear congruence\n-/\n\nnamespace exlean -- hide\n\nvariables {n d a b x : \u2124} -- hide\n\n/-\nSuppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n-/\n\n/-\n### Task\nProve the reduction result mentioned above, first by hand and then in Lean.\n-/\n\n/- Hint : A useful result\nRecall that if $d \\mid n$, and $s \\equiv t \\pmod n$, then $s \\equiv t \\pmod d$. We called this result\n`modeq_of_dvd_of_modeq`.\n-/\n\n/- Lemma : \nSuppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n-/\nlemma dvd_of_modeq_mul_of_common_divisor (h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor a n d) : \nd \u2223 b :=\nbegin\n", "proof": "  rcases h\u2082 with \u27e8hda, hdn\u27e9,\n  have h\u2083 : a * x \u2261 b [MOD d], from modeq_of_dvd_of_modeq hdn h\u2081,\n  rw \u2190modeq_zero_iff',\n  have h\u2084 : 0 \u2261 a * x [MOD d],\n  { rw modeq_zero_iff', \n    apply dvd_mul_of_dvd_left hda, },\n  apply mod_trans h\u2084 h\u2083,\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 20, "editorText": "sorry", "lineOffset": 34, "name": "dvd_of_modeq_mul_of_common_divisor", "statement": "(h\u2081 : a * x \u2261 b [MOD n]) (h\u2082 : common_divisor a n d) : \nd \u2223 b"}, {"type": "lean", "content": "2347", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2348", "hidden": true}, {"type": "text", "content": "2349"}, {"type": "lean", "content": "2350", "hidden": true}, {"type": "lean", "content": "2351", "hidden": true}, {"type": "text", "content": "2352"}, {"type": "lean", "content": "2353", "hidden": false}, {"type": "text", "content": "2354"}, {"type": "text", "content": "2355"}, {"type": "lemma", "text": "2356", "lean": "lemma no_soln_12_x_cong_10_mod_60 : \u00ac (12 * x \u2261 10 [MOD 60]) :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 81, "textBefore": "import congruences.condition_for_linear_congruence -- hide\n\n/-\n#  Congruences\n\n## Level 12: A linear congruence without a solution\n-/\n\nnamespace exlean -- hide\n\nvariables {x : \u2124} -- hide\n\n/-\nIt's easy to check that a given value $x$ _is_ a solution of a linear congruence.\n-/\n\nexample (h : x = 5) : 7 * x \u2261 3 [MOD 4] :=\nbegin\n  rw h, -- `\u22a2 7 * 5 \u2261 3 [MOD 4]`\n  use -8, -- `\u22a2 3 - 7 * 5 = 4 * -8`\n  norm_num,\nend\n\n\n/-\nIt's significantly more difficuult to show that a congruence doesn't have a solution.\n\nIn the previous level, you showed that the congruence $ax \\equiv b \\pmod n$ has a solution only if\n$d \\mid b$, where $d$ is a common divisor of $a$ and $n$.\n\nIn this level, you'll use this to show that a certain linear congruence has no solutions.\nThis boils down to showing that a number doesn't divide another number, a topic we covered in\nDivision World.\n-/\n\n/-\n### Task\n\nUsing the ideas above and any other lemmas you've seen, show that\nthere is no $x$ for which  $12 x \\equiv 10 \\pmod {60}$.\n-/\n\n/- Lemma : no-side-bar\nThe congruence $12 x \\equiv 10 \\pmod {60}$ has no solution for $x$.\n-/\nlemma no_soln_12_x_cong_10_mod_60 : \u00ac (12 * x \u2261 10 [MOD 60]) :=\nbegin\n", "proof": "  assume h : 12 * x \u2261 10 [MOD 60],\n  have h\u2082 : common_divisor 12 60 12,\n  { split; norm_num, },\n  have h\u2083 : 12 * x \u2261 10 [MOD 12], from modeq_of_dvd_of_modeq h\u2082.2 h,\n  have h\u2084 : (12 : \u2124) \u2223 10,\n  { rw \u2190modeq_zero_iff',\n    apply mod_trans,\n    swap,\n    from h\u2083,\n    use x,\n    linarith, },\n  cases h\u2084 with k h\u2084,\n  suffices h\u2085 : (k = 0) \u2227 ((0 : \u2124) = 10), linarith,\n  apply division_unique 10 12;\n  tidy,\n\n\n/-   assume h : 12 * x \u2261 10 [MOD 60],\n  cases h with m h,\n  have h\u2081 : 10 = 60 * m + 12 * x, linarith,\n  have h\u2082 : (12 : \u2124) \u2223 10,\n  { rw h\u2081,\n    apply dvd_mul_add_mul;\n    norm_num, },\n  cases h\u2082 with k h\u2082,\n  suffices h\u2085 : (k = 0) \u2227 ((0 : \u2124) = 10), linarith, \n  apply division_unique 10 12;\n  tidy, -/\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 34, "editorText": "sorry", "lineOffset": 47, "name": "no_soln_12_x_cong_10_mod_60", "statement": "\u00ac (12 * x \u2261 10 [MOD 60])"}, {"type": "lean", "content": "2357", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2358", "hidden": true}, {"type": "text", "content": "2359"}, {"type": "lean", "content": "2360", "hidden": true}, {"type": "lean", "content": "2361", "hidden": true}, {"type": "text", "content": "2362"}, {"type": "text", "content": "2363"}, {"type": "hint", "content": "2364", "title": "2365"}, {"type": "hint", "content": "2366", "title": "2367"}, {"type": "lemma", "text": "2368", "lean": "lemma modeq_mul_eq_one_of_coprime (h : greatest_common_divisor a n 1) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n] :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 62, "textBefore": "import congruences.linear_congruences_no_soln-- hide\n\n/-\n#  Congruences\n\n## Level 13: Solving a linear congruence\n-/\n\nnamespace exlean -- hide\n\nvariables {a n x : \u2124} -- hide\n\n/-\nWe've seen a necessary condition for a linear congruence to have a solution. You'll now prove a\nsufficient condition.\n\nSpecifically, you'll show that if $1$ is a greatest common divisor of $a$ and $n$, then the \ncongruence $ax \\equiv 1 \\pmod n$ has a solution for $x$.\n-/\n\n\n/-\n### Task\n\nProve the result above, both by hand and in Lean.\n-/\n\n/- Hint : Useful results\nFrom the Divisibility world, you'll need both B\u00e9zout's Lemma and the uniqueness\nof greatest common divisor.\n-/\n\n/- Hint : A proof template\nUse the following to start your proof.\n```\nrcases (bezout a n) with \u27e8d, s, t, hgcd, hdnn, heq\u27e9,\nsorry,\n```\n-/\n\n/- Lemma :\nIf $1$ is a greatest common divisor of $a$ and $n$, then there exists an integer $x$ such that\n$a x \\equiv 1 \\pmod n$.\n-/\nlemma modeq_mul_eq_one_of_coprime (h : greatest_common_divisor a n 1) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n] :=\nbegin\n", "proof": "  rcases (bezout a n) with \u27e8d, s, t, hgcd, hdnn, heq\u27e9,\n  have h\u2082 : d = 1, from uniqueness_of_greatest_common_divisor hdnn zero_le_one hgcd h,\n  subst h\u2082,\n  use [s, t],\n  linarith,\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 46, "name": "modeq_mul_eq_one_of_coprime", "statement": "(h : greatest_common_divisor a n 1) : \u2203 (x : \u2124), a * x \u2261 1 [MOD n]"}, {"type": "lean", "content": "2369", "hidden": true}]}], "parents": [9]}, {"name": "2370", "levels": [{"name": "", "problemIndex": 19, "objects": [{"type": "lean", "content": "2371", "hidden": true}, {"type": "text", "content": "2372"}, {"type": "text", "content": "2373"}, {"type": "text", "content": "2374"}, {"type": "lean", "content": "2375", "hidden": true}, {"type": "lean", "content": "2376", "hidden": true}, {"type": "lean", "content": "2377", "hidden": true}, {"type": "axiom", "content": "2378", "name": "mul_one", "sideBar": true}, {"type": "axiom", "content": "2379", "name": "one_mul", "sideBar": true}, {"type": "axiom", "content": "2380", "name": "mul_assoc", "sideBar": true}, {"type": "axiom", "content": "2381", "name": "mul_left_inv", "sideBar": true}, {"type": "lean", "content": "2382", "hidden": false}, {"type": "text", "content": "2383"}, {"type": "text", "content": "2384"}, {"type": "text", "content": "2385"}, {"type": "axiom", "content": "2386", "name": "eq_one_of_self_mul_eq", "sideBar": true}, {"type": "lean", "content": "2387", "hidden": false}, {"type": "text", "content": "2388"}, {"type": "text", "content": "2389"}, {"type": "theorem", "text": "2390", "lean": "theorem inv_inv : (a\u207b\u00b9)\u207b\u00b9 = a :=\n", "sideBar": true, "firstProofLineNumber": 145, "firstProofHintLineNumber": 146, "lastProofHintLineNumber": 147, "lastProofLineNumber": 157, "textBefore": "import  group.basic -- hide\n\n/-\n# Groups\n\n## Level 1: The group axioms; the inverse of an inverse\n-/\n\n/-\nA group $(G, \\ast)$ is a type (or set) $G$ together with a binary operation $\\ast : G \\times G \\to G$\nand a special element $e_G \\in G$ satisfying the following properties (called the _group axioms_):\n* [identity] for every $a : G$, $a \\ast e_G = a$ and $e_G \\ast a = a$.\n* [associativity] for all $a, b, c : G$, $(a \\ast b) \\ast c = a \\ast (b \\ast c)$\n* [inverse] for every $a : G$, there exists $b : G$ such that $a \\ast b = e_G$ and $b \\ast a = e_G$.\n-/\n\n/-\n### Groups in Lean\n\nIn Lean, we write $1$ for the identity element $e_G$ of a group. The symbol `1` here isn't \n(necessarily) the same as the ordinary number $1$.\n\nThe group axioms in Lean are the following:\n* `mul_one : \u2200 (a : G), a * 1 = a`\n* `one_mul : \u2200 (a : G), 1 * a = a`\n* `mul_assoc : \u2200 (a b c : G), (a * b) * c = a * (b * c)`\n* `mul_left_inv : \u2200 (a : G), a\u207b\u00b9 * a = 1` (note `a\u207b\u00b9` is typed `a\\inv` or `a\\-1`)\n\nIf you forget them, you can refresh your memory using the 'Groups' drop-down in the\n'Theorem statements' drop-down menu on the left \n\nHere are the group axioms in practice.\n-/\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n/- Axiom : mul_one\n(a : G) : a * 1 = a\n-/\n\n/- Axiom : one_mul\n(a : G) : 1 * a = a\n-/\n\n/- Axiom : mul_assoc\n(a b c : G) : (a * b) * c = a * (b * c)\n-/\n\n/- Axiom : mul_left_inv\n(a : G) : a\u207b\u00b9 * a = 1\n-/\n\nexample : a * 1 = a := mul_one a\n\nexample : 1 * a = a := one_mul a\n\nexample : (a * b) * c = a * (b * c) := mul_assoc a b c\n\nexample : a\u207b\u00b9 * a = 1 := mul_left_inv a\n\n/-\nTogether, `mul_one` and `one_mul` are equivalent to the 'normal' group identity axiom; `mul_assoc`\nis the same as the normal associativity axiom. The odd-one-out is `mul_left_inv`.\n\nRather than merely asserting the existence of an inverse of `g`, we name the inverse `g\u207b\u00b9`.\nMoreover, the `mul_left_inv` axiom only provides that `g\u207b\u00b9` is a left inverse of `g`.\nAs we'll soon see, the right inverse property can be proved from the other properties.\n\n-/\n\n/-\n### Uniqueness of identity\n\n**Theorem**:\nSuppose $b$ is an element of $G$ such that for every $a : G$, $b \\ast a = a$,\nthen $b = 1$.\n\nWe'll give a proof 'by calculation'. This is a series of equations, each with its own proof, \nstarting with the left-side and ending with the right-side of the desired equation $b = 1$.\n\n**Proof**:\n$$\n\\begin{align}\nb &= b \\ast 1 && \\text{[by identity axiom (mul one)]}\\\\\\\\\n&= b \\ast (b^{-1} \\ast b) && \\text{[by left inverse]} \\\\\\\\\n& = (b \\ast b^{-1}) \\ast b && \\text{[by associativity]} \\\\\\\\\n& = b^{-1} \\ast b && \\text{[by the hypothesis]} \\\\\\\\\n& = 1. && \\text{[by left inverse]}\n\\end{align}\n$$\n\u220e\n-/\n\n/-\nThe Lean proof of this result is remarkably similar to the handwritten proof:\n-/\n\n/- Axiom : eq_one_of_self_mul_eq\n(h : \u2200 (a : G), b * a = a) : b = 1\n-/\nlemma eq_one_of_self_mul_eq (h : \u2200 (a : G), b * a = a) : b = 1 :=\nbegin\n  calc\n    b = b * 1         : by rw mul_one\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n  ... = b\u207b\u00b9 * b       : by rw h\n  ... = 1             : by rw mul_left_inv\nend\n\n/-\nAbove, `calc` indicates that we are starting a proof by calculation. The\nproof for each line of calculation is shown after the colon.\n\nConsider the following two lines from the proof.\n```\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n```\nThe second line asserts `b = (b\u207b\u00b9 * b) = (b * b\u207b\u00b9) * b`, the proof of which is: `by rw mul_assoc`\n-/\n\n/-\n### Tasks\n\n* By hand, write a proof that if $a$ is an element of a group $G$, then $(a^{-1})^{-1} = a$. Use\nonly the group axoims from Lean (in particular, you may not use the 'right inverse' property).\n\n* Complete the Lean 'proof by calculation' below. I have supplied a suggested first\nline of the proof. You will need to add intermediate lines and replace all\n`sorry`s with proofs. I suggest working from top to bottom, one line at a time. By this process,\nyou may check if your proof is 'structurally correct', the test of which is that Lean will\nprovide no error message.\n-/\n\n/- Theorem : \nThe inverse of the inverse of $a$ is $a$.\n-/\ntheorem inv_inv : (a\u207b\u00b9)\u207b\u00b9 = a :=\nbegin\n", "proof": "/- hint\n  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry\n-/\n  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by rw mul_one\n  ... = (a\u207b\u00b9)\u207b\u00b9 * (a\u207b\u00b9 * a)   : by rw mul_left_inv\n  ... = ((a\u207b\u00b9)\u207b\u00b9 * a\u207b\u00b9) * a   : by rw mul_assoc\n  ... = 1 * a                 : by rw mul_left_inv\n  ... = a                     : by rw one_mul\n\n\n\n  ", "proof_hint": "  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "  calc (a\u207b\u00b9)\u207b\u00b9 = (a\u207b\u00b9)\u207b\u00b9 * 1  : by sorry\n  ... = a                     : by sorry", "lineOffset": 144, "name": "inv_inv", "statement": "(a\u207b\u00b9)\u207b\u00b9 = a"}, {"type": "lean", "content": "2391", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2392", "hidden": true}, {"type": "text", "content": "2393"}, {"type": "lean", "content": "2394", "hidden": true}, {"type": "lean", "content": "2395", "hidden": true}, {"type": "lean", "content": "2396", "hidden": true}, {"type": "text", "content": "2397"}, {"type": "theorem", "text": "2398", "lean": "theorem mul_right_inv : b * b\u207b\u00b9 = 1 :=\n", "sideBar": true, "firstProofLineNumber": 36, "firstProofHintLineNumber": 37, "lastProofHintLineNumber": 38, "lastProofLineNumber": 45, "textBefore": "import  group.inv_inv -- hide\n\n/-\n# Groups\n\n## Level 2: Right inverse\n-/\n\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n\n/-\nIn the previous level, we introduced the left inverse axiom for groups. In this level, you'll\n*prove* that the right inverse property follows from the other group axioms.\n\n\n### Tasks\n\n* By hand, write a proof that if $b$ is an element of a group $G$, then $b * b^{-1} = 1$. You may\nuse any axioms or theorems proved in the previous level.\n\n* Complete the Lean 'proof by calculation' below.\n-/\n\n/- Theorem : \n$b \\ast b^{-1} = 1$.\n-/\ntheorem mul_right_inv : b * b\u207b\u00b9 = 1 :=\nbegin\n", "proof": "/- hint\n  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry\n-/\n  calc b * b\u207b\u00b9 = (b\u207b\u00b9)\u207b\u00b9 * b\u207b\u00b9 : by rw inv_inv\n  ... = 1                      : by rw mul_left_inv\n\n\n\n  ", "proof_hint": "  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 10, "editorText": "  calc b * b\u207b\u00b9 = sorry : by sorry\n  ... = 1              : by sorry", "lineOffset": 35, "name": "mul_right_inv", "statement": "b * b\u207b\u00b9 = 1"}, {"type": "lean", "content": "2399", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2400", "hidden": true}, {"type": "text", "content": "2401"}, {"type": "lean", "content": "2402", "hidden": true}, {"type": "lean", "content": "2403", "hidden": true}, {"type": "lean", "content": "2404", "hidden": true}, {"type": "text", "content": "2405"}, {"type": "theorem", "text": "2406", "lean": "lemma inv_eq_of_mul_eq_one (h : a * b = 1) : a\u207b\u00b9 = b :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 47, "textBefore": "import group.mul_right_inv -- hide\n\n/-\n# Groups\n\n## Level 3: Uniqueness of inverse\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] {a b c : G} -- hide\n\n\n/-\nIn the first level of this world, you saw the 'uniqueness of identity' result. In this level,\nyou'll prove an equivalent 'uniqueness of inverse' result.\n\n\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$ and if $a \\ast b = 1$, then\n$a^{-1}$ equals $b$. You will only need the group axioms.\n\n* Write a Lean proof by calculation, using only the group axioms.\n-/\n\n/- Theorem : \nIf $a \\ast b = 1$, then $a^{-1} = b$.\n-/\nlemma inv_eq_of_mul_eq_one (h : a * b = 1) : a\u207b\u00b9 = b :=\nbegin\n", "proof": "  calc a\u207b\u00b9 = a\u207b\u00b9 * 1    : by rw mul_one\n  ... = a\u207b\u00b9 * (a * b)   : by rw h\n  ... = (a\u207b\u00b9 * a) * b   : by rw mul_assoc\n  ... = 1 * b           : by rw mul_left_inv\n  ... = b               : by rw one_mul\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 34, "name": "inv_eq_of_mul_eq_one", "statement": "(h : a * b = 1) : a\u207b\u00b9 = b"}, {"type": "lean", "content": "2407", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2408", "hidden": true}, {"type": "text", "content": "2409"}, {"type": "lean", "content": "2410", "hidden": true}, {"type": "lean", "content": "2411", "hidden": true}, {"type": "lean", "content": "2412", "hidden": true}, {"type": "text", "content": "2413"}, {"type": "hint", "content": "2414", "title": "2415"}, {"type": "theorem", "text": "2416", "lean": "theorem mul_inv_rev : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9 :=\n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 52, "textBefore": "import group.unique_inverse -- hide\n\n/-\n# Groups\n\n## Level 4: The inverse of a product\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} [group G] (a b c : G) -- hide\n\n\n/-\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$, then\n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n\n* Complete the Lean proof below.\n-/\n\n/- Hint : A helpful result\nYou've seen `inv_eq_of_mul_eq_one`. This result states that if `s * t = 1`, then `s\u207b\u00b9 = t`.\nHere, you can apply this result, via `apply inv_eq_of_mul_eq_one` to change the\ngoal to one of proving `(a * b) * (b\u207b\u00b9 * a\u207b\u00b9) = 1`.\n\nThis latter goal can be proved by calculation.\n-/\n\n/- Theorem : \n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n-/\ntheorem mul_inv_rev : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9 :=\nbegin\n", "proof": "  apply inv_eq_of_mul_eq_one,\n  calc (a * b) * (b\u207b\u00b9 * a\u207b\u00b9)\n      = a * (b * (b\u207b\u00b9 * a\u207b\u00b9))   : by rw mul_assoc\n  ... = a * ((b * b\u207b\u00b9) * a\u207b\u00b9)   : by rw mul_assoc\n  ... = a * (1 * a\u207b\u00b9)           : by rw mul_right_inv\n  ... = a * a\u207b\u00b9                 : by rw one_mul\n  ... = 1                       : by rw mul_right_inv\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 14, "editorText": "sorry", "lineOffset": 38, "name": "mul_inv_rev", "statement": "(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9"}, {"type": "lean", "content": "2417", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2418", "hidden": true}, {"type": "text", "content": "2419"}, {"type": "lean", "content": "2420", "hidden": true}, {"type": "lean", "content": "2421", "hidden": true}, {"type": "lean", "content": "2422", "hidden": true}, {"type": "text", "content": "2423"}, {"type": "lemma", "text": "2424", "lean": "lemma mul_left_cancel (h : a * b = a * c) : b = c :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 50, "textBefore": "import  group.mul_inv_rev -- hide\n\n/-\n# Groups\n\n## Level 5: Left cancellation\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G}  -- hide\n\n/-\nJust as with 'ordinary' multiplication, we can cancel the same factor on the left of\nboth sides of an equation.\n\n### Tasks\n\n* Give a handwritten proof that if $a \\ast b = a \\ast c$, then $b = c$.\n\n* Give a Lean 'proof by calculation' below.\n-/\n\n\n/- Lemma :\nIf $a \\ast b = a \\ast c$, then $b = c$.\n-/\nlemma mul_left_cancel (h : a * b = a * c) : b = c :=\nbegin\n", "proof": "  calc b = 1 * b      : by rw one_mul\n  ... = (a\u207b\u00b9 * a) * b : by rw mul_left_inv\n  ... = a\u207b\u00b9 * (a * b) : by rw mul_assoc\n  ... = a\u207b\u00b9 * (a * c) : by rw h\n  ... = (a\u207b\u00b9 * a) * c : by rw mul_assoc\n  ... = 1 * c         : by rw mul_left_inv\n  ... = c             : by rw one_mul\n\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 18, "editorText": "sorry", "lineOffset": 32, "name": "mul_left_cancel", "statement": "(h : a * b = a * c) : b = c"}, {"type": "lean", "content": "2425", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "2426", "hidden": true}, {"type": "text", "content": "2427"}, {"type": "lean", "content": "2428", "hidden": true}, {"type": "lean", "content": "2429", "hidden": true}, {"type": "lean", "content": "2430", "hidden": true}, {"type": "text", "content": "2431"}, {"type": "lemma", "text": "2432", "lean": "lemma inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 50, "textBefore": "import  group.left_cancellation -- hide\n\n/-\n# Groups\n\n## Level 6: Injectivity of inverse\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G)  -- hide\n\n/-\nOne way to prove two group elements are equal is to show that their inverses are equal.\n\n### Tasks\n\n* Give a handwritten proof that if $a$ and $b$ are group elements, then\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n\n* Give a Lean proof of this result.\n-/\n\n\n/- Lemma :\nLet $a$ and $b$ be elements of a group $G$. We have\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n-/\nlemma inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b :=\nbegin\n", "proof": "  split,\n  { assume h : a\u207b\u00b9 = b\u207b\u00b9,\n    calc a = a\u207b\u00b9\u207b\u00b9  : by rw inv_inv\n    ... = b\u207b\u00b9\u207b\u00b9     : by rw h\n    ... = b         : by rw inv_inv },\n  { assume h : a = b,\n    show a\u207b\u00b9 = b\u207b\u00b9, rw h,}\n\n\n\n\n\n\n\n\n\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 33, "name": "inv_inj", "statement": "a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b"}, {"type": "lean", "content": "2433", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "2434", "hidden": true}, {"type": "text", "content": "2435"}, {"type": "lean", "content": "2436", "hidden": true}, {"type": "lean", "content": "2437", "hidden": true}, {"type": "lean", "content": "2438", "hidden": true}, {"type": "text", "content": "2439"}, {"type": "axiom", "content": "2440", "name": "mul_left_cancel_iff", "sideBar": true}, {"type": "lean", "content": "2441", "hidden": false}, {"type": "text", "content": "2442"}, {"type": "hint", "content": "2443", "title": "2444"}, {"type": "lemma", "text": "2445", "lean": "lemma mul_right_cancel_iff : b * a = c * a \u2194 b = c :=\n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 65, "textBefore": "import  group.injectivity_of_inverse -- hide\n\n/-\n# Groups\n\n## Level 7: Right cancellation\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G)  -- hide\n\n/-\nFrom the left cancellation result, we cheaply prove an iff result.\n-/\n\n/- Axiom : mul_left_cancel_iff\n(a b c : G) : a * b = a * c \u2194 a = b\n-/\nlemma mul_left_cancel_iff : a * b = a * c \u2194 b = c :=\nbegin\n  split,\n  { assume h : a * b = a * c,\n    show b = c, exact mul_left_cancel h, },\n  { assume h : b = c,\n    show a * b = a * c, rw h,\n  }\nend\n\n/-\n### Tasks\n\n* Give a handwritten proof of the right cancellation result, that\n$b \\ast a = c \\ast a \\leftrightarrow b = c$. \n\n* Give a Lean proof of this result.\n-/\n\n\n/- Hint : Proof ideas\nA proof by calculation will work here. The result `inv_inj` may prove to be highly effective.\n-/\n\n/- Lemma :\nLet $a$ and $b$ be elements of a group $G$. We have\n$b \\ast a = c \\ast a \\leftrightarrow b = c$.\n-/\nlemma mul_right_cancel_iff : b * a = c * a \u2194 b = c :=\nbegin\n", "proof": "  rw [\u2190inv_inj, mul_inv_rev, mul_inv_rev, mul_left_cancel_iff, inv_inj],\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 13, "editorText": "sorry", "lineOffset": 52, "name": "mul_right_cancel_iff", "statement": "b * a = c * a \u2194 b = c"}, {"type": "lean", "content": "2446", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "2447", "hidden": true}, {"type": "text", "content": "2448"}, {"type": "lean", "content": "2449", "hidden": true}, {"type": "lean", "content": "2450", "hidden": true}, {"type": "lean", "content": "2451", "hidden": true}, {"type": "text", "content": "2452"}, {"type": "axiom", "content": "2453", "name": "pow_zero", "sideBar": true}, {"type": "axiom", "content": "2454", "name": "pow_succ", "sideBar": true}, {"type": "lean", "content": "2455", "hidden": false}, {"type": "lean", "content": "2456", "hidden": true}, {"type": "lean", "content": "2457", "hidden": false}, {"type": "text", "content": "2458"}, {"type": "text", "content": "2459"}, {"type": "hint", "content": "2460", "title": "2461"}, {"type": "lemma", "text": "2462", "lean": "lemma pow_one : a ^ 1 = a :=\n", "sideBar": true, "firstProofLineNumber": 73, "firstProofHintLineNumber": 80, "lastProofHintLineNumber": 82, "lastProofLineNumber": 85, "textBefore": "import  group.right_cancellation group.power_def -- hide\n\n/-\n# Groups\n\n## Level 8: Powers\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G) {n m : \u2115} -- hide\n\n/-\nExponentiation is defined to be repeated multiplication. That is, if $a$ is an element of a group\n$G$, then $a^0 := 1$ and $a^{n + 1} := a \\ast a^n$, for a natural number $n$.\n\nIn Lean, these defining equations are called `pow_zero` and `pow_succ`.\n-/\n\n/- Axiom : pow_zero\n(a : G) : a ^ 0 = 1\n-/\n\n/- Axiom : pow_succ\n(a : G) : a ^ (n + 1) = a * a ^ n\n-/\n\nexample : a ^ 0 = 1 :=\nbegin\n  rw pow_zero,\nend\n\n-- hide\n\nexample : a ^ (n + 1) = a * a ^ n :=\nbegin\n  rw pow_succ,\nend\n\n\n/-\nIn the next few levels, we will prove the laws of indices.\nThat is, we'll show that if $a : G$ and $n, m : \\mathbb N$, then:\n* $a ^ 1 = a$,\n* $1 ^ n = 1$,\n* $a ^{n + m} = a ^ n \\ast a ^ m$,\n* $a^{nm} = (a ^ n) ^ m$.\n-/\n\n/-\n### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n-/\n\n/- Hint : Proving arithmetic results\nAny arithmetic result you may need for this level can be proved using the\n`trivial` tactic.\n-/\n\n\n/- Lemma : \n$a^1 = a$, for $a$ an element of a group.\n-/\nlemma pow_one : a ^ 1 = a :=\nbegin\n", "proof": "  calc\n  a ^ 1 = a ^ (0 + 1) : by refl\n    ... = a * a^0     : by rw pow_succ\n    ... = a * 1       : by rw pow_zero\n    ... = a           : by rw mul_one,\n\n/- hint\ncalc\na ^ 1 = sorry       : sorry\n  ... = a           : sorry,\n-/\n\n  ", "proof_hint": "calc\na ^ 1 = sorry       : sorry\n  ... = a           : sorry,", "textAfter": "\nend \n\nend exlean -- hide", "height": 13, "editorText": "calc\na ^ 1 = sorry       : sorry\n  ... = a           : sorry,", "lineOffset": 72, "name": "pow_one", "statement": "a ^ 1 = a"}, {"type": "lean", "content": "2463", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2464", "hidden": true}, {"type": "text", "content": "2465"}, {"type": "lean", "content": "2466", "hidden": true}, {"type": "lean", "content": "2467", "hidden": true}, {"type": "lean", "content": "2468", "hidden": true}, {"type": "text", "content": "2469"}, {"type": "text", "content": "2470"}, {"type": "lemma", "text": "2471", "lean": "lemma one_pow : (1 : G) ^ n = 1 :=\n", "sideBar": true, "firstProofLineNumber": 41, "firstProofHintLineNumber": 42, "lastProofHintLineNumber": 54, "lastProofLineNumber": 72, "textBefore": "import group.pow_one tactic.modded -- hide\n\n/-\n# Groups\n\n## Level 9: One pow\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n\n/-\nIn this level, you'll prove, by induction on $n$, that\n$1 ^ n = 1$, for every natural number $n$. Here, $1$ is the\nidentity element in the group $G$.\n\nSometimes, you will need to write `(1 : G)` otherwise Lean will treat\n`1` as the natural number $1$ rather than the identity in the group $G$.\n-/\n\n\n/-\n### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n-/\n\n\n/- Lemma : \n$1^n = 1$, for $n$ a natural number and $1$ the identity in a group.\n-/\nlemma one_pow : (1 : G) ^ n = 1 :=\nbegin\n", "proof": "/- hint\ninduction n,\n\ncase zero :\n{ show (1 : G) ^ 0 = 1,\n  sorry },\n\ncase succ : k ih\n{ given ih : (1 : G) ^ k = 1,\n  show (1 : G) ^ (k + 1) = 1,\n  calc\n  (1 : G) ^ (k + 1)\n      = sorry     : sorry\n  ... = 1         : sorry, },\n-/\n  induction n,\n\n  case zero :\n  { show (1 : G) ^ 0 = 1,\n    rw pow_zero, },\n\n  case succ : k ih\n  { given ih : (1 : G) ^ k = 1,\n    show (1 : G) ^ (k + 1) = 1,\n    calc\n    (1 : G) ^ (k + 1)\n        = (1 * 1 ^ k : G)  : by rw pow_succ\n    ... = 1 ^ k            : by rw one_mul\n    ... = 1                 : by rw ih },\n\n\n  ", "proof_hint": "induction n,\n\ncase zero :\n{ show (1 : G) ^ 0 = 1,\n  sorry },\n\ncase succ : k ih\n{ given ih : (1 : G) ^ k = 1,\n  show (1 : G) ^ (k + 1) = 1,\n  calc\n  (1 : G) ^ (k + 1)\n      = sorry     : sorry\n  ... = 1         : sorry, },", "textAfter": "\nend \n\nend exlean -- hide", "height": 32, "editorText": "induction n,\n\ncase zero :\n{ show (1 : G) ^ 0 = 1,\n  sorry },\n\ncase succ : k ih\n{ given ih : (1 : G) ^ k = 1,\n  show (1 : G) ^ (k + 1) = 1,\n  calc\n  (1 : G) ^ (k + 1)\n      = sorry     : sorry\n  ... = 1         : sorry, },", "lineOffset": 40, "name": "one_pow", "statement": "(1 : G) ^ n = 1"}, {"type": "lean", "content": "2472", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2473", "hidden": true}, {"type": "text", "content": "2474"}, {"type": "lean", "content": "2475", "hidden": true}, {"type": "lean", "content": "2476", "hidden": true}, {"type": "lean", "content": "2477", "hidden": true}, {"type": "text", "content": "2478"}, {"type": "text", "content": "2479"}, {"type": "lemma", "text": "2480", "lean": "lemma pow_succ' (a : G) (n : \u2115) : a ^ (n+1) = a ^ n * a :=\n", "sideBar": true, "firstProofLineNumber": 39, "firstProofHintLineNumber": 41, "lastProofHintLineNumber": 56, "lastProofLineNumber": 86, "textBefore": "import group.one_pow tactic.modded -- hide\n\n/-\n# Groups\n\n## Level 10: Pow succ prime\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G) {n m : \u2115} -- hide\n\n/-\nBy definition, $g^{n + 1} = g \\ast g^n$. We will now prove that\n$g^{n + 1} = g^n \\ast g$.\n-/\n\n/-\n### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result. While writing your\nproof, ensure to fill in the underscores in the inductive step\nto state both the inductive hypothesis and the result to be proved.\n\n-/\n\n\n/- Lemma : \n$a^{n + 1} = a^n \\ast a$, for $n$ a natural number and $a$ an\nelement of the group $G$.\n-/\nlemma pow_succ' (a : G) (n : \u2115) : a ^ (n+1) = a ^ n * a :=\nbegin\n", "proof": "\n/- hint\ninduction n,\n\ncase zero :\n{ show a ^ (0 + 1) = a ^ 0 * a,\n  calc\n  a ^ (0 + 1)\n      = sorry     : sorry\n  ... = a ^ 0 * a : sorry, },\n\ncase succ : k ih\n{ given ih : _,\n  show _,\n  calc\n  a ^ ((k + 1) + 1)\n      = sorry               : sorry\n  ... = a ^ (k + 1) * a     : sorry },\n-/\n  induction n,\n\n  case zero :\n  { show a ^ (0 + 1) = a ^ 0 * a,\n    calc\n    a ^ (0 + 1)\n        = a ^ 1     : by refl\n    ... = a         : by rw pow_one\n    ... = 1 * a     : by rw one_mul\n    ... = a ^ 0 * a : by rw pow_zero, },\n\n  case succ : k ih\n  { given ih : a ^ (k + 1) = a ^ k * a,\n    show a ^ ((k + 1) + 1) = a ^ (k + 1) * a,\n    calc\n    a ^ ((k + 1) + 1)\n        = a * a ^ (k + 1)     : by rw pow_succ\n    ... = a * (a ^ k * a)     : by rw ih\n    ... = (a * a ^ k) * a     : by rw mul_assoc\n    ... = (a ^ (k + 1)) * a   : by rw pow_succ },\n\n\n\n\n\n\n\n\n  ", "proof_hint": "induction n,\n\ncase zero :\n{ show a ^ (0 + 1) = a ^ 0 * a,\n  calc\n  a ^ (0 + 1)\n      = sorry     : sorry\n  ... = a ^ 0 * a : sorry, },\n\ncase succ : k ih\n{ given ih : _,\n  show _,\n  calc\n  a ^ ((k + 1) + 1)\n      = sorry               : sorry\n  ... = a ^ (k + 1) * a     : sorry },", "textAfter": "\nend \n\nend exlean -- hide", "height": 48, "editorText": "induction n,\n\ncase zero :\n{ show a ^ (0 + 1) = a ^ 0 * a,\n  calc\n  a ^ (0 + 1)\n      = sorry     : sorry\n  ... = a ^ 0 * a : sorry, },\n\ncase succ : k ih\n{ given ih : _,\n  show _,\n  calc\n  a ^ ((k + 1) + 1)\n      = sorry               : sorry\n  ... = a ^ (k + 1) * a     : sorry },", "lineOffset": 38, "name": "pow_succ'", "statement": "(a : G) (n : \u2115) : a ^ (n+1) = a ^ n * a"}, {"type": "lean", "content": "2481", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "2482", "hidden": true}, {"type": "text", "content": "2483"}, {"type": "lean", "content": "2484", "hidden": true}, {"type": "lean", "content": "2485", "hidden": true}, {"type": "lean", "content": "2486", "hidden": true}, {"type": "text", "content": "2487"}, {"type": "text", "content": "2488"}, {"type": "hint", "content": "2489", "title": "2490"}, {"type": "hint", "content": "2491", "title": "2492"}, {"type": "lemma", "text": "2493", "lean": "lemma pow_add (a : G) (m n : \u2115) : a^(m + n) = a^m * a^n :=\n", "sideBar": true, "firstProofLineNumber": 47, "firstProofHintLineNumber": 48, "lastProofHintLineNumber": 54, "lastProofLineNumber": 80, "textBefore": "import group.pow_succ_prime tactic.modded -- hide\n\n/-\n# Groups\n\n## Level 11: Adding exponents\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n\n/-\nIn this level, you will prove $a^{m + n} = a^m \\ast a^n$ for\n$a$ in a group $G$ and natural numbers $m$ and $n$.\n-/\n\n/-\n### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n-/\n\n/- Hint : Proving arithmetic results\nAny arithmetic result you may need for this level can be proved using the\n`trivial` tactic.\n-/\n\n/- Hint : The structure of your proof\nTake inspiration from the structure of the problems in the previous\nthree levels of this world.\n-/\n\n\n/- Lemma : \n$a^{m + n} = a^m \\ast a^n$ for\n$a$ in a group $G$ and natural numbers $m$ and $n$.\n-/\nlemma pow_add (a : G) (m n : \u2115) : a^(m + n) = a^m * a^n :=\nbegin\n", "proof": "/- hint\ninduction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },\n-/\n  induction n,\n\n  case zero :\n  { show a ^ (m + 0) = a ^ m * a ^ 0,\n    calc\n    a ^ (m + 0) = a ^ m : by refl\n    ... = a ^ m * 1     : by rw mul_one\n    ... = a ^ m * a ^ 0 : by rw pow_zero, },\n\n  case succ : k ih\n  { given ih : a ^ (m + k) = a ^ m * a ^ k,\n    show a ^ (m + (k + 1)) = a ^ m * a ^ (k + 1),\n    calc\n    a ^ (m + (k + 1))\n        = a ^ ((m + k) + 1)     : by trivial\n    ... = a ^ (m + k) * a       : by rw pow_succ'\n    ... = (a ^ m * a ^ k) * a   : by rw ih\n    ... = a ^ m * (a ^ k * a)   : by rw mul_assoc\n    ... = a ^ m * a ^ (k + 1)   : by rw pow_succ', },\n\n\n\n\n\n  ", "proof_hint": "induction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },", "textAfter": "\nend \n\nend exlean -- hide", "height": 34, "editorText": "induction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },", "lineOffset": 46, "name": "pow_add", "statement": "(a : G) (m n : \u2115) : a^(m + n) = a^m * a^n"}, {"type": "lean", "content": "2494", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "2495", "hidden": true}, {"type": "text", "content": "2496"}, {"type": "lean", "content": "2497", "hidden": true}, {"type": "lean", "content": "2498", "hidden": true}, {"type": "lean", "content": "2499", "hidden": true}, {"type": "text", "content": "2500"}, {"type": "text", "content": "2501"}, {"type": "lemma", "text": "2502", "lean": "lemma pow_mul (a : G) (m n : \u2115) : a^(m * n) = (a^m)^n :=\n", "sideBar": true, "firstProofLineNumber": 37, "firstProofHintLineNumber": 38, "lastProofHintLineNumber": 44, "lastProofLineNumber": 73, "textBefore": "import group.pow_add tactic.modded -- hide\n\n/-\n# Groups\n\n## Level 12: Multiplying exponents\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n\n/-\nIn this level, you will prove $a^{m n} = (a^m)^n$ for\n$a$ in a group $G$ and natural numbers $n$ and $m$.\n-/\n\n/-\n### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n-/\n\n\n/- Lemma : \n $a^{m n} = (a^m)^n$ for\n$a$ in a group $G$ and natural numbers $n$ and $m$.\n-/\nlemma pow_mul (a : G) (m n : \u2115) : a^(m * n) = (a^m)^n :=\nbegin\n", "proof": "/- hint\ninduction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },\n-/\n  induction n,\n\n  case zero :\n  { show a ^ (m * 0) = (a ^ m) ^ 0,\n    calc\n    a ^ (m * 0)\n        = a ^ 0       : by trivial\n    ... = 1           : by rw pow_zero\n    ... = (a ^ m) ^ 0 : by rw pow_zero, },\n\n  case succ : k ih\n  { given ih : a ^ (m * k) = (a ^ m) ^ k,\n    show a ^ (m * (k + 1)) = (a ^ m) ^ (k + 1),\n    calc\n    a ^ (m * (k + 1))\n        = a ^ (m * k + m)       : by trivial\n    ... = a ^ (m * k) * a ^ m   : by rw pow_add\n    ... = ((a ^ m) ^ k) * a ^ m : by rw ih\n    ... = (a ^ m) ^ (k + 1)     : by rw pow_succ',\n\n\n   },\n\n\n\n\n\n  ", "proof_hint": "induction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },", "textAfter": "\nend \n\nend exlean -- hide", "height": 37, "editorText": "induction n,\n\ncase zero :\n{ sorry },\n\ncase succ : k ih\n{ sorry },", "lineOffset": 36, "name": "pow_mul", "statement": "(a : G) (m n : \u2115) : a^(m * n) = (a^m)^n"}, {"type": "lean", "content": "2503", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2504", "hidden": true}, {"type": "text", "content": "2505"}, {"type": "lean", "content": "2506", "hidden": true}, {"type": "lean", "content": "2507", "hidden": true}, {"type": "lean", "content": "2508", "hidden": true}, {"type": "text", "content": "2509"}, {"type": "lean", "content": "2510", "hidden": false}, {"type": "text", "content": "2511"}, {"type": "lemma", "text": "2512", "lean": "lemma exists_pow_eq_of_poq_eq_one (h : a ^ 8 = 1) :\n\u2203 (r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\n", "sideBar": false, "firstProofLineNumber": 71, "lastProofLineNumber": 87, "textBefore": "import  group.pow_mul -- hide\n\n/-\n# Groups\n\n## Level 13: Application of powers\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G} {n m : \u2115} -- hide\n\n/-\nAs an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{26} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nnatural numbers $q$ and $r$ such that $a ^ {26} = a ^r$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be 3 and $r$ to be $5$. We must show both that $a^{26} = a^{7\\times 3 + 5}$\nand that $0 \\le 5 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{26} &= a ^ {7 \\times 3 + 5} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ 3 \\ast a ^ 5 && \\text{[by laws of indices]} \\\\\\\\\n&= 1 ^ 3 \\ast a ^ 5  && \\text{[by $h$]} \\\\\\\\\n& = a ^ 5. && \\text{[by laws of indices and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n-/\n\nexample (h : a ^ 7 = 1) :\n\u2203 (r : \u2115), a ^ 26 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use 5,\n  split,\n  { calc a ^ 26\n        = a ^ (7 * 3 + 5)     : by trivial\n    ... = (a ^ 7) ^ 3 * a ^ 5 : by rw [pow_add, pow_mul]\n    ... = (1 ^ 3) * a ^ 5     : by rw h \n    ... = a ^ 5               : by rw [one_pow, one_mul] },\n  { tidy, },\nend\n\n/-\n### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n-/\n\n\n/- Lemma : no-side-bar\nIf $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n-/\nlemma exists_pow_eq_of_poq_eq_one (h : a ^ 8 = 1) :\n\u2203 (r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\nbegin\n", "proof": "  use 7,\n  split,\n  { calc a ^ 39 = a ^ (8 * 4 + 7) : by trivial\n    ... = (a ^ 8) ^ 4 * a ^ 7     : by rw [pow_add, pow_mul]\n    ... = 1 ^ 4 * a ^ 7           : by rw [h]\n    ... = a ^ 7                   : by rw [one_pow, one_mul]  },\n  { tidy, },\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 17, "editorText": "sorry", "lineOffset": 70, "name": "exists_pow_eq_of_poq_eq_one", "statement": "(h : a ^ 8 = 1) :\n\u2203 (r : \u2115), a ^ 39 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8)"}, {"type": "lean", "content": "2513", "hidden": true}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "2514", "hidden": true}, {"type": "text", "content": "2515"}, {"type": "lean", "content": "2516", "hidden": true}, {"type": "lean", "content": "2517", "hidden": true}, {"type": "lean", "content": "2518", "hidden": true}, {"type": "text", "content": "2519"}, {"type": "axiom", "content": "2520", "name": "one_gpow", "sideBar": true}, {"type": "axiom", "content": "2521", "name": "gpow_add", "sideBar": true}, {"type": "axiom", "content": "2522", "name": "gpow_mul", "sideBar": true}, {"type": "lean", "content": "2523", "hidden": false}, {"type": "text", "content": "2524"}, {"type": "lean", "content": "2525", "hidden": false}, {"type": "text", "content": "2526"}, {"type": "text", "content": "2527"}, {"type": "lemma", "text": "2528", "lean": "lemma exists_pow_eq_of_poq_eq_one2 (h : a ^ (8 : \u2124) = 1) :\n\u2203 (r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\n", "sideBar": false, "firstProofLineNumber": 119, "lastProofLineNumber": 134, "textBefore": "import group.power_lemmas -- hide\n\n/-\n# Groups\n\n## Level 14: Negative powers\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G: Type* } [group G] {a b c : G} {n m : \u2124} -- hide\n\n/-\nWe've seen how to define $a ^ n$ where $a$ is a group element and $n$ is a natural number.\nWe can extend the definition to consider $a ^ m$, where $m$ is an integer.\n\nThere are two possibilities:\n* $m = n$ for a natural number $n$. We then take $a ^ m := a ^ n$.\n* $m = -(n + 1)$ for a natural number $n$. We define $a ^ m = (a ^ {n + 1})^{-1}$.\n\n\n### Laws of indices in Lean\n\nThe laws of indices for integers powers are virtually the same as laws of indices for natural\nnumber powers. Only the names of the results are different.\n\nTaking `n` and `m` to be integers, the laws of indices in Lean are as follows.\n* `one_gpow n : 1 ^ n = 1`\n* `gpow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `gpow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nHere they are in action!\n-/\n\n/- Axiom : one_gpow\n(n : \u2124) : 1 ^ n = 1\n-/\n\n/- Axiom : gpow_add\n(a : G) (n m : \u2124) : a ^ (n + m) = a ^ n * a ^ m\n-/\n\n/- Axiom : gpow_mul\n(a : G) (n m : \u2124) : a ^ (n * m) = (a ^ n) ^ m\n-/\n\nexample : (1 : G) ^ n = 1 := one_gpow n\n\nexample : a ^ (n + m) = a ^ n * a ^ m := gpow_add a n m\n\nexample : a ^ (n * m) = (a ^ n) ^ m := gpow_mul a n m\n\n\n\n/-\nAs an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{-22} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nintegers $q$ and $r$ such that $a ^ {-20} = a^ {7q + r}$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be $-4$ and $r$ to be $6$. We must show both that $a^{-20} = a^{7\\times (-4) + 6}$\nand that $0 \\le 6 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{-22} &= a ^ {7 \\times (-4) + 6} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ (-4) \\ast a ^ 6 && \\text{[by laws of indices]} \\\\\\\\\n& = a ^ 6. && \\text{[by laws of indices, $h$, and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n-/\n\nexample (h : a ^ (7 : \u2124) = 1) :\n\u2203 (r : \u2124), a ^ (-22 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use 6,\n  split,\n  { calc a ^ (-22 : \u2124) = a ^ ((7 : \u2124) * -4 + 6) : by trivial\n    ... = a ^ ((7 : \u2124) * -4) * a ^ (6 : \u2124) : by rw gpow_add\n    ... = a ^ (6 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul], },\n  { tidy, },\nend\n\n\n/-\nIn the proof above, note that we need to specify, on occassion, that the quantities we are\npresenting to Lean are integers, not natural numbers. We do this with a type annotation. \nFor example, `(-22 : \u2124)` is the integer `-22`. If you just type `-22`, Lean will complain that\nyou can't take negatives of natural numbers!\n-/\n\n\n/-\n### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n-/\n\n\n/- Lemma : no-side-bar\nIf $a ^ 8 = 1$, then there exists and integer $r$ such that $a ^ {-70} = a ^ r$ and\n$0 \\le r < 8$.\n-/\nlemma exists_pow_eq_of_poq_eq_one2 (h : a ^ (8 : \u2124) = 1) :\n\u2203 (r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8) :=\nbegin\n", "proof": "  use 2,\n  split,\n  { calc a ^ (-70 : \u2124) = a ^ ((8 : \u2124) * (-9) + 2) : by trivial\n    ... = a ^ ((8 : \u2124) * -9) * a ^ (2 : \u2124) : by rw gpow_add\n    ... = a ^ (2 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul],  },\n  { tidy, },\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 118, "name": "exists_pow_eq_of_poq_eq_one2", "statement": "(h : a ^ (8 : \u2124) = 1) :\n\u2203 (r : \u2124), a ^ (-70 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 8)"}, {"type": "lean", "content": "2529", "hidden": true}]}]}, {"name": "2530", "levels": [{"name": "", "problemIndex": 13, "objects": [{"type": "lean", "content": "2531", "hidden": true}, {"type": "text", "content": "2532"}, {"type": "text", "content": "2533"}, {"type": "text", "content": "2534"}, {"type": "lean", "content": "2535", "hidden": true}, {"type": "lean", "content": "2536", "hidden": true}, {"type": "lean", "content": "2537", "hidden": true}, {"type": "text", "content": "2538"}, {"type": "axiom", "content": "2539", "name": "map_mul", "sideBar": true}, {"type": "lean", "content": "2540", "hidden": true}, {"type": "lean", "content": "2541", "hidden": false}, {"type": "text", "content": "2542"}, {"type": "hint", "content": "2543", "title": "2544"}, {"type": "theorem", "text": "2545", "lean": "theorem map_one : p(1) = 1 :=\n", "sideBar": true, "firstProofLineNumber": 97, "lastProofLineNumber": 117, "textBefore": "import hom.basic -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 1: The image of the identity element\n-/\n\n/-\nLet $(G, \\ast)$ and $(H, \\odot)$ be groups.  A *group homomorphism* (or, more simply, a\n*homomorphism*), is a function $p : G \\to H$ that preserves the group structure. That is,\na function for which $p(g_1 \\ast g_2) = p(g_1) \\odot p(g_2)$, for all $g_1$ and $g_2$ in $G$.\n-/\n\n\n/-\n**Theorem** Let  $(G, \\ast)$ and $(H, \\odot)$ be groups and let $p : G \\to H$ be a homomorphism.\nThen $p(1) = 1$.\n\nIn this theorem, $1$ on the left-side of the equation denotes the identity in the group $G$ whereas\n$1$ on the right side denotes the identity in the group $H$.\n\nBefore starting the proof, recall the left cancellation result. This states that $b = c$ follows\non the assumption that $a \\ast b = a \\ast c$.\n\n**Proof**\nBy left cancellation, it suffices to prove that $p(1) \\odot p(1) = p(1) \\odot 1$.\n\nBut\n$$\n\\begin{align}\np(1)\\odot p(1)   &= p(1 \\ast 1) && \\text{[by definition of hom]} \\\\\\\\\n&= p(1)                         && \\text{[by multiplicative identity]} \\\\\\\\\n& = p(1) \\odot 1                && \\text{[by multiplicative identity]}\n\\end{align}\n$$\n\u220e\n-/\n\n\n\nnamespace exlean -- hide\n\nopen group hom_class -- hide\n\nvariables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H]  (p : F) (a b : G) -- hide\n\n\n/-\n### Homomorphisms in Lean\n\nSuppose `G` and `H` are groups in Lean. Suppose that `p` is a group homomorphism. Given\nthat `a` and `b` are elements of `G`, the Lean result `map_mul` asserts that\n`p(a * b) = p(a) * p(b)`.\n\n**WARNING**: To save effort, Lean uses the symbol `*` for the multiplication operator in every\ngroup. Thus, the `*` in the left side of the above equation refers to multiplication in the\ngroup `G` while the symbol `*` in the right side refers to multiplication in the group `H`.\n-/\n\n/- Axiom : map_mul\np (a * b) = p(a) * p(b)\n-/\n\ninclude hc -- hide\n\nexample : p (a * b) = p(a) * p(b) :=\nbegin\n  rw map_mul,\nend\n\n/-\n### Tasks\n\nFollowing the ideas above, prove that $p(1) = 1$ for a group homomorphism\n$p : G \\to H$. As noted above, `map_mul` is the Lean name for the defining\nproperty of group homomorphisms.\n-/\n\n/- Hint : A proof template\nStart with\n```\n  apply mul_left_cancel,\n  show p(1) * p(1) = p(1) * 1,\n  calc\n    p(1) * p(1)\n        = sorry    : sorry\n    ... = p(1) * 1 : sorry\n```\n-/\n\n/- Theorem : \nThe inverse of the inverse of $a$ is $a$.\n-/\ntheorem map_one : p(1) = 1 :=\nbegin\n", "proof": "  apply mul_left_cancel,\n  show p(1) * p(1) = p(1) * 1,\n  calc\n    p(1) * p(1)\n        = p(1 * 1) : by rw map_mul\n    ... = p(1)     : by rw mul_one\n    ... = p(1) * 1 : by rw mul_one\n\n\n\n\n\n\n\n\n\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 21, "editorText": "sorry", "lineOffset": 96, "name": "map_one", "statement": "p(1) = 1"}, {"type": "lean", "content": "2546", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "2547", "hidden": true}, {"type": "text", "content": "2548"}, {"type": "text", "content": "2549"}, {"type": "lean", "content": "2550", "hidden": true}, {"type": "lean", "content": "2551", "hidden": true}, {"type": "lean", "content": "2552", "hidden": true}, {"type": "lean", "content": "2553", "hidden": false}, {"type": "text", "content": "2554"}, {"type": "hint", "content": "2555", "title": "2556"}, {"type": "hint", "content": "2557", "title": "2558"}, {"type": "theorem", "text": "2559", "lean": "def conj_map (c : G) : hom G G :=\n", "sideBar": true, "firstProofLineNumber": 106, "firstProofHintLineNumber": 107, "lastProofHintLineNumber": 117, "lastProofLineNumber": 134, "textBefore": "import hom.basic -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 2: Constructing homomorphisms\n-/\n\n/-\n### The trivial homomorphism\n\nLet $(G, \\ast)$ and $(H, \\odot)$ be groups.  The function $p : G \\to H$ defined by $p(a) = 1$, for\nevery $a$ in $G$, is a homomorphism, called the _trivial homomorphism_.\n\nIn Lean, a homomorphism is a structure that consists of two items:\n\n* a function, `p` from a group `G` to a group `H` and\n* a proof that for every `a` and `b` in `G`, `p(a * b) = p(a) * p(b)`.\n\nBelow, we give a Lean construction of the trivial homomorphism between two groups `G` and `H`. It ends with\n```\nfrom \u27e8p, h\u27e9,\n```\nHere `p` is a specified function `p : G \u2192 H` and `h` is a proof that\n`\u2200 (a b : G), p(a * b) = p(a) * p(b)`.\n\nThe function `p` is specified in Lean by\n```\nlet p : G \u2192 H := \u03bb a, 1\n```\nThis function maps each `a` in `G` to the identity element `1` in `H`.\n-/\n\n\nnamespace exlean -- hide\n\nopen group -- hide\n\nvariables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] -- hide\n\ndef one_map : hom G H :=\nbegin\n  let p : G \u2192 H := \u03bb a, 1,\n\n  have h : \u2200 (a b : G), p(a * b) = p(a) * p(b),\n  { assume a b : G,\n    show p(a * b) = p(a) * p(b),\n    calc\n      p(a * b)\n          = 1            : by refl\n      ... = 1 * 1        : by rw mul_one\n      ... = p(a) * p(b)  : by refl, },\n\n  from \u27e8p, h\u27e9,\nend\n\n/-\n### Tasks\n\nLet $G$ be a group and let $c$ be a fixed element of $G$. Let $p : G \\to G$ be the function\ndefined so that each $x$ in $G$ maps to $c \\ast x \\ast c^{-1}$.\n\n* Proof, by hand, that $p$ as defined above is a group homormorphism.\n\n* Prove the same result in Lean.\n-/\n\n/- Hint : A proof template\nStart with\n```\nlet p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\nhave h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n  assume (a b : G),\n  show p(a * b) = p(a) * p(b),\n  calc\n    p(a * b)\n        = sorry                           : sorry\n    ... = p(a) * p(b)                     : sorry, },\n\nfrom \u27e8p, h\u27e9,\n```\n-/\n\n/- Hint : Simplifying the use of associativity\nMany applications of associativity can be combined using\n`simp only [mul_assoc]`, as in the following example.\n\n```\nexample : (a * b) * (c * d) = a * ((b * c) * d) :=\nbegin\n  calc\n  (a * b) * (c * d)\n      = a * ((b * c) * d) : by simp only [mul_assoc],\nend\n```\n-/\n\n/- Theorem : \nFor a fixed element $c$ in a group $G$,\nthe map $p : G \\to G$ given by $p(x) = c \\ast x \\ast c^{-1}$ is\na group homomorphism.\n-/\ndef conj_map (c : G) : hom G G :=\nbegin\n", "proof": "/- hint\nlet p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\nhave h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n  assume (a b : G),\n  show p(a * b) = p(a) * p(b),\n  calc\n    p(a * b)\n        = sorry                           : sorry\n    ... = p(a) * p(b)                     : sorry, },\n\nfrom \u27e8p, h\u27e9,\n-/\n\n  let p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\n  have h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n    assume (a b : G),\n    show p(a * b) = p(a) * p(b),\n    calc\n      p(a * b)\n          = c * (a * b) * c\u207b\u00b9               : by refl\n      ... = c * (a * 1 * b) * c\u207b\u00b9           : by rw mul_one\n      ... = c * (a * (c\u207b\u00b9 * c) * b) * c \u207b\u00b9  : by rw mul_left_inv\n      ... = (c * a * c\u207b\u00b9) * (c * b * c\u207b\u00b9)   : by simp only [mul_assoc]\n      ... = p(a) * p(b)                     : by refl, },\n\n  from \u27e8p, h\u27e9,\n", "proof_hint": "let p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\nhave h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n  assume (a b : G),\n  show p(a * b) = p(a) * p(b),\n  calc\n    p(a * b)\n        = sorry                           : sorry\n    ... = p(a) * p(b)                     : sorry, },\n\nfrom \u27e8p, h\u27e9,", "textAfter": "\nend\n\nend exlean -- hide", "height": 29, "editorText": "let p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\nhave h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n  assume (a b : G),\n  show p(a * b) = p(a) * p(b),\n  calc\n    p(a * b)\n        = sorry                           : sorry\n    ... = p(a) * p(b)                     : sorry, },\n\nfrom \u27e8p, h\u27e9,", "lineOffset": 105, "name": "conj_map", "statement": "(c : G) : hom G G"}, {"type": "lean", "content": "2560", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2561", "hidden": true}, {"type": "text", "content": "2562"}, {"type": "text", "content": "2563"}, {"type": "lean", "content": "2564", "hidden": true}, {"type": "lean", "content": "2565", "hidden": true}, {"type": "lean", "content": "2566", "hidden": true}, {"type": "text", "content": "2567"}, {"type": "hint", "content": "2568", "title": "2569"}, {"type": "theorem", "text": "2570", "lean": "def hom.comp (p : hom G H) (q : hom H K) : hom G K :=\n", "sideBar": true, "firstProofLineNumber": 47, "firstProofHintLineNumber": 48, "lastProofHintLineNumber": 51, "lastProofLineNumber": 64, "textBefore": "import hom.conjugation -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 3: The composite of two homomorphisms\n-/\n\n/-\nIn this level, you will prove that if $p : G \\to H$ and $q : H \\to K$ are \nhomomorphims of groups, then so is the composite $q \\circ p$.\n-/\n\nnamespace exlean -- hide\n\nopen group hom_class -- hide\n\nvariables {G : Type*} {H : Type*} {K : Type*} (F : Type*) [group G] [group H] [group K] (a b c : G) -- hide\n\n\n/-\n### Tasks\n\n* By hand, write a proof that the composite of two homomorphism is a homomorphism.\n\n* Prove the same result in Lean. Recall that the `refl` tactic can be used to prove\n`(q \u2218 p)(x) = q(p(x))`. **Recall** that the composition symbol `\u2218` is typed `\\o` or `\\circ` in Lean.\n-/\n\n/- Hint : A proof template\n\nStart with\n```\nhave h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n{ sorry },\n\n  from \u27e8q \u2218 p, h\u27e9,\n```\nRefer to the previous level for ideas regarding the proof of `h`.\n-/\n\n/- Theorem : \nThe composite of two homomorphims is a homomorphism\n-/\ndef hom.comp (p : hom G H) (q : hom H K) : hom G K :=\nbegin\n", "proof": "/- hint\nhave h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n{ sorry },\n\nfrom \u27e8q \u2218 p, h\u27e9,\n-/\n\n  have h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n  { assume a b : G,\n    show (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n    calc\n      (q \u2218 p)(a * b)\n          = q(p (a * b) )           : by refl\n      ... = q(p(a) * p(b))          : by rw map_mul\n      ... = (q (p(a))) * q(p(b))    : by rw map_mul\n      ... = (q \u2218 p)(a) * (q \u2218 p)(b) : by refl },\n\n  from \u27e8q \u2218 p, h\u27e9,", "proof_hint": "have h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n{ sorry },\n\nfrom \u27e8q \u2218 p, h\u27e9,", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 18, "editorText": "have h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n{ sorry },\n\nfrom \u27e8q \u2218 p, h\u27e9,", "lineOffset": 46, "name": "hom.comp", "statement": "(p : hom G H) (q : hom H K) : hom G K"}, {"type": "lean", "content": "2571", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "2572", "hidden": true}, {"type": "text", "content": "2573"}, {"type": "text", "content": "2574"}, {"type": "lean", "content": "2575", "hidden": true}, {"type": "lean", "content": "2576", "hidden": true}, {"type": "lean", "content": "2577", "hidden": true}, {"type": "text", "content": "2578"}, {"type": "hint", "content": "2579", "title": "2580"}, {"type": "hint", "content": "2581", "title": "2582"}, {"type": "lean", "content": "2583", "hidden": true}, {"type": "theorem", "text": "2584", "lean": "lemma map_inv (g : G) : (p(g))\u207b\u00b9 = p(g\u207b\u00b9) :=\n", "sideBar": true, "firstProofLineNumber": 58, "lastProofLineNumber": 73, "textBefore": "import hom.composite -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 4: The inverse of the image of a group element under a homomorphism.\n-/\n\n/-\nWe've seen that if $p : G \\to H$ is a group homomorphism, then\n$p(a \\ast b) = p(a) \\odot p(b)$ and that $p(1) = 1$. In this level, you'll\nshow that $p(g)^{-1} = p(g^{-1})$. So, in every respect, homomorphims preserve the\ngroup structure.\n-/\n\nnamespace exlean -- hide\n\nopen group hom_class -- hide\n\nvariables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H] (p : F) -- hide\n\n\n/-\n### Tasks\n\n* By hand, write a proof that $p(g)^{-1} = p(g^{-1})$.\n\n* Prove the same result in Lean.\n-/\n\n/- Hint : Starting the proof\nIn this level, you are required to prove a result of the form `a\u207b\u00b9 = b`.\nRecall that using `apply inv_eq_of_mul_eq_one` changes the target of proving `a\u207b\u00b9 = b` to one\nof proving `a * b = 1`.\n-/\n\n\n/- Hint : A proof template\nTry this:\n```\napply inv_eq_of_mul_eq_one,\nshow p(g) * p(g\u207b\u00b9) = 1,\ncalc\n  p(g) * p(g\u207b\u00b9)\n      = sorry      : sorry\n  ... = 1          : sorry\n```\n\n-/\n\ninclude hc -- hide\n\n/- Theorem : \nGiven a group homomorphism $p : G \\to H$, the inverse of $p(g)$ is $p(g^{-1})$.\n-/\nlemma map_inv (g : G) : (p(g))\u207b\u00b9 = p(g\u207b\u00b9) :=\nbegin\n", "proof": "  apply inv_eq_of_mul_eq_one,\n  show p(g) * p(g\u207b\u00b9) = 1,\n  calc\n    p(g) * p(g\u207b\u00b9)\n        = p(g * g\u207b\u00b9) : by rw map_mul\n    ... = p(1)       : by rw mul_right_inv\n    ... = 1          : by rw map_one\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide", "height": 16, "editorText": "sorry", "lineOffset": 57, "name": "map_inv", "statement": "(g : G) : (p(g))\u207b\u00b9 = p(g\u207b\u00b9)"}, {"type": "lean", "content": "2585", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "2586", "hidden": true}, {"type": "text", "content": "2587"}, {"type": "lean", "content": "2588", "hidden": true}, {"type": "lean", "content": "2589", "hidden": true}, {"type": "lean", "content": "2590", "hidden": true}, {"type": "text", "content": "2591"}, {"type": "hint", "content": "2592", "title": "2593"}, {"type": "hint", "content": "2594", "title": "2595"}, {"type": "lean", "content": "2596", "hidden": true}, {"type": "theorem", "text": "2597", "lean": "lemma map_mul_inv (a b : G) :\n  (p(a * b))\u207b\u00b9 = p(b\u207b\u00b9) * p(a\u207b\u00b9) :=\n", "sideBar": true, "firstProofLineNumber": 47, "firstProofHintLineNumber": 48, "lastProofHintLineNumber": 51, "lastProofLineNumber": 72, "textBefore": "import hom.map_inv -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 5: The inverse of the image of a product of elements under a group homomorphism\n-/\n\nnamespace exlean -- hide\n\nopen group hom_class -- hide\n\nvariables {G : Type*} {H : Type*} {F : Type*} [group G] [group H]  [hc : hom_class F G H] (p : F) -- hide\n\n\n/-\n### Tasks\n\n* Prove that if $p : G \\to H$ is a group homomorphism, then $p(a \\ast b)^{-1} = p(b^{-1}) \\odot p(a^{-1})$.\n\n* Prove the same result in Lean.\n-/\n\n/- Hint : A proof template\nTry this\n```\ncalc\n  (p(a * b))\u207b\u00b9\n      = sorry             : sorry\n  ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)   : sorry\n```\n-/\n\n/- Hint : A useful result\nIn the groups world, we proved `mul_inv_rev`, that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a \u207b\u00b9`.\n-/\n\ninclude hc -- hide\n\n/- Theorem : \nGiven a group homomorphism $p : G \\to H$, we have $p(a \\ast b)^{-1} = p(b^{-1}) \\odot p(a^{-1})$.\n-/\nlemma map_mul_inv (a b : G) :\n  (p(a * b))\u207b\u00b9 = p(b\u207b\u00b9) * p(a\u207b\u00b9) :=\nbegin\n", "proof": "/- hint\ncalc\n  (p(a * b))\u207b\u00b9\n      = sorry             : sorry\n  ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)   : sorry\n-/\n  calc\n    (p(a * b))\u207b\u00b9\n        = p((a * b)\u207b\u00b9)     : by rw map_inv\n    ... = p(b\u207b\u00b9 * a\u207b\u00b9)      : by rw mul_inv_rev\n    ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)  : by rw map_mul\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "calc\n  (p(a * b))\u207b\u00b9\n      = sorry             : sorry\n  ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)   : sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 26, "editorText": "calc\n  (p(a * b))\u207b\u00b9\n      = sorry             : sorry\n  ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)   : sorry", "lineOffset": 46, "name": "map_mul_inv", "statement": "(a b : G) :\n  (p(a * b))\u207b\u00b9 = p(b\u207b\u00b9) * p(a\u207b\u00b9)"}, {"type": "lean", "content": "2598", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "2599", "hidden": true}, {"type": "text", "content": "2600"}, {"type": "lean", "content": "2601", "hidden": true}, {"type": "lean", "content": "2602", "hidden": true}, {"type": "lean", "content": "2603", "hidden": true}, {"type": "text", "content": "2604"}, {"type": "text", "content": "2605"}, {"type": "lean", "content": "2606", "hidden": true}, {"type": "theorem", "text": "2607", "lean": "lemma map_pow (p : F) (a : G) (n : \u2115)  :\n  p(a^n) = (p(a))^n :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 79, "textBefore": "import hom.map_mul_inv -- hide\n\n/-\n# Group Homomorphisms\n\n## Level 6: Powers of images of elements under a group homomorphism\n-/\n\nnamespace exlean -- hide\n\nopen group hom_class -- hide\n\nvariables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H]  -- hide\n\n/-\nBy induction, you can prove that if $p : G \\to H$ is a homomorphism, if $a$ is an\nelement of $G$ and if $n$ is a natural number (non-negative integer), then $p(a)^n = p(a^n)$.\n-/\n\n/-\n### Tasks\n\n* Prove that if $p : G \\to H$ is a group homomorphism and if $n$ is a natural number, then\nthen $p(a)^n = p(a^n)$.\n\n* Prove the same result in Lean.\n-/\n\ninclude hc -- hide\n\n/- Theorem : \nGiven a group homomorphism $p : G \\to H$, we have $p(a)^n = p(a^n)$, for every natural number $n$.\n-/\nlemma map_pow (p : F) (a : G) (n : \u2115)  :\n  p(a^n) = (p(a))^n :=\nbegin\n", "proof": "  induction n,\n\n  case zero :\n  { show p(a ^ 0) = (p(a))^0,\n    calc\n      p(a ^ 0)\n        = p(1)        : by rw pow_zero\n    ... = 1           : by rw map_one\n    ... = (p(a))^ 0   : by rw pow_zero, },\n\n  case succ : k ih\n  { given ih : p(a^k) = (p(a))^k,\n    show p(a^(k+1)) = (p(a))^(k+1),\n    calc\n      p(a ^ (k + 1))\n          = p(a * a ^ k)     : by rw pow_succ\n      ... = p(a) * p(a^ k)   : by rw map_mul\n      ... = p(a) * (p(a))^k  : by rw ih\n      ... = (p(a))^(k + 1)   : by rw pow_succ, },\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide", "height": 43, "editorText": "sorry", "lineOffset": 36, "name": "map_pow", "statement": "(p : F) (a : G) (n : \u2115)  :\n  p(a^n) = (p(a))^n"}, {"type": "lean", "content": "2608", "hidden": true}]}], "parents": [11]}], "texts": [["Modern Mathematics with Lean", "# Modern Mathematics with Lean, version 0.12\n\n## By Gihan Marasingha\n\nThis is an interactive book aimed at beginning mathematics undergraduates. You'll learn to prove\ntheorems online using a computer tool called Lean.\n\nEach chapter is represented by a coloured circular button in the right-hand pane. Blue indicates your\ncurrent position, green is for completed chapters, and grey is for unread or incomplete chapters.\n\nAt every stage in a proof, there is a *target*, the thing you want to prove, and a *context*, the\nset of things you have already proved or assumed at the beginning of your argument.\nThe target and context change through the proof.\n\nThe word *goal* is used to refer variously to the target or to the combination of target and context.\n\nYou'll use *tactics* to modify the goal until you have proved the target (called 'closing the goal').\nEach tactic may invoke one or more *theorems*.\n\nNote: the book is several megabytes in size. It must be downloaded before you can begin to work on the\nproblems. Once you open the book, wait for the text 'Lean is busy...' to disappear from the\ntop-right-hand pane before using Lean.\n\n## Lean symbols\n\n<table>\n  <tr>\n    <th style=\"padding-right : 20px\">Symbol</th>\n    <th style=\"padding-right : 20px; text-align: left\">Lean input</th>\n    <th style=\"padding-right : 20px; text-align: left\">Meaning</th>\n  </tr>\n  <tr>\n    <td><code>h\u2081</code></td>\n    <td><code>h\\1</code></td>\n    <td>Subscript</td>\n  </tr>\n  <tr>\n    <td><code>\u03bb</code></td> \n    <td><code>\\lam</code></td>\n    <td>Lambda abstraction</td> \n  </tr>\n  <tr>\n    <td><code>X \u2192 Y</code></td>\n    <td><code>X \\r Y</code></td>\n    <td>Function type</td>\n  </tr>\n  <tr>\n    <td><code>\u2115</code></td>\n    <td><code>\\N</code></td>\n    <td>Natural number type</td>\n  </tr>\n  <tr>\n    <td><code>\u2124</code></td>\n    <td><code>\\Z<code></td>\n    <td>Integer type</td>\n  </tr>\n  <tr>\n    <td><code>\u211a</code></td>\n    <td><code>\\R<code></td>\n    <td>Rational number type</td>\n  </tr>\n  <tr>\n    <td><code>\u211d</code></td>\n    <td><code>\\R<code></td>\n    <td>Real number type</td>\n  </tr>\n  <tr>\n    <td><code>\u2211</code></td>\n    <td><code>\\sum<code></td>\n    <td>Sum (only in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u227a</code></td>\n    <td><code>\\prec<code></td>\n    <td>Less than (only in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u227c</code></td>\n    <td><code>\\preceq<code></td>\n    <td>Less than or equal to (only in finite sum notation)</td>\n  </tr>\n  <tr>\n    <td><code>\u2264</code></td>\n    <td><code>\\le<code></td>\n    <td>Less than or equal to</td>\n  </tr>\n  <tr>\n    <td><code>\u2265</code></td>\n    <td><code>\\ge<code></td>\n    <td>Greater than or equal to</td>\n  </tr>\n  <tr>\n    <td><code>\u2260</code></td>\n    <td><code>\\ne<code></td>\n    <td>Does not equal</td>\n  </tr>\n  <tr>\n    <td><code>\u2227</code></td>\n    <td><code>\\and<code></td>\n    <td>Logical and</td>\n  </tr>\n  <tr>\n    <td><code>\u2228</code></td>\n    <td><code>\\or<code></td>\n    <td>Logical or</td>\n  </tr>\n  <tr>\n    <td><code>\u2192</code></td>\n    <td><code>\\r<code></td>\n    <td>Logical implication</td>\n  </tr>\n    <tr>\n    <td><code>\u2194</code></td>\n    <td><code>\\iff<code></td>\n    <td>Logical if and only if</td>\n  </tr>\n  <tr>\n    <td><code>\u00ac</code></td>\n    <td><code>\\n<code></td>\n    <td>Logical not</td>\n  </tr>\n  <tr>\n    <td><code>\u2200</code></td>\n    <td><code>\\all<code></td>\n    <td>For all</td>\n  </tr>\n  <tr>\n    <td><code>\u2203</code></td>\n    <td><code>\\ex<code></td>\n    <td>There exists</td>\n  </tr>\n  <tr>\n    <td><code>\u2208</code></td>\n    <td><code>\\in<code></td>\n    <td>Set membership</td>\n  </tr>\n  <tr>\n    <td><code>\u2205</code></td>\n    <td><code>\\empty<code></td>\n    <td>Empty set</td>\n  </tr>\n  <tr>\n    <td><code>\u2286</code></td>\n    <td><code>\\sub<code></td>\n    <td>Subset</td>\n  </tr>\n  <tr>\n    <td><code>\u2229</code></td>\n    <td><code>\\i<code></td>\n    <td>Set intersection</td>\n  </tr>\n  <tr>\n    <td><code>\u222a</code></td>\n    <td><code>\\un<code></td>\n    <td>Set union</td>\n  </tr>\n  <tr>\n    <td><code>\u00d7\u02e2</code></td>\n    <td><code>\\x\\^s<code></td>\n    <td>Cartesian product of sets</td>\n  </tr>\n  <tr>\n    <td><code>\ud835\udcab</code></td>\n    <td><code>\\power<code></td>\n    <td>Power set</td>\n  </tr>\n  <tr>\n    <td><code>f '' S</code></td>\n    <td><code>f '' S<code></td>\n    <td>Image of set $S$ under function $f$</td>\n  </tr>\n  <tr>\n    <td><code>f\u207b\u00b9'(U)</code></td>\n    <td><code>f\\preim(U)<code></td>\n    <td>Pre-image of set $U$ under function $f$</td>\n  </tr>\n  <tr>\n    <td><code>\u2218</code></td>\n    <td><code>\\o<code></td>\n    <td>Composition of functions</td>\n  </tr>\n  <tr>\n    <td><code>\u03b5</code></td>\n    <td><code>\\e<code></td>\n    <td>Greek letter epsilon</td>\n  </tr>\n  <tr>\n    <td><code>\u2223</code></td>\n    <td><code>\\mid<code></td>\n    <td>Divides</td>\n  </tr>\n  <tr>\n    <td><code>\u2261</code></td>\n    <td><code>\\==<code></td>\n    <td>Congruence</td>\n  </tr>\n  <tr>\n    <td><code>|x|</code></td>\n    <td><code>|x|<code></td>\n    <td>Absolute value of $x$</td>\n  </tr>\n  <tr>\n    <td><code>g\u207b\u00b9</code></td>\n    <td><code>g\\inv<code></td>\n    <td>Inverse of group element $g$</td>\n  </tr>\n</table>\n\n*Modern mathematics with Lean* is part of the \n<a href=\"https://exlean.org\" target=\"blank\">exlean</a> project.\n\n**This book is under construction.** \n\n## Credits\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\nIt uses ideas and special tactics from the \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n", "Equations", "import mynat.basic -- hide\n", "# Equations\n\n## Level 1: Proving equations through reflexivity\n\nThe `rfl` principle (short for reflexivity) can be used to prove any statement of the form\n`?X = ?X`. Here, I use `?X` to stand in for any expression of any type.\nIt could be `8 + 9` or `a * b` or `\"adele\"` or whatever.\n\nBelow, you are asked to prove `x + y = x + y`, where `x` and `y` are natural numbers.\nThe word `sorry` between the `begin` and `end` lines below asks Lean not to give an error message if a\nproof isn't complete. You'll see a <span style=\"color:orange\">warning</span> message in the\nbottom-right hand pane. This indicates you shouldn't trust the proof just yet, as it uses `sorry`!\n\nDelete `sorry` (using the backspace key on your keyboard). In the right-hand pane you'll see:\n```\nx y : \u2115\n\u22a2 x + y = x + y\n```\n\nHere, `x y : \u2115` is the *context*, the set of things you know. In this case, you know `x` and `y`\nare natural numbers.\n\nThe *target* is `\u22a2 x + y = x + y`. The `\u22a2` symbol can be read 'to prove'. So your target is\nto prove `x + y = x + y`.\n\nThe bottom part of the right-hand pane shows an <span style=\"color:red\">error</span>  message:\ntactic failed, there are unsolved goals. Don't panic! It's just telling you that you haven't yet\nproved the result.\n\nYour task is to replace `sorry` with `from rfl,`. Note the comma at the end of the line!\nIf you're successful, Lean will respond with the message `no goals` or `Proof complete!`\n\nIn `from rfl`, the word `from` is a *tactic*. This tactic takes a proof term and closes a goal\nif the provided proof term exactly matches the target. The list of tactics you've seen so far\nis presented in the left-hand pane.\n", "## Translation to a hand-written proof\n\nIn words, the `from rfl` says, \"The result holds from reflexivity\".\n\n", "If `h` is a hypothesis or proof term that matches the target, then `from h` will close the goal.\n\n`from` is a synonym for the tactic `exact`.\n", "If `h` is a hypothesis or proof term that matches the target, then `exact h` will close the goal.\n", "a = a\n", "namespace exlean -- hide\n", "open mynat -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2115) -- Declare `x` and `y` to be natural numbers.\n", "$x + y = x + y$, for all natural numbers $x$ and $y$.\n", "end exlean -- hide\n", "import mynat.add_mul_lemmas  -- hide\n", "# Equations\n\n## Level 2: Commutativity of addition\n\nNow we'll prove something (slighlty) more interesting, than `x + 3 = 3 + x`.\nTry `from rfl,` below (remember to put a comma after `rfl`) and see what happens.\n\nYou'll get an error message:\n```\ninvalid apply tactic, failed to unify\n  x + 3 = 3 + x\nwith\n  ?m_2 = ?m_2\n```\n\nLean tells you that you're trying to use `rfl` to prove `x + 3 = 3 + x`, but it expects a target\nof the form `?m_2 = ?m_2`.\n\nThe problem: even though we 'know' the left and right sides are equal, they are not\n*identically equal*.\nFortunately, Lean comes with a *theorem* of just the right kind. It's called `add_comm`, which is\nshort for additive commutativity.\nThe result `add_comm a b` states that `a + b = b + a`, where `a` and `b` are natural numbers.\n\nTo apply this theorem, we'll use the `from` tactic.\n\nReplace the `sorry` below with `from add_comm x 3` (followed by a comma\u2014I won't mention this from now\non).\n\nAlternatively, write `apply add_comm`. The `apply` tactic automatically fills in the missing\narguments to `add_comm`.\n", "`apply`, provided with a theorem name and any number of conditions of the theorem,\nopens as many new goals are necessary to fill in proofs of the remaining conditions\nof the theorem.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (x y : \u2115) -- hide\n", "a + b = b + a\n", "theorem add_comm (a b : \u2115) : a + b = b + a := mynat.add_comm' a b -- hide\n", "$x + 3 = 3 + x$, for all natural numbers $x$.\n", "end exlean -- hide\n", "## Translation to a hand-written proof\n\nIn words, `from add_comm x 3` says, \"The result follows from additive commutativity applied\nto $x$ and $3$.\"\n\nLikewise, `apply add_comm` says, \"The result follows by applying additive commutativity\".\n", "## Anatomy of a level\n\nEach level contains three vertical panes. The left-hand pane contains a list of the tactics and\ntheorem statements you've seen so far. Click on the arrows to dig deeper.\n\nThe middle pane is the one you're reading now! It contains text and interactive exercises.\nThe right-hand pane contains the Lean Infoview window, showing the 'tactic state' and error messages.\n\nYou can navigate through the book using the buttons in the top horizonal pane. The circular arrow\nresets your progress.\n", "import equations.add_comm -- hide\n", "# Equations\n\n## Level 3: `have` and `show`\n\nThe `have` tactic enables you to structure your proofs by adding intermediate results into the\ncontext. The `show` tactic helps your reader understand what you are proving.\n\n", "`have` is used to introduce a hypothesis into the context. For example,\n`have h : x + y = x + y, from rfl,` introduces the hypothesis `h : x + y = x + y` into the context.\n`have` requires a tactic proof of the claimed result. Here, `from rfl` is a tactic proof of `x + y = x + y`.\n\nMore generally, `have h : \u03b1, T` introduces `h : \u03b1` into the context if `T` is a tactic proof of `\u03b1`.\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (a b c : \u2115) -- hide\n", "In the example below, the first line adds `h : a + b = b + a` into the context. Here,\n`apply add_comm` gives a proof of `a + b = b + a`. The second lines uses this intermediate result\nto close the goal. In this simple example `have` is not necessary as the proof can be done in one\nline with `apply add_comm`.\n", "example : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  from h,\nend\n", "## Translation to a hand-written proof\n\nIn words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> The result follows from $h$.\n", "Changing the last line of the Lean proof above, we indicate what is being proved with the `show` tactic.\n", "`show` is used to state what is being proved. If, for example, the target is to prove `x + y = x + y`,\nyou can indicate and prove this using `show x + y = x + y, from rfl`.\n\nMore generally, if the target is to prove `\u03b1`, you can close the goal using `show \u03b1, T` where `T` is a tactic proof of `\u03b1`.\n", "example : a + b = b + a :=\nbegin\n  have h : a + b = b + a, apply add_comm,\n  show a + b = b + a, from h,\nend\n", "In words, the above proof says:\n> We have $h : a + b = b + a$, by additive commutativity.\n> We show $a + b = b + a$ from $h$.\n", "## Task\nReplace the underscores `_` below with statements and the `sorry` with a proof.\n", "$b + c = c + b$, for all natural numbers $b$ and $c$.\n", "end exlean -- hide\n", "import equations.add_comm -- hide\n", "# Equations\n\n## Level 4: Substitution\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "P b\n", "@[elab_as_eliminator]\ndef eq.sub {T} {a b : T} (P : T -> Prop) (h : a = b) (ha : P a) := @eq.rec T a P ha b h\n", "If you know `h\u2081 : a = b` and you know `h\u2082 : P(a)`, where `P(a)` is some statement involving `a`,\nthen you know `P(b)`. This principle is called *substitution*. In Lean, `eq.sub P h\u2081 h\u2082` is a\nproof of `P(b)`.\n\nA statement that depends on a variable (or on zero or more variables) is called a *predicate*. Thus,\n`P` above is a predicate.\n\nWe use the substitution principle to prove $s + (t + u) = s + (u + t)$. Let $P(x)$ be the statement\n$s + (t + u) = s + x$. We have $h_1 : t + u = u + t$, by commutativity of addition.\nWe have $h_2 : P (t + u)$ (that is $s + (t + u) = s + (t + u)$), from reflexivity.\n\nThus, the result (which is $P(u + t)$) follows by substituting $h_1$ into $h_2$.\n\nThis proof is written in Lean as follows.\n", "s + (t + u) = s + (u + t)\n", "theorem add_comm_congr_left : s + (t + u) = s + (u + t) :=\nbegin\n  let P : \u2115 \u2192 Prop := \u03bb x, s + (t + u) = s + x,\n  have h\u2081 : t + u = u + t, apply add_comm,\n  have h\u2082 : P(t + u), from rfl,\n  show P(u + t), from eq.sub P h\u2081 h\u2082,\nend\n", "In the proof below, we don't give $P$ explicitly. By using the underscore `_` as an argument to\n`eq.sub`, we ask Lean to infer the correct predicate `P`.\n", "example : s + (t + u) = s + (u + t) :=\nbegin\n  have h\u2081 : t + u = u + t, from add_comm t u,\n  have h\u2082 : s + (t + u) = s + (t + u), from rfl,\n  show s + (t + u) = s + (u + t) , from eq.sub _ h\u2081 h\u2082,\nend\n", "Finally, we can give a very terse proof of the result.\n", "example : s + (t + u) = s + (u + t) :=\nbegin\n  from eq.sub _ (add_comm t u) rfl,\nend\n", "## Task \n\nComplete the proof below, adapting the proof above. Replace each underscore `_` with a statement\nand each `sorry` with a proof.\n\nHere, `\u2115`, the type of natural numbers, is written `\\N` while `\u03bb` is typed `\\lam`.\n", "If you're struggling to determine the predicate `P`, delete the `let` line, replace `h\u2082 : P(s + t)`\nwith `h\u2082 : (s + t) + u = (s + t) + u`, and replace `eq.sub P h\u2081 h\u2082` with `eq.sub _ h\u2081 h\u2082`.\n", "Avoiding the predicate", "$(s + t) + u = (t + s) + u$, for all natural numbers $s$, $t$, $u$.\n", "end exlean -- hide\n", "import equations.substitution -- hide\n", "# Equations\n\n## Level 5: Substitution 2\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "## Task \n\nComplete the proof below. Get hints if needed by clicking on the drop-down menus below.\nIf you want to start with an explicit predicate, the first line should be\n```let P : \u2115 \u2192 Prop := \u03bb x, _,```\nwhere you should replace `_` with a statement depending on `x`.\n", "You can do this with (no more than) two `have`s and an application of substitution.\n", "Structure of the proof", "The result proved in the previous level will come in handy.\n", "A useful result", "$(s + t) + u  = u + (t + s)$, for all natural numbers $s$, $t$, and $u$.\n", "end exlean -- hide\n", "import equations.substitution2 -- hide\n", "# Equations\n\n## Level 6: Congruence of arguments\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "variables (s t u : \u2115) -- hide\n", "f a\u2081 = f a\u2082\n", "Let `f` be a function. Suppose `h : a = b`. Then `congr_arg f h` gives a proof of `f(a) = f (b)`.\nThis is called congruence of arguments.\n\nIn the example below, $f$ is the function from $\\mathbb N$ to $\\mathbb N$ given by $f(x) := 5 x$.\nThe term $h$ is a proof of $t + u = u + t$. Thus, `congr_arg f h` is a proof that\n$5(t + u) = 5(u + t)$.\n", "example : 5 * (t + u) = 5 * (u + t) :=\nbegin\n  let f : \u2115 \u2192 \u2115 := \u03bb x, 5 * x,\n  have h : t + u = u + t, apply add_comm,\n  show 5 * (t + u) = 5 * (u + t), from congr_arg f h,\nend\n", "## Translation to a hand-written proof\n\nThe proof above can be written by hand as follows.\n> Let $f : \\mathbb N \\to \\mathbb N$ be the function $f(x) := 5 x$.\n> We have $h : t + u = u + t$ by commutativity of addition.\n> The result follows by congruence of arguments with $f$ and $h$.\n", "## Task \n\nComplete the proof below, adapting the proof above.\n", "$(s + (t + u))  t = (s + (u + t))  t$, for all natural numbers\n$s$, $t$, $u$.\n", "end exlean -- hide\n", "import equations.congruence -- hide\n", "# Equations\n\n## Level 7: Congruence of arguments - proof\n", "namespace exlean -- hide\n", "## Task \n\nYou've used the `congr_arg` theorem. In this level, you'll *prove* it. Naturally, I've disabled\nthe ordinary `congr_arg` theorem so you can't cheat!\n", "namespace hidden -- hide\n", "variables {\u03b1 : Type*} {\u03b2 : Type*} {a b : \u03b1} -- hide\n", "Let $f$ be a function from a type $\\alpha$ to a type $\\beta$. \nLet $a$ and $b$ be terms of type $\\alpha$ and suppose $h : a = b$.\nThen $f(a) = f(b)$. \n", "end hidden -- hide\n", "end exlean -- hide\n", "import equations.congruence -- hide\n", "# Equations\n\n## Level 8: Associativity\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Additional of natural numbers satisfy the *associative* property. That is,\nfor all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\nIn Lean, `add_assoc` is the name of this theorem. Thus, `add_assoc a b c` is a proof that\n`(a + b) + c = a + (b + c)`.\n", "(a + b) + c = a + (b + c)\n", "theorem add_assoc (a b c : \u2115) : (a + b) + c = a + (b + c) := mynat.add_assoc' a b c -- hide\n", "variables (s t u v : \u2115) -- hide\n", "Thus, `add_assoc (s + t) u v` is a proof that $((s + t) + u) + v = (s + t) + (u + v)$.\n", "example : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  from add_assoc (s + t) u v,\nend\n", "We can let Lean do the chore of determining the arguments to `add_assoc` by using the `apply`\ntactic.\n", "example : ((s + t) + u) + v = (s + t) + (u + v) :=\nbegin\n  apply add_assoc,\nend\n", "variables (a b c : \u2115) -- hide\n", "$a + (b + c) = (a + b) + c$, for all natural numbers $a$, $b$, and $c$.\n", "end exlean -- hide\n", "import equations.associativity -- hide\n", "# Equations\n\n## Level 9: Symmetry\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The symmetry property of $=$ states that if $a = b$, then $b = a$. In Lean, if $h : a = b$,\nthen `eq.symm h` is a proof that `b = a`. This can also be written `h.symm`.\n", "b = a\n", "Using `eq.symm`, we'll reprove the result from the previous level.\n", "variables (a b c : \u2115) -- hide\n", "example : a + (b + c) = (a + b) + c :=\nbegin\n  have h : (a + b) + c = a + (b + c), apply add_assoc,\n  show a + (b + c) = (a + b) + c, from eq.symm h,\nend\n", "Or, more simply:\n", "example : a + (b + c) = (a + b) + c :=\nbegin\n  from (add_assoc a b c).symm\nend\n", "variables (s t u : \u2115) -- hide\n", "## Task\n\nComplete the proof below, replacing each underscore `_` with a statement and\neach `sorry` with a proof.\n", "$s + (t + u) = (t + s) + u$, for all natural numbers $s$, $t$, and $u$.\n", "end exlean -- hide\n", "import equations.symmetry -- hide\n", "# Equations\n\n## Level 10 : Transitivity\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Given `h\u2081 : a = b` and `h\u2082 : b = c`, we have `a = c`. This is called *transitivity*. Specifically,\nthe Lean result `eq.trans h\u2081 h\u2082` is a  proof of `a = c`.\n", "a = c\n", "We'll prove a result using `eq.trans` and two other results we've seen.\n", "variables (x y z : \u2115) -- hide\n", "example : (x + y) + z = x + (z + y) :=\nbegin\n  have h\u2081 : (x + y) + z = x + (y + z), apply add_assoc,\n  have h\u2082 : x + (y + z) = x + (z + y), apply add_comm_congr_left,\n  show (x + y) + z = x + (z + y), from eq.trans h\u2081 h\u2082,\nend\n", "## Task\n\nComplete the proof below. You may need to replace `sorry` with two lines. The last\nline should invoke `eq.trans`.\n", "$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.transitivity -- hide\n", "# Equations\n\n## Level 11 : Proof by calculation\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "If you did the exericse from the previous level, you may have found it overly complicated for\nsuch a simple result. The proof required showing three equations of the form `h\u2081 : a = b`,\n`h\u2082 : b = c`, and `h\u2083 : c = d` and combining them by two applications of transitivity.\n\nThis technique is so common, that we have a special notation for proofs that combine several\nequations via transitivity. First, we present the handwritten version.\n\n**Proof**:\n$$\n\\begin{align}\n(x + y) + z &= x + (y + z) & & \\text{[by associativity of addition]} \\\\\\\\\n&= x + (z + y) & &\\text{[by Theorem add_comm_congr_left]} \\\\\\\\\n&= (x + z) + y. & & \\text{[by associativity of addition (backward)]}\n\\end{align}\n$$\n\nThe same proof can be presented in Lean as follows. Here, I use underscores `_` to ask Lean\nto fill in the missing arguments.\n", "variables (x y z : \u2115) -- hide\n", "example : (x + y) + z = (x + z) + y :=\nbegin\n  calc  \n  (x + y) + z = x + (y + z) : add_assoc _ _ _\n          ... = x + (z + y) : add_comm_congr_left _ _ _\n          ... = (x + z) + y : add_assoc_symm _ _ _,\nend\n", "## Task\n\nComplete the proof below. As usual, you will find it helpful to use the results already proved.\n", "$(x + y) + z = (z + x) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.calculation -- hide\n", "# Equations\n\n## Level 12 : Challenge level\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Write a proof by calculation (or by any other method) of the result below.\n", "You can do this entirely using `congr_arg`, `add_assoc`, and `add_comm`.\n", "Required results", "Try the following proof template. For the first `sorry`, you'll need `congr_arg`.\n```\ncalc (x + y) + (s + t) = (x + y) + (t + s) : sorry\n... = x + (y + (t + s)) : sorry\n... = (y + (t + s)) + x : sorry,\n```\n", "A proof template", "variables (x y z s t : \u2115) -- hide\n", "$(x + y) + (s + t) = (y + (t + s)) + x$, for all natural numbers $x$, $y$, $s$, and $t$.\n", "end exlean -- hide\n", "import equations.challenge tactic.pure_maths -- hide\n", "# Equations\n\n## Level 13 : Backward proof and the `rw` tactic\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "Let's give a backward proof of $x + (y + z) = (z + y) + x$.\n\n**Proof**:\n$$\n\\begin{align}\n&& x + (y + z) & = (z + y) + x & &  \\\\\\\\\n&\\iff & x + (z + y)& = (z + y) + x & & \\text{[by commutativity of addition on $y$ and $z$]} \\\\\\\\\n&\\iff & (z + y) + x&= (z + y) + x. & & \\text{[by commutativity of addition on $x$ and $z + y$]}\n\\end{align}\n$$\nThe last line follows by reflexivity. \u220e\n", "Here is a Lean proof of this result.\n", "variables (x y z : \u2115) -- hide\n", "example : x + (y + z) = (z + y) + x :=\nbegin [pure_maths]\n  show x + (y + z) = (z + y) + x,   rw add_comm y z,\n  show x + (z + y) = (z + y) + x,   rw add_comm x (z + y),\n  show (z + y) + x = (z + y) + x,   from rfl,\nend\n", "If `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "In this proof, `rw` is short for `rewrite` and the expression `rw add_comm y z` is the Lean\nversion of the handwritten, 'by commutativity of addition on $y$ and $z$'. The only difference\nis that each `rw` appears one line above where it would in a handwritten proof.\n\nIn general, if you use `rw h` where `h : a = b`, then Lean\nwill look for every instance of `a` in the target and replace it with `b`.\n\n\n\n## Task\nThere are many ways to prove a given theorem. Below is a different backward proof of our result.\nConvert this Lean proof into a handwritten proof.\n", "example : x + (y + z) = (z + y) + x :=\nbegin [pure_maths] \n  show x + (y + z) = (z + y) + x,   rw add_comm (z + y) x,\n  show x + (y + z) = x + (z + y),   rw add_comm y z,\n  show x + (z + y) = x + (z + y),   from rfl,\nend\n", "The use of `show` isn't required by Lean. Moreover, multiple applications of `rw` can\nbe combined on one line, as shown below. However, this translates poorly to handwritten proofs.\n", "example : x + (y + z) = (z + y) + x:=\nbegin [pure_maths]\n  rw [add_comm y z, add_comm], from rfl,\nend\n", "\n", "## Task \nGiven a backward of the theorem `add_right_comm` that you first encounterd in the transitivity level.\nI've provided you with a suggested first line.\n\nThe old `add_right_comm` result is unavailable for use in your proof!\n", "namespace hidden -- hide\n", "$(x + y) + z = (x + z) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end hidden -- hide\n", "end exlean -- hide\n", "import equations.challenge tactic.pure_maths -- hide\n", "# Equations\n\n## Level 14 : Easy calculation proofs using `rw`\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "The idea of 'replacing equals with equals' can lead to simpler proofs. Using this idea,\nwe present a proof of the result from the challenge level.\n", "variables (x y z s t: \u2115) -- hide\n", "example : (x + y) + (s + t) = (y + (t + s)) + x :=\nbegin\n  calc\n  (x + y) + (s + t) = (x + y) + (t + s) : by rw add_comm s t\n                ... = x + (y + (t + s)) : by rw add_assoc\n                ... = (y + (t + s)) + x : by rw add_comm,\nend\n", "In each line of justification above, the word `by` announces that we are to provide Lean with a \ntactic proof.\n\nThus, `rw add_comm s t` is a tactic proof of `(x + y) + (s + t) = (x + y) + (t + s)`.\n", "## Task\n\nComplete the proof below. To do this, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n", "If you try `add_comm` (or `add_assoc`) and Lean doesn't do what you expect, you may need\nto be more precise about what you want to add `add_comm` to.\n\nFor example, to justify the line `a + (b + c) = a + (c + b)` requires `rw add_comm b c`\n(or `rw add_comm b`). The problem is that `rw add_comm` by itself transforms \n`a + (b + c)` into `(b + c) + a`.\n", "Problems with applying `add_assoc` or `add_comm`?", "$x + ((y + z) + z) = ((z + z) + x) + y$, for all natural numbers $x$, $y$, and $z$.\n", "end exlean -- hide\n", "import equations.rewrite_calc-- hide\n", "# Equations\n\n## Level 15 : The simplifier\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "This level introduces a powerful new tactic, `simp`, Lean's simplifier. It rewrites \nrepeatedly using either supplied theorems & hypotheses or theorems that it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nIn the example below, we supply `simp` with `add_assoc` and `add_comm y x`.\n\nWithout `simp`, you'd need several applications of `rw add_assoc`. \n", "example (x y z : \u2115) : x + ((y + z) + x) = (y + x) + (z + x) :=\nbegin\n  simp [add_assoc, add_comm y x],\nend\n", "## Tasks\n\n* Prove the result below using only `simp` with supplied theorems, as in the example above. You should\nonly need to supply two theorems.\n\n* For fun (!) try proving this result using `rw`. Which proof do you prefer?\n", "Let `x`, `y`, and `z` be natural numbers. Then `(y + x) + (0 + z + 0) + (0 + x + 0) = y + (z + (x + x))`.\n", "The `simp` tactic rewrites repeatedly using either supplied theorems & hypotheses or theorems\nthat it 'knows'.\n\nTo suggest theorems and hypotheses for use with `simp`, provide them as a comma-separated list.\nFor example `simp [h, add_comm]` rewrites repeatedly with hypotheses `h` and theorem `add_comm`.\n", "end exlean -- hide\n", "Natural numbers", "import mynat.basic tactic.pure_maths -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 1: A boolen evenness function\n\nIn this world, a natural number is either `O` (the capital letter `O`) or\n`S(k)`, where `k` is a natural number. The successor function `S` can be thought of\nas 'returning' the number `S(k)` that comes after `k`.\n\nThe number we call $2$ can be written with this definition as `S(S(O))` or `S(S O)`.\n", "example : \u2115 := O \nexample : \u2115 := S O \nexample : \u2115 := S(S(O))\nexample : \u2115 := S(S(S O))\n", "\nTo define a function on `\u2115` is to give its value at `O` and to specify how its\nvalue at `S(k)` depends on its value at `k`.\n\nWe define a function `evenb` such that `evenb(n)` is `tt` (true) if `n` is even and is\n`ff` (false) otherwise. In the following recursive definition of `evenb`, the symbol `!`\nrepresents the Boolean 'not' function, defined so that `!(tt) := ff` and `!(ff) := tt`.\n", "def evenb : \u2115 \u2192 bool\n| O     := tt\n| (S k) := !(evenb k)\n", "By definition of `evenb`, we extract two lemmas. The first, `evenb_O`, asserts\n`evenbO = tt`. The second, `evenb_S`, asserts that `evenb(S(n)) = !(evenb(n))`.\n", "evenb(O) = tt\n", "lemma evenb_O : evenb O = tt := rfl\n", "evenb (S(n)) = !(evenb n)\n", "lemma evenb_S (n : \u2115) : evenb (S n) = !(evenb n) := rfl\n", "Using these two lemmas, we give a proof by calculation that 3 is not even. More precisely,\nthat `evenb(S(S(S(O)))) = ff`.\n", "example : evenb(S(S(S(O)))) = ff :=\nbegin\n  calc\n  evenb(S(S(S(O)))) = !evenb((S(S(O)))) : by rw evenb_S\n                ... = !!evenb(S O)      : by rw evenb_S\n                ... = !!!evenb(O)       : by rw evenb_S\n                ... = !!!tt             : by rw evenb_O\n                ... = ff                : rfl,\nend\n", "In fact, as each step of the proof above involves an application of a definition, the\nresult holds by reflexivity.\n", "example : evenb(S(S(S(O)))) = ff :=\nbegin\n  from rfl,\nend\n", "## Task\n\nComplete the proof by calculation that 2 is even. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n", "That $2$ is even has value 'true'.\n", "end exlean -- hide", "import natural_numbers.evenb -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 2: The definition of addition\n\nOur addition function is defined so that for every natural number `m`, we have\n`m + O = m` and `m + (S n) = S(m + n)`, for every natural number `n`.\n\nThese definitions are available as the theorems `add_O` and `add_S`:\n\n`add_O (m : \u2115) : m + O = m`\n\n`add_S (m n : \u2115) : m + (S n) = S(m + n)`\n", "n + O = n\n", "m + (S n) = S(m + n)\n", "Using these two lemmas, we give a proof by calculation that `(S O) + (S O) = S(S(O))`,\nthat is, that $1 + 1 = 2$.\n", "example : (S O) + (S O) = S(S(O)) :=\nbegin\n  calc\n  (S O) + (S O) = S((S O) + O)  : by rw add_S\n            ... = S(S(O))       : by rw add_O\nend\n", "As in the previous level, both sides are *definitionally* equal to `S(S(O))`, thus\nthe result could, more easily, be proved by reflexivity.\n", "example : (S O) + (S O) = S(S(O)) :=\nbegin\n  from rfl,\nend\n", "As another example, we prove that `S(n) = n + (S O)`, effectively that\n$\\mathsf{S}(n) = n + 1$.\n", "S n = n + (S O)\n", "lemma S_eq_add_one (n : \u2115) : S n = n + (S O) :=\nbegin [pure_maths]\n  show S n = n + (S O), rw add_S,\n  show S n = S(n + O),  rw add_O,\n  show S n = S n, from rfl,\nend\n", "## Task\n\nComplete the proof by calculation that $1 + 2 = 3$. You'll need\nadditional lines of calculation.\n\nOnce you've done this, check that `from rfl,` suffices\nas a one-line proof.\n", "$1 + 2 = 3$.\n", "end exlean -- hide", "import natural_numbers.addition -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 3: Induction and `S_eq_one_add`\n\nLet $P$ be a predicate on $\\mathbb N$. To prove that $P(n)$ holds for every natural number $n$\nis to:\n1. [base case] prove $P(\\mathsf{O})$ and\n2. [inductive step] prove that for every $k : \\mathbb N$, $P(\\mathsf S(k))$ follows from the *induction hypothesis*,\nthe assumption of $P(k)$.\n\nThis is called *proof by induction*.\n", "Via proof by induction, one may prove $\\mathsf O + n = n$, for every $n : \\mathbb N$. Here, the\npredicate $P$ is given by $P(n) := \\mathsf O + n = n$.\n\n**Proof**:\n1. [Base case] We must show $P(\\mathsf O)$. That is, $\\mathsf O + \\mathsf O = \\mathsf O$. This follows by definition of\naddition.\n\n2. [Inductive step] Let $k$ be a natural number. Assume the induction hypothesis $h : P(k)$, which is\n$\\mathsf O + k = k$. We must show $P(\\mathsf S(k))$, i.e. $\\mathsf O + \\mathsf S(k) = \\mathsf S(k)$.\nBut\n$$\n\\begin{align}\n\\mathsf O + \\mathsf S(k) & = \\mathsf S(\\mathsf O + k) && \\text{[by definition of addition]} \\\\\\\\\n&= \\mathsf S(k). & & \\text{[by  $h$]}\n\\end{align}\n$$\n\nThe result follows by induction. \u220e \n", "The same result is proved in Lean below. Here, `induction n` marks the start of the proof. The base case is\nindicated with `case O` and the inductive step with `case S`.\n\nThe base case is the proof of `P(O)`. That is, the proof of `O + O = O`. This holds by\ndefinition of addition, and hence by reflexivity.\n\nIn the inductive step, the quantities `k` and `h` in `case S : k h` are the induction variable\nand induction hypothesis, respectively. We must show `P(S(k))`, i.e. `O + S(k) = S(k)`,\ngiven the induction hypothesis: the assumption of `P(k)`, i.e.\nof `O + k = k`.\n", "To prove `P(n)` holds for all `n : \u2115`, use the `induction n`. This opens up two new goals:\n(1) to prove `P(O)` and (2) to prove `P(S(k))` on the assumption of `P(k)`.\n\nTo specify the names of the induction variable (say `k`) and induction hypothesis (say `h`)\nyou can either use the form `induction with k h` or you can tag the induction step with\n`case S : k h`.\n", "O + n = n\n", "@[simp] lemma O_add (n : \u2115) : O + n = n :=\nbegin\n  induction n,\n", "  -- hide\n", "  case O :\n  { show O + O = O, from rfl, },\n", "  -- hide\n", "  case S : k h\n  { show O + S(k) = S(k),\n    given h : O + k = k,\n    calc\n    O + S(k)  = S(O + k)  : by rw add_S\n          ... = S(k)      : by rw h, },\nend\n", "As an aside, note that I've tagged the theorem above with `@[simp]`. This\nmeans that the `simp` tactic will automatically call on `O_add` whenever applicable, as in\nthe proof below.\n", "example (n : \u2115) : (O + (O + n)) + O  = n :=\nbegin\n  simp,\nend\n", "## Task\n\nComplete the following proof by induction, following the template given by the proof of `O_add`\nabove. Note you have to separately proof the base case and the inductive step.\n", "If you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S(O) = S(O) + O, sorry, },\n\ncase S : k h\n{ show S(S(k)) = S(O) + S(k),\n  given h : S(k) = S(O) + k,\n  sorry, },\n```\n\n", "A proof template", "For every natural number $n$, we have $\\mathsf S(n) = \\mathsf S(\\mathsf O) + n$. That is,\n$\\mathsf S(n) = 1 + n$.\n", "end exlean -- hide", "import natural_numbers.S_eq_one_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 4: `S_add`\n\nIn this level, you'll prove a result that depends on two variables $m$ and $n$ by fixing $m$\nand performing induction on $n$.\n\n## Task\n\nComplete the following proof by induction.\n", "If you're not sure how to start, begin with the following template. The `sorry` in the inductive\nstep can be filled in with a proof by calculation, as above.\n```\ninduction n,\n\ncase O :\n{ show S m + O = S(m + O), sorry, },\n\ncase S : k h\n{ show S(m) + S(k) = S(m + S(k)),\n  given h : S(m) + k = S(m + k),\n  sorry, },\n```\n", "A proof template", "If you used the proof template above, the goal of the inductive step is\n```\n m k : \u2115,\n h : S m + k = S (m + k)\n \u22a2 S m + S k = S (m + S k)\n```\nTo help you understand proof by induction, I recommend using a proof by calculation here.\nHowever, Lean can partially automate the construction of a proof using the `simp` tactic. Here,\n`simp [add_S, h]` proves the inductive step. It tells Lean to use `add_S` and the inductive\nhypothesis `h` (and any other lemma marked with the `simp` attribute) as many times as necesary\nand in whatever order until a proof is found or no further simplification is possible.\n", "A cheap proof using `simp`", "For all natural numbers $m$ and $n$, we have $\\mathsf S(m) + n = \\mathsf S(m + n)$.\n", "end exlean -- hide", "import natural_numbers.S_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 5: Doubling\n\nThe function `double` from `\u2115` to `\u2115` is defined so that `double(O) := O` and\n`double(S(k)) = S(S(double(k)))`. It corresponds to the ordinary notion of doubling a natural\nnumber.\n", "def double : \u2115 \u2192 \u2115\n| O     := O\n| (S k) := S (S (double k))\n", "The definition equations of `double` give two results, by reflexivity.\n", "double(O) = O\n", "lemma double_O : double(O) = O := rfl\n", "double(S(n)) = S(S(double(n)))\n", "lemma double_S (n : \u2115) : double(S(n)) = S(S(double(n))) := rfl\n", "## Task\n\nComplete the following proof by induction. Use the results `double_O` and `double_S` above\ntogether with any relevant results from previous levels in this world.\n", "For every natural number $n$, we have $\\mathsf{double}(n) = n + n$.\n", "end exlean -- hide", "import natural_numbers.double_eq_add_self -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 6: Commutativity of addition\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that $m + n = n + m$\nfor all natural numbers $n$.\n", "This is the first level where the base case cannot be proved by reflexivity. Previously proved\nresults will come in handy here. See the 'Theorem statements' side bar on the left for inspiration.\n", "Proving the base case", "For all natural numbers $m$ and $n$, we have $m + n = n + m$.\n", "end exlean -- hide", "import natural_numbers.add_comm -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 7: Associativity of addition\n", "## Task\n\nLet $x$ and $y$ be a natural numbers. By induction on $z$, prove that $(x + y) + z = x + (y + z)$\nfor all natural numbers $z$.\n", "For all natural numbers $x$, $y$, and $z$, we have $(x + y) + z = x + (y + z)$.\n", "end exlean -- hide", "import natural_numbers.add_assoc algebra.group.defs -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 8: Easy addition with `ac_refl`\n", "If you were asked to prove $(a + b) + (c + (b + a)) = (c + (b + b)) + (a + a)$ for all natural \nnumbers $a$, $b$, and $c$, you might say that the statement is clearly true, by rearranging.\n\nIf you were required to prove this step-by-step using the laws of commutativity and associativity\nof addition, it would be a pain.\n\nFortunately, Lean comes with a clever tactic called `ac_refl` that can creates proofs of any\nresult that can be justified solely by associativity, commutativity, and reflexivity.\n\nSince we've shown `+` is associative and commutative, we may use `ac_refl`.\n", "instance : add_comm_monoid mynat :=\n{ add_assoc := add_assoc,\n  add_comm := add_comm,\n  zero_add := O_add,\n  add_zero := add_O,\n  .. }\n", "variables (a b c v i o l e t : \u2115) -- hide\n", "example : (a + b) + (c + (b + a)) = (c + (b + b)) + (a + a) :=\nbegin\n  ac_refl,\nend\n", "This tactic closes any goal that can be proved only by associativity, commutativity, and\nreflexivity.\n", "## Task\n\nUse `ac_refl` to prove the following.\n", "$(v + (i + o)) + (l + (e + t)) = ((l + o) + (v + e)) + (i + t)$.\n", "end exlean -- hide", "import natural_numbers.easy_addition -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 9: Multiplication and `mul_two`\n\nThe multiplication function is defined so that for every natural number `m`, we have\n`m * O = O` and `m * (S n) = m * n + m`, for every natural number `n`.\n\nThese definitions are available as the theorems `mul_O` and `mul_S`:\n\n`mul_O (m : \u2115) : m * O = O`\n\n`mul_S (m n : \u2115) : m * (S n) = m * n + m`\n", "n * O = O\n", "m * (S n) = m * n + m\n", "Using these 'definitional' results, we'll prove $n \\times 1 = n$.\n", "n * S(O) = n\n", "@[simp] lemma mul_one (n : \u2115) : n * S(O) = n :=\nbegin\n  calc\n  n * S(O)  = n * O + n : by rw mul_S\n        ... = O + n     : by rw mul_O\n        ... = n         : by rw O_add,\nend\n", "## Task\n\nProve that $n \\times \\mathsf S(\\mathsf S(\\mathsf O)) = n + n$, for every natural number $n$.\nYou *do not* require induction for this proof. Give a proof by calculation using previously\nproved results.\n\nTo complete the proof, replace the `_` with an expression, add extra lines of calculation,\nand replace the `sorry` with a final justification.\n", "For every natural number $n$, we have $n \\times 2 = n + n$.\n", "end exlean -- hide", "import natural_numbers.mul_two -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 10: Multiply by O on the left\n", "## Task\n\nBy induction on $n$, prove that $\\mathsf O \\times n = \\mathsf O$,\nfor every natural number $n$.\n", "For every natural number $n$, we have $\\mathsf O \\times n = \\mathsf O$.\n", "attribute [simp] O_mul -- hide\n", "end exlean -- hide", "import natural_numbers.zero_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 11: Left distributivity of multiplication\n", "## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$x(y + z) = x y + xz$, for every natural number $z$.\n", "For all natural numbers $x$, $y$, and $z$, we have $x(y + z) = xy + xz$.\n", "end exlean -- hide", "import natural_numbers.mul_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 12: Associativity of multiplication\n", "## Task\n\nLet $x$ and $y$ be natural numbers. By induction on $z$, prove that\n$(xy)z = x(yz)$, for every natural number $z$.\n", "At some point in your proof, it will be helpful to use `mul_add`, the\nleft distributivity of multiplication result.\n", "A helpful result", "For all natural numbers $x$, $y$, and $z$, we have $(xy)z = x(yz)$.\n", "end exlean -- hide", "import natural_numbers.mul_assoc -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 13: `S_mul`\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$\\mathsf S(m) n = mn + n$, for every natural number $n$.\n\nThis is the hardest induction so far.\n", "At some point in your proof of the inductive step, it will be\nhelpful to use `mul_S`, `add_S`, `add_assoc`, and `add_comm`.\n", "Helpful results", "For all natural numbers $m$ and $n$, we have $\\mathsf S(m) n = mn + n$.\n", "end exlean -- hide", "import natural_numbers.S_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 14: Commutativity of multiplication\n", "## Task\n\nLet $m$ be a natural number. By induction on $n$, prove that\n$mn = nm$, for every natural number $n$.\n\nYou've done all the hard work in the previous level, `S_mul`.\n", "For all natural numbers $m$ and $n$, we have $mn = nm$.\n", "end exlean -- hide", "import natural_numbers.mul_comm tactic.ring -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 15: Easy arithmetic\n\nWe've proved a significant set of theorems about natural number arithmetic. We know addition\nand multiplication are associative and commutative. We know that multiplication is distributive.\nWe know special facts about adding and multiplying by zero and multiplying by one.\n\nPut together, these facts mean that `\u2115` is something called a 'commutative semiring'. You don't\nneed to know what that means for the moment. What's important is that Lean has powerful tactics\nfor proving results in commutative semirings.\n", "S(O) * m = m\n", "@[simp] lemma one_mul (n : \u2115) : S(O) * n = n := by rw [mul_comm, mul_one]\ninstance : comm_monoid mynat :=\n{ mul_assoc := mul_assoc,\n  mul_comm := mul_comm,\n  one_mul := one_mul,\n  mul_one := mul_one,\n  .. }\ninstance : has_coe nat mynat := \u27e8\u03bb n, nat.rec_on n O (\u03bb a b, S b)\u27e9\nlemma coe_succ (n : nat) : \u2191(nat.succ n) = S n := rfl\nlemma nsmul_succ' (n : nat) (x : mynat) : \u2191(n.succ) * x = x + \u2191n * x :=\nby rw [coe_succ, S_mul, add_comm]\nlemma add_mul (a b c : \u2115) : (a + b) * c = a * c + b * c :=\nby rw [mul_comm, mul_add, mul_comm c, mul_comm c]\ninstance : comm_semiring mynat :=\n{ nsmul := \u03bb m n, m * n,\n  nsmul_zero' := O_mul,\n  nsmul_succ' := nsmul_succ',\n  left_distrib := mul_add,\n  right_distrib := add_mul,\n  zero_mul := O_mul,\n  mul_zero := mul_O,\n  ..mynat.add_comm_monoid, ..mynat.comm_monoid, .. }\n", "For example, the `ring` tactic can prove $(a + b)^2 = a^2 + 2ab + b^2$.\n", "example (a b c : \u2115) :\n(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 :=\nbegin\n  ring,\nend\n", "To make things interesting, we can pose the proof above as a question. Find $x$ such that\n$(a + b)^2 = a^2 + xab + b^2$, for all $a$ and $b$.\n\nThe answer is $2$ (of course!). You tell Lean to use $2$ by typing `use 2`. Then `ring`\nfinishes the proof.\n", "Proves equations in commutative semirings (such as \u2115).\n", "example (a b c : \u2115) : \u2203 (x : \u2115),\n(a + b) ^ 2 = a ^ 2 + x * a * b + b ^ 2 :=\nbegin\n  use 2,\n  ring,\nend\n", "## Task\n\nAdapting the proof above, prove the following result by finding $x$ such that\n$(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$.\n", "There exists a natural number $x$ such that $(a + 2b)(2a + b) = 2a ^ 2 + xab + 2b^2$, for all\nnatural numbers $a$ and $b$.\n", "end exlean -- hide", "import natural_numbers.easy_multiplication -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 16: Exponentiation. Raising to the first power\n", "Let $m$ be a natural number. We'll define raising $m$ to the (natural number) power $n$\nrecursively on $n$ so that $m^{\\mathsf O} := 1$ and $m^{\\mathsf S(n)} := (m ^ n) \\times m$.\n\nIn Lean, we write `m ^ n` for $m ^ n$. The defining equations of exponentiation are represented\nby the following theorems.\n\n`pow_O (n : \u2115) : n ^ O = S(O)`\n\n`pow_S (m n : \u2115) : m ^ S(n) = (m ^ n) * m`\n", "n ^ O = S(O)\n", "m ^ S(n) = (m ^ n) * m\n", "## Task\n\nProve that $m ^ 1 = m$, for every natural number $m$. You *don't* need\ninduction.\n", "For all natural numbers $m$ and $n$, we have $mn = nm$.\n", "end exlean -- hide", "import natural_numbers.pow_one -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 17: Powers of 1\n\n## Task\n\nProve that $1 ^ m = 1$, for every natural number $m$.\n", "$1 ^ m = 1$, for every natural number $m$.\n", "end exlean -- hide", "import natural_numbers.one_pow -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 18: Raising to a power $a + b$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a + b} = m ^ a m ^ b$, for all natural numbers $b$.\n", "For all natural numbers $m$, $a$, and $b$, we have $m ^ {a + b} = m ^ a m ^ b$.\n", "end exlean -- hide", "import natural_numbers.pow_add -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 19: Raising to a power $ab$\n\n## Task\n\nLet $m$ and $a$ be natural numbers. Prove, by induction on $b$,\nthat $m ^ {a b} = (m ^ a) ^ b$, for all natural numbers $b$.\n", "For all natural numbers $m$, $a$, and $b$, we have $m ^ {a b} = (m ^ a) ^ b$.\n", "end exlean -- hide", "import natural_numbers.pow_mul -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 20: Powers of products\n\n## Task\n\nLet $a$ and $b$ be natural numbers. Prove that $(ab)^m = (a^m)(b^m)$,\nfor every natural number $m$.\n", "At some point in the proof, you may find it helpful to use the `ac_refl` tactic \nor the `ring` tactic to easily show\na result that depends on commutativity and associativity of multiplication.\n", "A time-saving tactic", "For all natural numbers $a$, $b$, and $m$, we have $(ab)^m = (a^m)(b^m)$.\n", "end exlean -- hide", "import natural_numbers.mul_pow -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 21: Finite sums\n\nIn mathematics, the 'sigma' notation is used to represent sums. We may write\n$$\n\\sum_{i=0}^{10} i\n$$\nto represent the sum $0 + 1 + \\dots + 9 + 10$. Henceforth, as all our numbers are non-negative,\nwe'll omit the lower summation bound $0$.\n\nIn this book, we represent the same quantity as\n`\u2211 i \u227c 10, i`. Here, `\u2211` is typed `\\sum`, and `\u227c` is typed `\\preceq`.\n\nLikewise, the sum $\\sum_{i < 10} i$ is represented as `\u2211 i \u227a 10, i`, where `\u227a` is typed `\\prec`.\n\nFor example, one can prove (by reflexivity), that\n$$\\sum_{i \\le 4} i ^ 2 = 30.$$\n", "open_locale fsum -- hide\n", "example : \u2211 i \u227c 4, i ^ 2 = 30 :=\nbegin\n  from rfl,\nend\n", "More generally, one can consider $\\sum_{i < n} f(i)$, for some function $f$. We'll define this by\ntwo principles: (1) $\\sum_{i < 0} f(i) := 0$ and (2)\n$\\sum_{i < \\mathsf S(n)} f(i) := \\sum_{i < n} f(i) + f(n)$.\n\nNote (2) may also be written as $\\sum_{i \\le n} f(i) := \\sum_{i < n} f(i) + f(n)$.\n", "These definitions are available as the theorems `fsum_O` and `fsum_S`:\n\n`fsum_O (f : \u2115 \u2192 \u2115) : \u2211 i \u227a O, f(i) = O`\n\n`fsum_S (f : \u2115 \u2192 \u2115) (n : \u2115) : \u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)`\n", "\u2211 i \u227a O, f(i) = O\n", "\u2211 i \u227c n, f(i) = \u2211 i \u227a n, f(i) + f(n)\n", "Using these theorems, we can prove $\\sum_{i < n} 0 = 0$, for all natural numbers $n$.\n", "\u2211 i \u227a n, 0 = 0\n", "lemma fsum_zero (n : \u2115) : \u2211 i \u227a n, 0 = 0 :=\nbegin [pure_maths]\n  induction n,\n  case O :\n  { show \u2211 i \u227a 0, 0 = 0, from rfl, },\n  case S : k h\n  { show \u2211 i \u227c k, 0 = 0,\n    given h : \u2211 i \u227a k, 0 = 0,\n    calc\n    \u2211 i \u227c k, 0  = \u2211 i \u227a k, 0 + 0 : by rw fsum_S\n            ... = 0 + 0           : by rw h\n            ... = 0               : rfl, },\nend\n", "\n## Task\n\nLet $c : \\mathbb N$ be a constant.\nBy induction on $n$, prove that $\\sum_{i < n} c = cn$, for every natural number $n$.\n", "$\\sum_{i < n} c = cn$, for all natural numbers $c$ and $n$.\n", "attribute [simp] fsum_const -- hide\n", "end exlean -- hide", "import natural_numbers.finite_sum -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 22: Triangular numbers\n", "open_locale fsum -- hide\n", "\n## Task\n\nProve the formula for triangular numbers, that\n$$\n2\\left(\\sum_{i \\le n} i\\right) = n(n + 1),\n$$\nfor every natural number $n$.\n", "Remember that the `ring` tactic can prove most equations.\n", "Cheap algebra", "The equation `S(k) = k + 1` holds from `rfl`. Use this before\napplying the `ring` tactic.\n", "Converting from `S(k)` to `k + 1`", "If you're not sure how to get going, try the following proof template.\nFill in the `_` with an expression, add extra calculation lines and\ncomplete the final `sorry`.\n```\ninduction n,\n\ncase O :\n{ from rfl, },\n\ncase S : k h\n{ show 2 * (\u2211 i \u227c S(k), i) = S(k) * (S(k) + 1),\n  given h : 2 * (\u2211 i \u227c k, i) = k * (k + 1),\n  calc\n  2 * (\u2211 i \u227c S(k), i)\n      = 2 * (\u2211 i \u227c k, i + S(k))        : by rw fsum_S\n  ... = (k + 1) * ((k + 1) + 1)        : sorry, }\n```\n\n", "A proof template", "$2(\\sum_{i \\le n} i) = n(n + 1)$, for every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.triangle_numbers -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 23: Sums of squares\n", "open_locale fsum -- hide\n", "\n## Task\n\nProve the formula for sums of squares, that\n$$\n6\\left(\\sum_{i \\le n} i^2\\right) = n(n + 1)(2n + 1),\n$$\nfor every natural number $n$.\n", "$6(\\sum_{i \\le n} i^2) = n(n + 1)(2n + 1)$, for every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.sums_of_squares -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 24: Change of index in a sum\n", "open_locale fsum -- hide\n", "By *definition*, we have\n$$\n\\sum_{i \\le n} f(i) = \\left(\\sum_{i < n} f(i)\\right) + f(n),\n$$\ncorresponding to the intuition\n$$\nf(0) + f(1) + \\dots + f(n) = (f(0) + \\dots + f(n-1)) + f(n).\n$$\nOne should expect also that\n$$\nf(0) + f(1) + \\dots + f(n)  = f(0) + (f(1) \\dots  + f(n)),\n$$\nwhich can be written as\n$$\n\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0).\n$$\n\n\n\n", "\n## Task\n\nProve the claim above.\n", "At some point, you'll need to use a result of the form $(a + b) + c = (a + c) + b$.\nYou've proved a result that states exactly this earlier. Either use this theorem or use\none of the `ac_refl` or `ring` tactics.\n", "A helpful result", "For any function $f : \\mathbb N \\to \\mathbb N$, we have \n$\\sum_{i \\le n} f(i) = \\sum_{i < n} f(i + 1) + f(0)$,\nfor every natural number $n$.\n", "end exlean -- hide", "import natural_numbers.fsum_S_prime -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 25: Multiplying each term by a constant\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor any function $f : \\mathbb N \\to \\mathbb N$, for all natural numbers $x$ and $n$,\nprove that \n$$\nx\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i).\n$$\n", "For any function $f : \\mathbb N \\to \\mathbb N$, we have \n$x\\sum_{i \\le n} f(i) = \\sum_{i < n} x f(i)$,\nfor all natural numbers $x$ and $n$.\n", "end exlean -- hide", "import natural_numbers.mul_fsum -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 26: Summing over sums\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),\n$$\nfor every natural number $n$.\n", "For all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\sum_{i < n} (f(i) + g(i)) = \\sum_{i < n} f(i) + \\sum_{i < n} g(i),$\nfor all natural numbers $n$.\n", "end exlean -- hide", "import natural_numbers.fsum_add_distrib -- hide\n", "set_option pp.structure_projections false -- hide\n", "namespace exlean -- hide\n", "open_locale mynum -- hide\n", "open mynat -- hide\n", "# Natural numbers\n\n## Level 27: Multiplying sums\n", "open_locale fsum -- hide\n", "\n## Task\n\nFor all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nprove that \n$$\n\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)\n$$\nfor all natural numbers $m$ and $n$.\n", "There's a painful way and an easy (or easier) way to prove this result. The \neasier way is to try induction on `m`, rather than induction on `n`.`\n", "Having trouble with the induction?", "At some point in the proof, you'll need to use the results `mul_fsum` and `add_mul`.\n", "A useful result", "For all functions $f$ and $g$ of type $\\mathbb N \\to \\mathbb N$,\nwe have \n$\\left(\\sum_{i < m} f(i)\\right) \\left(\\sum_{j < n} g(j)\\right)  =\n\\sum_{i < m} \\sum_{j < n} f(i)g(j)$,\nfor all natural numbers $n$.\n", "end exlean -- hide", "Propositional logic", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\nHere, `h.left` is an abbreviation for `and.elim_left h`. Likewise for `h.right`.\n\n**Theorem**: Let $x$ be an integer. Supose $h : (x > 0) \\land (x ^ 2 = 16)$. Then $x ^ 2 = 16$.\n\n**Proof**: The result follows from right and elimination on $h$. \u220e\n\nThe Lean proof is below.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n", "p\n", "q\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16 :=\nbegin\n  from h.right,\nend\n", "Alternatively, the `cases` tactic will decompose the `\u2227` into both the left and right sides.\nBelow `cases h with h\u2081 h\u2082` decomposes `h` into `h\u2081 : x > 0` and `h\u2082 : x * x = 16`.\n", "example (x : \u2124) (h : (x > 0) \u2227 (x * x = 16)) : x * x = 16  :=\nbegin\n  cases h with h\u2081 h\u2082,  \n  show x * x = 16, from h\u2082,\nend\n", "Frequently, we consider the conjunction of several statements. \nWe can, for instance, derive $q$ given the assumption $p \\land (q \\land r)$.\n", "example (p q r : Prop) (h : p \u2227 (q \u2227 r)) : q :=\nbegin\n  have h\u2082 : q \u2227 r, from h.right,\n  show q, from h\u2082.left,\nend\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\nAdapt the proof of the example above.\n2. Write another Lean proof using `cases`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h : (r \\land (p \\land q)) \\land r$,\nwe have $q$.\n", "end exlean -- hide", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 2: And introduction\n\n## And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and to prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n", "example (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n", "The `split` tactic is an alternative (backward) proof technique. If the target is to prove `p \u2227 q`,\nthen `split` replaces the goal with two new goals: (1) to prove `p` and (2) to prove `q`.\n", "example (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  split,\n  { show p, from h\u2081, }, -- The first goal.\n  { show q, from h\u2082, }, -- The second goal.\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Replace `sorry` below with a Lean proof using `and.intro`.\n2. Write another Lean proof using `split`.\n3. On a piece of paper, state and give a handwritten proof of this result.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n", "\nThe `split` tactic splits a 'compound' target into multiple goals. \n\n### Examples\n\n`split` turns the target `\u22a2 p \u2227 q` into two goals: (1) `\u22a2 p` and (2)  `\u22a2 q`.\n\nEqually, if the target is `\u22a2 p \u2194 q`, split creates the goals (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n", "p \u2227 q\n", "variables (p q r : Prop) -- hide\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : r \\land q$.\n", "end exlean -- hide", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 3: And swap\n\n", "namespace exlean -- hide\n", "variables {p q : Prop} -- hide\n", "## Task\n\nIntuitively, you'd expect that if you have $h : p \\land q$, then you can derive $q \\land p$.\nIn this level, you'll do just that!\n\nRecall you can:\n* use `cases`, or `.left` and `.right` for and elimination and\n* use `split` or `and.intro` for and introduction.\n", "Let $p$ and $q$ be propositions. Assuming $h : p \\land q$, we have $h : q \\land p$.\n", "end exlean -- hide", "import propositional_logic.and_swap -- hide\n", "# Propositional logic\n## Level 4: Implication elimination\n\nGiven proofs of $p \\to q$ ($p$ implies $q$) and $p$, you know $q$. This is *implication elimination*,\nsometimes called *modus ponens*.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : p` is a proof of `p`, then `h\u2081 h\u2082` is a proof\nof `q`.\n\n**Notation**: The symbol `\u2192` is typed `\\r`.\n", "variables (p q r : Prop) -- hide\n", "example (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  from h\u2081 h\u2082\nend\n", "The `apply` tactic permits us to do implication elimination backward.\nThat is, if the target is to prove `q` and if we have a hypothesis `h : p \u2192 q`, then\n`apply h` replaced the target with one of proving `q`.\n\nThis corresponds to the idea that if we know $p \\to q$ then to prove $q$, it suffices to prove $p$.\n", "example (h\u2081 : p \u2192 q) (h\u2082 : p) : q :=\nbegin\n  apply h\u2081, -- The target now becomes \u22a2 q,\n  from h\u2082\nend\n", "As another example, we'll prove $r$ on the assumptions $h_1 : p \\to (q \\land r)$ and $h_2 : p$.\n", "example (h\u2081 : p \u2192 (q \u2227 r)) (h\u2082 : p) : r :=\nbegin\n  have h\u2083 : q \u2227 r, from h\u2081 h\u2082,\n  show r, from h\u2083.right,\nend\n", "namespace exlean -- hide\n", "## Task\n\nProve the following result in Lean.\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h_1 : p \\to q \\land r$ and $h_2 : p$, we have $q$.\n", "end exlean -- hide", "import propositional_logic.imp_elim -- hide\n", "# Propositional logic\n## Level 5: Implication introduction\n\nTo prove $p \\to q$ is to assume $p$ and derive $q$.\n\nIn Lean, if the target is `p \u2192 q`, typing `assume h : p` introduces `h : p` into the context\nand replaces the target with one of proving `q`.\n\nHere, we prove $(p \\land q) \\to p$.\n", "variables (p q : Prop) -- hide\n", "example : (p \u2227 q) \u2192 p :=\nbegin\n  assume h : p \u2227 q,\n  show p, from h.left,\nend\n", "namespace hidden -- hide\n", "A useful result, `id` asserts that `s \u2192 s`, for any `s`.\n", "p \u2192 p\n", "variable (s : Prop) -- hide\n", "lemma id : s \u2192 s :=\nbegin\n  assume h : s,\n  show s, from h,\nend\n", "end hidden -- hide\n", "namespace exlean -- hide\n", "In the fun example below, we prove $p \\to (q \\to p)$.\n", "example : p \u2192 (q \u2192 p) :=\nbegin\n  assume h\u2081 : p,\n  show q \u2192 p,\n  assume h\u2082 : q,\n  show p, from h\u2081,\nend\n", "## Task\n\nProve the following result in Lean.\n", "Let $p$ and $q$ be propositions. Then $(p \\land q) \\to p$.\n", "end exlean -- hide", "import propositional_logic.imp_intro -- hide\n", "# Propositional logic\n## Level 6: Proving negations\n\nGiven a proposition $p$, we write $\\neg p$ to mean 'not $p$'. Thus, $\\neg (x = 5)$ is the same as\n$x \\ne 5$. Formally, $\\neg p$ is an abbreviation for $p\\to\\bot$, where $\\bot$ is read 'false'\nor 'contradiction'.\n\nWe've seen that to prove $p \\to q$ is to assume $p$ and derive $q$. Thus, to prove $\\neg p$ is to\nassume $p$ and derive $\\bot$.\n\n**Notation**: The symbol `\u00ac` is typed `\\n` or `\\not`. The mathematical symbol $\\bot$ is written\n`false` in Lean.\n\nUsing these ideas, we'll prove $p \\to \\neg\\neg p$.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "p \u2192 \u00ac\u00acp\n", "lemma not_not_intro : p \u2192 \u00ac\u00acp :=\nbegin \n  assume h\u2081 : p,\n  show \u00ac\u00acp,\n  show \u00acp \u2192 false,\n  assume h\u2082 : \u00acp, -- So h\u2082 : p \u2192 false\n  show false, from h\u2082 h\u2081,\nend\n", "Implication elimination is used in the last line of the proof above. Lean permits *backward*\nimplication elimination via the `apply` tactic.\nIf the target is to prove `q` and if `h : p \u2192 q`, then typing `apply h`, transforms\nthe target to one of proving `p`.\n\nBelow, we prove $r$ on the assumptions $h_1 : (p \\land q) \\to r)$, $h_2 : p$ and $h_3 : q$.\nThe first step is to realise that $r$ is the 'conclusion' of $h_1$, whence `apply h\u2081` transforms\nthe goal to one of proving $p \\land q$.\n", "example (h\u2081 : (p \u2227 q) \u2192 r) (h\u2082 : p) (h\u2083 : q) : r :=\nbegin\n  apply h\u2081,\n  show p \u2227 q, from and.intro h\u2082 h\u2083,\nend\n", "## Task\n\nProve the logical principle that $\\neg q \\to \\neg p$ follows from $p \\to q$. This is\nsometimes called *modus tollens*.\n\nYou'll need to perform implication introduction three times and implication elimination twice.\nFor fun, try both formward and backward implication elimination.\n", "Let $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg q \\to \\neg p)$.\n", "end exlean -- hide", "import propositional_logic.proving_negation -- hide\n", "# Propositional logic\n## Level 7: Or introduction\n\nThe proposition $p \\lor q$ has the informal meaning '$p$ or $q$'. To prove $p \\lor q$ is:\n1. [left or introduction] to prove $p$ or`\n2. [right or introduction] to prove $q$.\n\nIn Lean, suppose `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`. Then\n`or.inl h\u2081` is a proof of `p \u2228 q` and `or.inr h\u2082` is a proof of `p \u2228 q`.\n\n**Notation**: `\u2228` is typed `\\or`.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "example (h\u2081 : p) : p \u2228 q :=\nbegin\n  from or.inl h\u2081,\nend\n", "-- hide\n", "example (h\u2082 : q) : p \u2228 q :=\nbegin\n  from or.inr h\u2082,\nend\n", "For example, we'll prove `p \u2228 (q \u2227 r)` given `h : p`.\n", "example (h : p) : p \u2228 (q \u2227 r) :=\nbegin\n  from or.inl h,\nend\n", "  (h : p) : p \u2228 q\n", "  (h : q) : p \u2228 q\n", "`left` changes a goal of proving `p \u2228 q` into a goal of proving `p`.\n", "`right` changes a goal of proving `p \u2228 q` into a goal or proving `q`.\n", "As a backward alternative, if the target is to prove `p \u2228 q`, the `left` tactic replaces the target\nwith one of proving `p`. Likewise for the `right` tactic.\n\nHere is a backward proof that $q \\lor (p \\lor r)$ follows from $h : p$.\n", "example (h : p) : q \u2228 (p \u2228 r) :=\nbegin \n  show q \u2228 (p \u2228 r),\n  right,\n  show p \u2228 r,\n  left,\n  show p, from h,\nend\n", "To prove the same result forward involves the introduction of hypotheses.\n", "example (h : p) : q \u2228 (p \u2228 r) :=\nbegin\n  have h\u2082 : p \u2228 r, from or.inl h,\n  show q \u2228 (p \u2228 r), from or.inr h\u2082,\nend\n", "## Task\n\nProve the following in Lean and by hand.\n", "Let $p$, $q$ and $r$ be propositions. Then $(p \\lor q) \\lor r$ follows from the assumption\n$h : q$.\n", "end exlean -- hide", "import propositional_logic.or_introduction -- hide\n", "# Propositional logic\n## Level 8: Or elimination\n\nSuppose you are given $h : p \\lor q$. To prove $r$ is to\n1. Assume $p$ and derive $r$ and (separately) to\n2. assume $q$ and derive $r$.\n\nThis is (backward) *or elimination*.\n\nFor example, we prove $q \\lor p$ on the assumption $h : p \\lor q$.\n\n**Proof**:\n1. Assume $h_2 : p$. We must show $q \\lor p$. This follows from right or introduction on $h_2$.\n2. Assume $h_3 : q$. We must show $q \\lor p$. This follows from left or introduction on $h_3$.\n\n\nIn Lean, the `cases` tactic performs backward or elimination. With hypotheses as above,\n`cases h with h\u2082 h\u2083` creates two new goals:\n1. to prove `r` under the assumption `h\u2082 : p` and, separately\n2. to prove `r` under the assumption `h\u2083 : q`.\n\nHere is a Lean proof of the result above.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "q \u2228 p\n", "lemma or.swap (h : p \u2228 q) : q \u2228 p :=\nbegin\n  cases h with h\u2082 h\u2083,\n  { given h\u2082 : p,\n    show q \u2228 p, from or.inr h\u2082, },\n  { given h\u2083 : q,\n    show q \u2228 p, from or.inl h\u2083, },\nend\n", "## Task\n\nProve the following in Lean and by hand. For the adventurous, see the end of this level for discussion\nof *forward* or elimination. Come back and try a forward argument of this result.\n", "Let $p$, $q$ and $r$ be propositions. Then $p$ follows from the assumption\n$h : (p \\land q) \\lor (r \\land p)$.\n", "## Forward or elimination\n\nI find it simplest to use or elimination in its backward form. For the sake of completeness, I\ninclude the forward version.\n\nLet $h : p \\lor q$ be a proof of $p \\lor q$, $h_1 : p \\to r$ a proof of $p \\to r$ and let $h_2 : q \\to r$ be a proof of $q \\to r$.\nThen (forward) *or elimination* applied to $h$, $h_1$, and $h_2$ is a proof of $r$.\n\nThe Lean name of the formard or elimination result is `or.elim`. Below, we use it to re-prove `or.swap`.\n", "r\n", "example  (h : p \u2228 q) : q \u2228 p :=\nbegin\n  have h\u2081 : p \u2192 (q \u2228 p),\n  { assume k : p,\n    show q \u2228 p, from or.inr k, },\n", "  -- hide\n", "  have h\u2082 : q \u2192 (q \u2228 p),\n  { assume k : q,\n    show q \u2228 p, from or.inl k,  },\n", "  -- hide\n", "  show q \u2228 p, from or.elim h h\u2081 h\u2082,\nend\n", "end exlean -- hide", "import propositional_logic.or_elimination -- hide\n", "# Propositional logic\n## Level 9: Iff elimination\n\nThe proposition $p \\leftrightarrow q$ represents the informal notation '$p$ if and only if $q$'.\n\nSuppose you are given `h : p \u2194 q` Then\n1. [left iff elimination] `h.mp` is a proof of `p \u2192 q` and\n2. [right iff elimination] `h.mpr` is a proof of `q \u2192 p`.\n\nHere, `h.mp` is an abbreviation of `iff.elim_left`. Likewise for `h.mpr`.\n\n**Notation**: `\u2194` is typed `\\iff`.\n\nUsing this, we'll prove $p$ on the assumptions $h_1 : p \\leftrightarrow q$ and $h_2 : q$.\n\n**Proof**:\nWe have $h_3 : q \\to p$ by right iff elimination on $h_1$.\nFrom $h_3$, it suffices to show $q$, which follows from $h_2$.\n", "p \u2192 q\n", "q \u2192 p\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "The same result may be proved in Lean.\n", "example (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  have h\u2083 : q \u2192 p, from iff.elim_right h\u2081,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n", "Alternatively, the `cases` tactic (much as for and elimination) decomposes `h : p \u2194 q` into proofs\nof `p \u2192 q` and `q \u2192 p`. We use this below and also \n", "example (h\u2081 : p \u2194 q) (h\u2082 : q) : p :=\nbegin\n  cases h\u2081 with k h\u2083,\n  given h\u2083 : q \u2192 p,\n  apply h\u2083,\n  show q, from h\u2082,\nend\n", "## Task\n\nProve the following in Lean and by hand. Use either forward or backward iff elimination.\n", "Let $p$, $q$ and $r$ be propositions. Then $q$ follows from the assumptions\n$h : p \\leftrightarrow (q \\land r)$ and $k : p$.\n", "end exlean -- hide", "import propositional_logic.iff_elimination -- hide\n", "# Propositional logic\n## Level 10: Iff introduction\n\nTo *prove* $p\\leftrightarrow q$ is to prove $p \\to q$ and to prove $q \\to p$.\n\nIn Lean, if `h\u2081 : p \u2192 q` is a proof of `p \u2192 q` and `h\u2082 : q \u2192 p` is a proof of `q \u2192 p`, then\n`iff.intro h\u2081 h\u2082` is a proof of `p \u2194 q`.\n\nNote the similarities between `\u2227` and `\u2194`.\n", "p \u2194 q\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "example (p q : Prop) (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 p) : p \u2194 q :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n", "Recall we earlier proved `and.swap` which gives `q \u2227 p` from `p \u2227 q`.\nWe'll use this to prove `(a \u2227 b) \u2194 (b \u2227 a)`.\n", "a \u2227 b \u2194 b \u2227 a \n", "lemma and.comm {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  have h\u2081 : a \u2227 b \u2192 b \u2227 a, from and.swap,\n  have h\u2082 : b \u2227 a \u2192 a \u2227 b, from and.swap,\n  show a \u2227 b \u2194 b \u2227 a, from iff.intro h\u2081 h\u2082,\nend\n", "As with `\u2227` introduction, the `split` tactic changes a goal of proving `p \u2194 q` into two\nnew goals: (1) to prove `p \u2192 q` and (2) to prove `q \u2192 p`. This is backward iff introduction.\n", "example {a b : Prop} : (a \u2227 b) \u2194 (b \u2227 a) :=\nbegin\n  split,\n  { show (a \u2227 b) \u2192 (b \u2227 a), from and.swap, },\n  { show (b \u2227 a) \u2192 (a \u2227 b), from and.swap, }, \nend\n", "## Task\n\nProve the commutativity of `\u2228` in Lean and by hand.\n", "Let $p$ and $q$ be propositions. Then $(p \\lor q) \\leftrightarrow (q \\lor p)$.\n", "end exlean -- hide", "import propositional_logic.iff_introduction -- hide\n", "# Propositional logic\n## Level 11: True and false\n\nWe have two propositional constants, $\\top$ and $\\bot$, written as \n`true` and `false` in Lean.\n\nThere's not much to say about $\\top$. It's always true. The proof of this is `trivial`, also called\n*true introduction*.\n", "true\n", "example : true :=\nbegin\n  from trivial,\nend\n", "False ($\\bot$) is more interesting! The single governing principle of `false` is that\n*anything follows from false*, a principle called *false elimination* or *exfalso sequitur quodlibet*.\n\nIn Lean, if `h : false` is a proof of `false` and if `p` is *anything*, then `false.elim h` is\na proof / construction of `p`.\n", "p\n", "universe u -- hide\n", "example (p : Sort u) (h : false) : p :=\nbegin\n  from false.elim h,\nend\n", "namespace exlean -- hide\n", "## Task\n\nRecall that $\\neg p$ is shorthand for $p \\to \\bot$ (or `p \u2192 false` in Lean notation).\n\nUse this to prove that anything follows from the assumptions of $p$ and $\\neg p$.\n", "Let $p$ and $q$ be propositions. Then $q$ follows from $h_1 : p$ and\n$h_2 : \\neg p$.\n", "end exlean -- hide", "import propositional_logic.true_and_false tactic.localized -- hide\n", "# Propositional logic\n## Level 12: Law of the excluded middle, proof by cases, proof by contradiction\n\nGiven a proposition $p$, the law of the excluded middle is the assertion $p \\lor \\neg p$.\n\nIn Lean, if `p : Prop`, then `em p` is the assertion `p \u2228 \u00acp`.\n", "p \u2228 \u00acp\n", "open_locale classical -- hide\n", "example (p : Prop) : p \u2228 \u00acp :=\nbegin\n  from em p,\nend\n", "namespace exlean -- hide\n", "variables {p q : Prop} -- hide\n", "From the law of the excluded middle, we derive a proof method called 'proof by cases'.\nNamely, to prove $q$, it suffices to prove $p \\to q$ and $\\neg p \\to q$.\n\nThe first step of the proof is to deduce $h : p \\lor \\neg p$, by the law of the\nexcluded middle. The rest of the proof follows by or elimination on $h$.\n\n", "q\n", "theorem by_cases (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  have k : p \u2228 \u00acp, from em p,\n  cases k with k\u2081 k\u2082,\n  { given k\u2081 : p,\n    show q, from h\u2081 k\u2081, },\n  { given k\u2082 : \u00acp,\n    show q, from h\u2082 k\u2082, },\nend\n", "\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses.\nFor example, if you write `by_cases h : p`, then Lean creates two new goals\n(1) to prove the target under the assumption\n`h : p` and (2) separately to prove the target under the assumption `h : \u00acp`.\n\n", "This is such a useful theorem that Lean provides a `by_cases` tactic to help write\nbackward proofs by cases. It's best illustrated by example.\n\nWe call `by_cases` with the name of a proposition `p` and a tag for the resulting hypotheses\n(here, we used `k`). The tactic creates two new goals (1) to prove the target under the assumption\n`k : p` and (2) separately to prove the target under the assumption `k : \u00acp`.\n", "example (h\u2081 : p \u2192 q) (h\u2082 : \u00acp \u2192 q) : q :=\nbegin\n  by_cases k : p,\n  { given k : p,\n    show q, from h\u2081 k, },\n  { given k : \u00acp,\n    show q, from h\u2082 k, },\nend\n", "## Tasks\n\nProof by contradiction asserts that to prove $p$, it suffices to show that $\\neg p$ leads to a\ncontradiction. Equally, to prove $(\\neg p \\to \\bot) \\to p$.\n\n1. Your first task is to complete the result below, the principle of 'proof by contradiction',\nusing any of the methods shown above (law of the excluded middle, the proof by cases theorem or the proof\nby cases tactic).\n2. Lean offers a `by_contra` tactic to help write backward proofs by contradiction.\nProve the theorem below by starting with `by_contra k`. This introduces the hypothesis `k : \u00acp`\nand makes proving `false` the target.\n\n", "\nProof by contradiction. If the target is to prove `p`, using the tactic `by_contra h` will introduce the hypothesis `h : p`\nand change the target to one of proving `false`. \n", "Proof by contradiction. Given a proposition $p$, we have $\\neg \\neg p \\to \\bot$.\n", "end exlean -- hide", "import propositional_logic.lem -- hide\n", "# Propositional logic\n## Level 13: Propositional extensionality\n\nLet $\\alpha$ and $\\beta$ be propositions. Suppose $\\alpha\\leftrightarrow\\beta$. Then anything that holds for $\\alpha$ holds for $\\beta$\nand vice-versa. This is called *propositional extensionality*.\n\nUsing propositional extensionality is similar to using `rw` to write backward proofs in the\nequation world.\n", "namespace exlean -- hide\n", "variables {p q r : Prop} -- hide\n", "We prove $p \\lor (q\\land r) \\to p \\lor (r \\land q)$ by propositional extensionality.\n\n**Proof**:\n$$\n\\begin{align}\n&& p \\lor (q\\land r) \\to (r \\land q) \\lor p& &  \\\\\\\\\n&\\iff & p \\lor (r\\land q) \\to (r \\land q) \\lor p & & \\text{[by commutativity of $\\land$]} \\\\\\\\\n&\\iff & (r \\land q) \\lor p \\to (r \\land q) \\lor p. & & \\text{[by commutativity of $\\lor$]} \\\\\\\\\n\\end{align}\n$$\nThe last line follows by reflexivity of $\\to$. \u220e\n", "The same proof is given below in Lean.\n", "example : p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p :=\nbegin\n  show p \u2228 (q \u2227 r) \u2192 (r \u2227 q) \u2228 p, rw and.comm,\n  show p \u2228 (r \u2227 q) \u2192 (r \u2227 q) \u2228 p, rw or.comm,\n  show (r \u2227 q) \u2228 p \u2192 (r \u2227 q) \u2228 p, from id,\nend\n", "Before moving on to the task for this level, we'll prove a helpful\nequivalence, that $\\neg\\neg p \\leftrightarrow p$.\n", "\u00ac\u00acp \u2194 p\n", "lemma not_not {p : Prop} : \u00ac\u00acp \u2194 p :=\nbegin\n  have h\u2081 : \u00ac\u00acp \u2192 p, from by_contra,\n  have h\u2082 : p \u2192 \u00ac\u00acp, from not_not_intro,\n  show \u00ac\u00acp \u2194 p, from iff.intro h\u2081 h\u2082,\nend\n", "## Tasks\n1. Prove the result below in Lean using propositional extensionality. Follow the idea\nof the proof above.\n2. If you're feeling adventurous, try proving the result *without* using propositional\nextensionality.\n\n", "Let $p$, $q$, and $r$ be propositions. Then\n$q \\land \\neg\\neg(r \\lor p) \\to (p \\lor r) \\land q$.\n", "end exlean -- hide", "import propositional_logic.prop_ext -- hide\n", "# Propositional logic\n## Level 14: Implication redux, part 1\n\nThe aim of this level and the next is to prove $p \\to q$ is equivalent to $\\neg p \\lor q$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\lor q) \\to (p \\to q)$.\n", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor q) \\to (p \\to q)$.\n", "end exlean -- hide", "import propositional_logic.implication_redux1 -- hide\n", "# Propositional logic\n## Level 15: Implication redux, part 2\n\nIn this level, we prove the converse of the result of the previous level.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(p \\to q) \\to (\\neg p \\lor q)$.\n", "For this result, you'll need to use a non-constructive proof method\n(law of the excluded middle, proof by contradiction, proof by cases, and so forth).\nI suggest proof by cases on `p`.\n", "Suggested approach", "If you get stuck, try the following template.\n```\nassume h : p \u2192 q,\nshow \u00acp \u2228 q,\nby_cases k : p,\n{ given k : p,\n  sorry, },\n{ given k : \u00acp,\n  sorry, },\n```\n\n", "A proof template", "Let $p$ and $q$ be propositions. Then $(p \\to q) \\to (\\neg p \\lor q)$.\n", "end exlean -- hide", "import propositional_logic.implication_redux2 -- hide\n", "# Propositional logic\n## Level 16: De Morgan's laws 1\n\nDe Morgan's laws state:\n* $\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$ and\n* $\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n\nIn this series of levels, you will prove the four implications that\ntogether constitute these laws.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement.\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan1 -- hide\n", "# Propositional logic\n## Level 17: De Morgan's laws 2\n\nWe continue our examination of De Morgan's laws by proving the\n'backward' direction of \n\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $(\\neg p \\land \\neg q) \\to \\neg(p \\lor q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nAt some point, you will need to decompose an or statement and an\nand statement.\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan2 -- hide\n", "# Propositional logic\n## Level 18: De Morgan's laws 3\n\nWe now prove the forward direction of:\n$\\neg(p \\lor q) \\leftrightarrow (\\neg p \\land \\neg q)$.\n", "namespace exlean -- hide\n", "## Task\nProve in Lean that $\\neg(p \\lor q) \\to (\\neg p \\land \\neg q)$. \n", "You need to prove an implication. Thus, you should start by assuming\nthe left hand side of the implication.\n\nYou then have to prove an `\u2227` statement. What should you do?\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "import propositional_logic.de_morgan3 -- hide\n", "# Propositional logic\n## Level 19: De Morgan's laws 4\n\nWe continue our examination of De Morgan's laws by proving the\n'forward' direction of \n\n$\\neg(p \\land q) \\leftrightarrow (\\neg p \\lor \\neg q)$.\n\n\nFor this level, it will be helpful to have a proof of\n$\\neg(p \\to q) \\leftrightarrow (\u00acp \\lor q)$.\n\nWe prove this by combining two results from previous levels:\n", "namespace exlean -- hide\n", "(p \u2192 q) \u2194 (\u00acp \u2228 q)\n", "lemma imp_iff_not_or {p q : Prop} : (p \u2192 q) \u2194 (\u00acp \u2228 q) :=\nbegin\n  have h\u2081 : (p \u2192 q) \u2192 (\u00acp \u2228 q), from not_or_of_imp,\n  have h\u2082 : (\u00acp \u2228 q) \u2192 (p \u2192 q), from or.neg_resolve_left,\n  show (p \u2192 q) \u2194 (\u00acp \u2228 q), from iff.intro h\u2081 h\u2082,\nend\n", "## Task\nProve in Lean that $\\neg(p \\land q) \\to (\\neg p \\lor \\neg q)$. \n", "\nAt some point in your proof, you will have a target of the form `\u00aca \u2228 b`.\n\nTo prove this kind of statement requires 'classical reasoning'. That is,\nyou'll need to use something like the law of the excluded middle,\nproof by cases, proof by contradiction, or a result that uses one of\nthose principles.\n\nPerhaps the simplest approach is to use the lemma `imp_iff_not_or` above.\n\nUsing this lemma, you can turn the target (of the form `\u00aca \u2228 b`) into\na statement of the form `a \u2192 b`. To do this, rewrite\nfrom the left, typing\n\n`rw \u2190imp_iff_not_or`\n", "Suggested approach", "Let $p$ and $q$ be propositions. Then $(\\neg p \\lor \\neg q) \\to \\neg(p \\land q)$.\n", "end exlean -- hide", "Predicate logic", "import data.nat.basic propositional_logic.de_morgan4 -- hide\n", "# Predicate logic\n## Level 1: For all elimination\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nGiven $h : \\forall (x : X),\\ P(x)$ and given $y : X$, the *for all\nelimination rule* applied to $h$ and $y$ gives a proof of $P(y)$.\n\nAs an example, let $h$ be a proof that\n$\\forall (n : \\mathbb N),\\ (n + 1)^2 = n ^ 2 + 2n + 1$.\n\nThen 'for all elimination', applied to $h$ and $ab$ (for natural \nnumbers $a$ and $b$) gives a proof of\n$(ab + 1)^2 = (ab)^2 + 2(ab) + 1$.\n\nIn Lean, if `h : \u2200 (x : X), P(x)` and if `y : X`, then the\nexpression `h(y)` is a proof of `P(y)`.\n\nThe symbol `\u2200` is typed `\\all`.\n\nHere follows a Lean translation of the above example.\n", "example (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  from h (a * b),\nend\n", "An alternative approach is to use the `specialize` tactic.\nGiven a hypothesis `h : \u2200 (x : X), P(x)` and given a term `y : X`,\ntyping `specialize h y` replaces `h` with `h : P(y)`.\n\nThat is, the general statment `\u2200 (x : X), P(x)` is replaced with\nits specialisation to `y`.\n\nHere is the same result as above, proved using the `specialize` tactic.\nAfter the first line, the hypothesis `h` changes to\n`h : (a * b + 1) ^ 2 = (a * b) ^ 2 + 2 * (a * b) + 1`\n\nIt is used directly in the last line to conclude the proof.\n", "example (a b : \u2115) (h : \u2200 (n : \u2115), (n + 1)^2 = n^2 + 2 * n + 1)\n: (a * b + 1) ^ 2 = (a * b)^2 + 2 * (a * b) + 1 :=\nbegin\n  specialize h (a * b),\n  from h,\nend\n", "`specialize` changes a proof of a `\u2200` statement to its specialisation at a particular value.\n\n### Example\n\nGiven `h : \u2200 (x : \u2124), f(x) = 10`, typing `specialize h 3` replaces `h` with\n`h : f(3) = 10`.\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below using for all elimination.\n2. Prove the result below using the `specialize` tactic.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (x : \\mathbb N),\\ f(x) = f(x + 1)$.\nThen $f(5) = f(5 + 1)$.\n", "end exlean -- hide", "import predicate_logic.forall_elimination -- hide\n", "# Predicate logic\n## Level 2: For all introduction\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo *prove* a statement $\\forall (x : X),\\ P(x)$ is to assume $y$\nis a term of type $X$ and to prove $P(y)$. This is the *for all\nintroduction* rule.\n\nIn this rule, there's nothing special about the name of the variable\n$y$ or the variable $x$.\n\n\n\nAs an example, suppose $P$ and $Q$ are predicates on a type $B$.\nWe'll prove $\\forall (b : B),\\ Q(b)$, given\n$h : \\forall (z : B),\\ P(z) \\land Q(z)$.\n\n**Proof** Assume $y : B$. We must show $Q(y)$.\nBy for all elimination on $h$ and $y$, we have $h_2 : P(y) \\land Q(y)$.\nWe show $Q(y)$ by right and elimination on $h_2$. \u220e\n\n*Note*: we don't explictly refer to the 'for all introduction' rule\nwhen proving a for all statement.\n", "variables (B : Type*) (P Q : B \u2192 Prop) -- hide\n", "example (h : \u2200 (z : B), P(z) \u2227 Q(z)) : \u2200 (b : B), Q(b) :=\nbegin\n  assume y : B,\n  show Q(y),\n  have h\u2082 : P(y) \u2227 Q(y), from h y,\n  show Q(y), from h\u2082.right,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean.\n2. Prove the result below by hand.\n", "Let $P$ and $Q$ be predicates on a type $B$. Suppose\n$h : \\forall (z : B),\\ P(z)$,\nthen $\\forall (b : B),\\ Q(b) \\lor P(b)$.\n", "end exlean -- hide", "import predicate_logic.forall_intro tactic.linarith -- hide\n", "# Predicate logic\n## Level 3: For all practice\n\n**Theorem**: Let $g : \\mathbb N \\to \\mathbb N$ be a function such\nthat $h : \\forall (n : \\mathbb N),\\ g(n + 1) = 2g(n)$. Then\n$\\forall (m : \\mathbb N),\\ g(m + 2) = 4g(m)$.\n\n**Proof**: Assume $m : \\mathbb N$. We must show $g(m + 2) = 4g(m)$.\nNow,\n$$\n\\begin{align}\ng(m + 2) &= g((m + 1) + 1) & & \\text{[by arithmetic]} \\\\\\\\\n&= 2 g(m + 1) & &\\text{[by $h$, specialised at $m + 1$]} \\\\\\\\\n&= 2 (2 g(m)) & &\\text{[by $h$, specialised at $m$]} \\\\\\\\\n&= 4g(m). & & \\text{[by arithmetic]}\n\\end{align}\n$$\n \u220e\n", "The handwritten proof above can be written in Lean. \nThe `linarith` tactic roughly corresponds to the English phrase\n'by arithemtic'. In particular, `linarith` proves many linear\nequations and inequalities.\n", "Proves many linear equations and inequalities.\n", "example (g : \u2115 \u2192 \u2115)\n(h : \u2200 (n : \u2115), g(n + 1) = 2 * g(n)) :\n\u2200 (m : \u2115), g(m + 2) = 4 * g(m) :=\nbegin\n  assume m : \u2115,\n  show g(m + 2) = 4 * g(m),\n  calc\n  g(m + 2)  = g((m + 1) + 1)  : by linarith\n        ... = 2 * g(m + 1)    : by rw h (m + 1)\n        ... = 2 * (2 * g(m))  : by rw h m\n        ... = 4 * g(m)        : by linarith\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function such that\n$\\forall (a : \\mathbb N),\\ f(a) + f(a + 1) = f(a + 2)$. Then\n$\\forall (m : \\mathbb N),\\ 2 f(m + 2) = f(m) + f(m + 3)$.\n", "end exlean -- hide", "import predicate_logic.forall_practice -- hide\n", "# Predicate logic\n## Level 4: Exists introduction 1\n\nThe symbol $\\exists$ is real 'there exists' and is called the\nexistential quantifier.\n\nSuppose $P : X \\to \\mathsf{Prop}$ is a predicate on a type $X$.\nTo prove $\\exists (x : X),\\ P(x)$ is to exhibit a term $y : X$\nand a proof of $P(y)$. This is called *exists introduction*.\n\nAs an example, we'll prove an existentially quantified statement.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\nThe idea of the proof is to find an natural number $x$ together\nwith a proof that $x^2 + 2 = 3x$. How we *find* such a natural\nnumber is not relevant to the proof. In this case, you might\ntry to find an $x$ by rearranging the equation $x^2 + 2 = 3x$ into\n$(x - 2)(x - 1) = 0$, from which it is clear that $2$ or $1$ could\nbe taken as values for $x$.\n\n**Proof**: We have $h : 2^2 + 2 = 3 \\times 2$, by arithmetic.\nWe show $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$ by\nexists introduction on $2$ and $h$. \u220e\n\nIn Lean, `\u2203` is typed `\\exists`. The exists introduction rule is\ncalled `Exists.intro`. Given `y : X` and a proof `h : P(y)`,\n`Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n", "\u2203 (x : X), P(x)\n", "example : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  have h : 2 ^ 2 + 2 = 3 * 2, linarith,\n  from Exists.intro 2 h,\nend\n", "Our next example involves a more complicated predicate.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nWe have $h : (1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$ as\n1. $1 < 2$ by arithmetic and\n2. $1 ^ 2 + 2 = 3 \\times 1$ by arithmetic.\n\nWe show $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$\nfrom exists introduction on $1$ and $h$. \u220e\n\nIn the Lean proof below, we use the `split` tactic to prove the\n`\u2227` statement (recall this is backward and introduction).\n", "example : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  have h : (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  { split,\n      show 1 < 2, linarith,\n      show 1 ^ 2 + 2 = 3 * 1, linarith, },\n  from Exists.intro 1 h,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\n1. Prove the result below in Lean, using the same basic structure as\nthe proof above.\n2. Prove the result below by hand.\n", "$\\exists (m : \\mathbb N),\\ (m > 5) \u2227 (m ^ 2 + 40 = 14 m)$\n", "end exlean -- hide", "import predicate_logic.exists_intro -- hide\n", "# Predicate logic\n## Level 5: Exists introduction 2\n\nIn the previous level, we saw that if `y : X` and if `h : P(y)`,\nthen `Exists.intro y h` is a proof of `\u2203 (x : X), P(x)`.\n\nThis is a 'forward' approach to the proof. Often, it is more\nnatural to give a 'backward' proof. Here a handwritten example.\n\n**Theorem**: $\\exists (m : \\mathbb N),\\ m^2 + 2 = 3 m$.\n\n**Proof**: Take $m$ to be $2$. It suffices to prove $2^2 + 2 = 3\\times 2$.\nBut this holds by arithmetic. \u220e\n\nIn Lean, we type `use 2` in place of the handwritten, 'Take $m$\nto be $2$'.\n", "\nThe `use` tactic is used to prove `\u2203` statements.\nIf the target is to prove `\u2203 (x : X), P(x)` and if `y : X`, then\n`use y` changes the target to one of proving `P(y)`.\n\n### Example\n\nThe tactic `use 2` can be employed in the first line of the\nproof of $\\exists (m : \\mathbb N) : m ^ 2 + 2 = 3m$. It\nchanges the target to one of proving $2^2 + 2 = 3 \\times 2$.\n\n```\nexample :\n\u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2,\n  linarith,\nend\n```\n", "example : \u2203 (m : \u2115), m ^ 2 + 2 = 3 * m :=\nbegin\n  use 2,\n  show 2 ^ 2 + 2 = 3 * 2, linarith,\nend\n", "**Theorem**: $\\exists (m : \\mathbb N),\\ (m < 2) \\land (m^2 + 2 = 3 m)$.\n\n**Proof**:\nLet $m$ be $1$. We'll show $(1 < 2) \\land (1 ^ 2 + 2 = 3 \\times 1)$.\nBut\n1. $1 < 2$ by arithmetic and\n2. $1 ^ 2 + 2 = 3 \\times 1$ by arithmetic. \u220e\n", "example : \u2203 (m : \u2115), (m < 2) \u2227 (m ^ 2 + 2 = 3 * m) :=\nbegin\n  use 1,\n  show (1 < 2) \u2227 (1 ^ 2 + 2 = 3 * 1),\n  split,\n    show 1 < 2, linarith,\n    show 1 ^ 2 + 2 = 3 * 1, linarith, \nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean, via the `use` tactic.\n", "$\\exists (m : \\mathbb N),\\ (m < 5) \\land\n((m ^ 2 + 18 = 9 m) \\lor (m ^ 2 + 35 = 12 m))$\n", "end exlean -- hide", "import predicate_logic.exists_intro2 -- hide\n", "# Predicate logic\n## Level 6: Exists elimination 1\n\nWe've seen how to prove existentially-quantified statements.\nHow do we *use* an existentially-quantified statement?\n\nLet's begin with an informal argument.\n\n**Theorem**: Suppose\n$h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$.\nThen $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: From $h$, we have an integer $x$ such that\n$h_2 : 32 x ^ 5 + 160 x ^ 4$ = 5184$.\n\nTake $n$ to be $2x$. It suffices to prove $(2x)^5 + 10 (2x)^4 = 5184$,\nbut this follows by arithmetic.\n\u220e\n\n", "More formally, the *exists elimination* rule produces a proof\nof a proposition $q$ if it is given a proof of\n$\\exists (x : X), P(x)$ and a proof of\n$\\forall (y : X), (P(y) \\to q)$.\n", "q\n", "We prove the result above using exists elimination. Recall we \nare given $h : \\exists (m : \\mathbb Z),\\ 32m ^ 5 + 160 m ^ 4 = 5184$\nand we are to prove $\\exists (n : \\mathbb Z),\\ n^5 + 10n^4 = 5184$.\n\n**Proof**: We have $h_2 : \\forall (y : \\mathbb Z),\\\n  ( 32 y ^ 5 + 160 y ^ 4 = 5184  \\to\n    \\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184 )$ as follows:\n> Assume $y : \\mathbb Z$.\n> Assume $h : 32 y ^ 5 + 160 y ^ 4 = 5184$.\n> We must show $\\exists (n : \\mathbb Z), n ^ 5 + 10 n ^ 4 = 5184$. \n> Take $n$ to be $2y$.\n> We must show $(2y)^5 + 10(2y)^4 = 5184$. This follows by\n> arithmetic.\n\nThe result follows by exists elimination on $h$ and $h_2$. \u220e\n\n", "In the proof below, `exists.elim` is the Lean version of the\nexists elimination rule.\n", "example (h : \u2203 (m : \u2124), 32 * m ^ 5 + 160 * m ^ 4 = 5184) :\n\u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184  :=\nbegin\n  have h\u2082 : \u2200 (y : \u2124),\n  (32 * y ^ 5 + 160 * y ^ 4 = 5184 \u2192 \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184),\n  { assume y : \u2124,\n    assume h\u2083 : 32 * y ^ 5 + 160 * y ^ 4 = 5184,\n    show \u2203 (n : \u2124), n ^ 5 + 10 * n ^ 4 = 5184,\n    use 2 * y,\n    show (2 * y) ^ 5 + 10 * (2 * y) ^ 4 = 5184, linarith, },\n  from exists.elim h h\u2082,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean using `exists.elim`.\n", "Let $f : \\mathbb N \\to \\mathbb N$ be a function.\nGiven $h : \\exists (x : \\mathbb N),\\ f(5x) = 10x$, prove\n$\\exists (m : \\mathbb N),\\ f(m) = 2m$.\n", "end exlean -- hide", "import predicate_logic.exists_elim1 -- hide\n", "# Predicate logic\n## Level 7: Exists elimination 2\n\nThe exists elimination rule can be tricky to use. In this level,\nwe introduce a Lean tactic that simulates the informal style\nof proof we showed at the beginning of the previous level.\n\nHere is a theorem statement and an informal proof.\n\n**Theorem**: Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ Q(z)$.\n\n**Proof**: From $h$, we have a term $y : X$ such that\n$h_2 : P(y) \\land Q(y)$.\n\nTake $z$ to be $y$. We must show $Q(y)$. But this follows by\nright and elimination on $h_2$. \u220e\n\n", "In Lean, we decompose a given `\u2203` statement using the `cases`\ntactic (much as we do for `\u2228` statements).\n\nIn the proof below `cases h with x h\u2082` introduces a new\nvariable `x : \u2124` together with a proof\n`h\u2082 : P(y) \u2227 Q(y)`. The optional `given`\nstatement is there to indicate to the reader what `h\u2082` asserts.\n", "variable (X : Type) -- hide\n", "example (P Q : X \u2192 Prop) (h : \u2203 (x : X), P(x) \u2227 Q(x)) :\n\u2203 (z : X), Q(z) :=\nbegin\n  cases h with y h\u2082,\n  given h\u2082 : P(y) \u2227 Q(y),\n  use y,\n  show Q(y), from h\u2082.right,\nend\n", "namespace exlean -- hide\n", "## Tasks\n\nProve the result below in Lean, via the `cases` tactic.\n", "Let $P$ and $Q$ be predicates on a type $X$.\nSuppose $h : \\exists (x : X), P(x) \\land Q(x)$.\nThen $\\exists (z : X),\\ P(z) \\lor Q(z)$.\n", "end exlean -- hide", "import predicate_logic.exists_elim2 -- hide\n", "# Predicate logic\n## Level 8: Extensionality of predicates\n\nConsider the predicates $P$ and $Q$ on the type of natural numbers\ngiven by $P(x) := x < 5$ and $Q(y) := 2y < 10$.\n\nOn the one hand, $P$ and $Q$ are clearly different. They\nhave different meanings. The proposition\n$Q(y)$ involves a multiplication by $2$. The definition of $Q$\nseems to involve a variables $y$ whereas that of $P$ seems to\ninvolve a variable $x$.\n\nBut, on the other hand, $P$ and $Q$ are clearly the same predicate.\nIndeed, for every integer $m$, $P(m)$ holds if and only if\n$Q(m)$ holds.\n\nThe principle of extensionality of predicates asserts that\ntwo predicates $P$ and $Q$ on a type $X$ are equal given that\n$\\forall (x : X),\\ P(x) \\leftrightarrow Q(x)$.\n\nThis principle cannot be *proved*. It is something we accept as\nan axiom.\n", "\nThe `ext` (short for 'extensionality') tactic is used to prove\ntwo mathematical objects are extensionally equal. This is typically\nused for sets, functions, and predicates.\n\n## Example\nSuppose `P` and `Q` are predicates on a type `B`. If the target is\nto prove `P = Q`, then using `ext b` changes the target to one of proving\n`P(b) \u2194 Q(b)`.\n", "Below, we give a Lean proof of the statement above. Initially,\nthe target is to show equality of the predicates `P` and `Q`\n(defined as above).\n\nBy using the `ext` tactic, the target is changed to one of proving\n`(x < 5) \u2194 (2 * x < 10)`, for a newly introduced variable `x : \u2115`.\n", "namespace exlean -- hide\n", "namespace pred_ext1 -- hide\n", "def P(m : \u2115) := m < 5\ndef Q(n : \u2115) := 2 * n < 10\n", "\n", "example :\nP = Q :=\nbegin\n  ext x,\n  show (x < 5) \u2194 (2 * x < 10),\n  split,\n  { assume h : x < 5,\n    show 2 * x < 10, linarith, },\n  { assume h : 2 * x < 10,\n    show x < 5, linarith,  },\nend\n", "end pred_ext1 -- hide\n", "For a more interesting example, let $f : \\mathbb Z \u2192 \\mathbb Z$ be \na function and let $P$ and $Q$ be predicates on $\\mathbb Z$ defined\nby $P(m) := f(m) = 5$ and $Q(n) := 2 = f(n) - 3$. We'll show $P = Q$.\n", "namespace pred_ext2 -- hide\n", "constant f : \u2124 \u2192 \u2124\ndef P(m : \u2124) := f(m) = 5\ndef Q(n : \u2124) := 2 = f(n) - 3\n", "\n", "example : P = Q :=\nbegin\n  ext x,\n  show (f(x) = 5) \u2194 (2 = f(x) - 3),\n  split,\n  { assume h : f(x) = 5,\n    show 2 = f(x) - 3, linarith, },\n  { assume h : 2 = f(x) - 3,\n    show f(x) = 5, linarith,  },\nend\n", "end pred_ext2 -- hide\n", "Extensionality of predicates will feature heavily later in this\ngame when we explore equality of sets.\n\n", "## Tasks\n\nHere, you are given a function $f : \\mathbb N \\to \\mathbb N$ and\nthree predicates on $\\mathbb N$,\n* $P(m) := f(m) = 6$,\n* $Q(n) := f(3n) = 18$, and\n* $R(k) := 3f(k) = 18$.\n\nYou are asked to prove $(P = Q) \\lor (P = R)$.\n", "You should first determine whether you think `P = Q` is true of\n`P = R` is true. Then either use the `left` tactic or the\n`right` tactic, respectively.\n", "Starting the proof", "namespace pred_ext3 -- hide\n", "constant f : \u2115 \u2192 \u2115\ndef P(m : \u2115) := f(m) = 6\ndef Q(n : \u2115) := f(3 * n) = 18\ndef R(k : \u2115) := 3 * f(k) = 18\n", "$(P = Q) \\lor (P = R)$.\n", "end pred_ext3 -- hide\n", "end exlean -- hide", "import tactic.modded predicate_logic.pred_extensionality -- hide\n", "# Predicate logic\n## Level 9: Even integers\n\nAs a practical example, define the predicate\n$\\mathsf{even}$ on $\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists (m : \\mathbb Z),\\ n = 2m$.\n\nTo prove $\\mathsf{even}(10)$ is to prove $\\exists (m : \\mathbb Z),\\ 10 = 2m$.\n\n**Proof**: take $m$ to be $5$. Then indeed $10 = 2 \\times 5$.\n", "Here is a Lean definition of the `even` predicate.\n", "namespace exlean -- hide\n", "def even (n : \u2124) := \u2203 (m : \u2124), n = 2 * m\n", "In the Lean proof below, I use the slightly odd construction\n`(10 : \u2124) = 2 * 5` rather than `10 = 2 * 5`. This is to ensure\nLean inteprets the quantities as integers rather than as\nnatural numbers.\n", "example : even(10) :=\nbegin\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n", "**Theorem**: for all integers $n$, if $n$ is even, then $4n$ is even.\n\nMore formally, we are to prove\n$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(4n)$.\n\n**Proof**: Assume $n : \\mathbb Z$. Assume $h : \\mathsf{even}(n)$.\nThat is, $h : \\exists (m : \\mathbb Z),\\ n = 2m$.\nDecomposing this we have $x : \\mathbb Z$ for which $h_2 : n = 2x$.\nWe must show $\\mathsf{even}(4n)$. That is, $\\exists (m : \\mathbb Z),\\ 4n = 2m$.\nTake $m$ to be $4x$. We must show $4n = 2(4x)$.\nBy $h_2$, we must show $4(2x) = 2(4x)$. This holds by arithmetic.\n", "example : \u2200 (n : \u2124), even(n) \u2192 even(4 * n) :=\nbegin\n  assume n : \u2124,\n  assume h : even(n),\n  given h : \u2203 (m : \u2124), n = 2 * m,\n  cases h with x h\u2082,\n  given h\u2082 : n = 2 * x,\n  show \u2203 (m : \u2124), 4 * n = 2 * m, \n  use 4 * x,\n  rw h\u2082,\n  show 4 * (2 * x) = 2 * (4 * x), linarith,\nend\n", "## Task\n\nProve the result below in Lean, adapting the proof above.\n", "$\\forall (n : \\mathbb Z),\\ \\mathsf{even}(n) \\to \\mathsf{even}(n ^ 2)$.\n", "end exlean -- hide", "import predicate_logic.even1 -- hide\n", "# Predicate logic\n## Level 10: Multiple quantifiers 1\n\nMany statements in mathematics involve more than one quantifier.\nThe commutitivity of addition of natural numbers can be stated\nas\n$\\forall (m : \\mathbb N),\\ \\forall (n : \\mathbb N),\\ m + n = n + m$.\n", "Statements such as this are to be read from left-to-right.\nIf we let $P$ be the predicate on $\\mathbb N$ given by\n$P(m) := \\forall (n : \\mathbb N),\\ m + n = n + m$, then\nthe above statement can be shortened to\n$\\forall (m : \\mathbb N),\\ P(m)$.\n\n", "**Theorem**: Let $P$ and $Q$ be predicates on a type $X$. Suppose\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\nThen $\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$.\n\n**Proof**: Assume $m : X$ and $n : X$.\nWe have $h_2 : P(m) \\land Q(n)$ by $h$ specialised at $m$ and $n$.\nWe must show $Q(n) \\land P(m)$. By commutativity of $\\land$, this\nis the same as proving $P(m) \\land Q(n)$, which follows from $h_2$. \u220e\n\n", "variable (X : Type)\nexample (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  assume (m n : X),\n  have h\u2082 : (P m) \u2227 (Q n), from h m n,\n  show Q(n) \u2227 P(m),\n  rw and_comm,\n  show P(m) \u2227 Q(n), from h\u2082,\nend\n", "The proof above uses for all introduction and for all elimination.\nA more natural proof uses propositional extensionality to rewrite\nthe commutativity of $\\land$ through the universal quantifier.\n\nAgain, we'll prove that\n$\\forall (m : X), \\forall (n : X),\\ Q(n) \\land P(m)$ follows from\n$h : \\forall (x : X), \\forall (y : X),\\ P(x) \\land Q(y)$.\n\n**Proof**: By commutativity of $\\land$, it suffices to prove\n$\\forall (m : X), \\forall (n : X),\\ P(m) \\land Q(m)$. This follows\nfrom $h$. \u220e\n\nIn Lean, we use the `simp` tactic to rewrite through\nquantifiers, as below.\n", "example (P Q : X \u2192 Prop)\n(h : \u2200 (x : X), \u2200 (y : X), P(x) \u2227 Q(y)) :\n\u2200 (m : X), \u2200 (n : X), Q(n) \u2227 P(m) :=\nbegin\n  simp [and_comm],\n  show \u2200 (m : X), \u2200 (n : X), P(m) \u2227 Q(n), from h,\nend\n", "namespace exlean -- hide\n", "## Tasks\n1. Prove the result below in the style of the first proof above.\n2. Prove the result below using `simp` to rewrite through\nthe quantifiers.\n\n", "Suppose $P$ and $Q$ are predicates on a type $X$. \nSuppose $h : \\forall (x : X),\\ \\forall (y : X),\\ P(x) \\lor Q(y)$.\nThen $\\forall (m : X),\\ \\forall (n : X),\\ Q(n) \\lor P(m)$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers1 -- hide\n", "# Predicate logic\n## Level 11: Multiple quantifiers 2\n\n", "**Theorem**: $\\forall (x : \\mathbb Z), \\exists (y : \\mathbb Z),\\ x = y + 5$.\n\n**Proof**: Assume $x : \\mathbb Z$. Take $y$ to be $x - 5$.\nIt remains to show $x = (x - 5) + 5$, but this holds by arithmetic. \u220e\n\nThe handwritten proof above translates easily to a Lean proof.\n", "example : \u2200 (x : \u2124), \u2203 (y : \u2124), x = y + 5 :=\nbegin\n  assume x : \u2124,\n  use (x - 5),\n  show x = (x - 5) + 5, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "Show that\n$\n\\forall (m : \\mathbb Z),\\ \\exists (n : \\mathbb Z),\\ m n + n - 1 = m (m + 2)\n$\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers2 -- hide\n", "# Predicate logic\n## Level 12: Multiple quantifiers 3\n\n", "**Theorem**: $\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x^2 + 3xy + 66 = 4 y ^2$.\n\nFor the proof below, it isn't relevant *how* you find $x$ and $y$\nsuch that the above equation is satisfied. \n", "\nThough it's not relevant at this stage of your mathematical journey,\none way to find solutions to this equation is to treat the\nequation as a quadratic in $x$ and to solve for $x$ in terms of $y$.\nAs we are looking for natural number solutions, we require the\ndiscriminant of the equation to be a perfect square. In this case,\nthat means you need $25y^2 - 264 = m^2$, for some integer $m$.\nThere are only finitely many solutions to this equation amongst\nthe integers.\n", "But how do I find the solutions?", "\n**Proof**: Take $x$ to be $2$. Take $y$ to be $5$. We must\nshow $2^2 + 3 \\times 2 \\times 4 + 66 = 4 \\times 5 ^2 $.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n", "example :\n\u2203 (x : \u2115), \u2203 (y : \u2115), x ^ 2 + 3 * x * y + 66 = 4 * y ^ 2 :=\nbegin\n  use 2,\n  use 5,\n  show 2 ^ 2 + 3 * 2 * 5 + 66 = 4 * 5 ^ 2, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. In this case, there are infinitely many\nsolutions for $x$ and $y$. You just need to find one solution.\n\n", "Show that\n$\\exists (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\\n x  y + 21 = 7  x + 3  y$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers3 -- hide\n", "# Predicate logic\n## Level 13: Multiple quantifiers 4\n\n", "**Theorem**: $\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n x + y = y$.\n\n**Proof**: Take $x$ to be $0$. We must show\n$\\forall (y : \\mathbb Z),\\ 0 + y = y$.\nAssume $y : \\mathbb Z$. We must show $0 + y = y$.\nBut this holds by arithmetic. \u220e\n\nBelow is a Lean proof of this result.\n", "example : \u2203 (x : \u2124), \u2200 (y : \u2124), x + y = y :=\nbegin\n  use 0,\n  assume y : \u2124,\n  show 0 + y = y, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "Show that\n$\\exists (x : \\mathbb Z),\\ \\forall (y : \\mathbb Z),\\\n (y - 1)^2 = y^2 - xy + 1$.\n", "end exlean -- hide", "import tactic.modded predicate_logic.multiple_quantifiers4 -- hide\n", "# Predicate logic\n## Level 14: Even integers 2\n\n", "## Task\n\nProve the result below in Lean.\n", "namespace exlean -- hide\n", "$\\exists (a : \\mathbb Z),\\ \\forall (b : \\mathbb Z),\\ \\mathsf{even}(ab)$.\n", "end exlean -- hide", "import predicate_logic.multiple_quantifiers4 -- hide\n", "# Predicate logic\n## Level 15: Negating quantifiers 1\n\n", "As we'll soon see, the proposition $\\neg (\\forall (x : X),\\ P(x))$\nis equal (materially equivalent to) the proposition\n$\\exists (x : X),\\ \\neg P(x)$.\n\nLikewise, the proposition $\\neg (\\exists (x : X),\\ P(x))$ is equal\nto the proposition $\\forall (x : X),\\ \\neg P(x)$.\n\n**Theorem**: Prove that $\\neg (\\forall (x : \\mathbb N),\\ x + 2 = 5)$.\n\nIn words, we'll prove it's not the case that for every natural\nnumber $x$, $x + 2 = 5$.\n\n**Proof**: We must show $\\exists (x : \\mathbb N),\\ \\neg(x + 2 = 5)$.\nThat is, to show $\\exists (x : \\mathbb N),\\ x + 2 \\ne 5$.\n\nTake $x$ to be $0$. We must show $0 + 2 \\ne 5$. This holds by\narithmetic. \u220e\n", "In the Lean proof below, `push_neg` is the tactic that converts the\nnegation of a universally quantified statement into an \nexistentially quantified statement.\n\nThe symbol `\u2260` is typed `\\ne`.\n", "\nThe `push_neg` tactic 'pushes' negations inside\nquantifiers. For example, it changes a target `\u2200 (x : X), P(x)`\ninto `\u2203 (x : X), \u00acP(x)`. If `P(x)` is itself a quantified\nstatement, then `push_neg` will recursively push the negation\ninto `P(x)`.\n\nThus, `push_neg` converts `\u00ac(\u2200 (x : X), \u2203 (y : Y), P x y)` into\n`\u2203 (x : X), \u2200 (y : Y), \u00ac(P x y)`.\n", "example : \u00ac(\u2200 (x : \u2115), x + 2 = 5) :=\nbegin\n  push_neg,\n  show \u2203 (x : \u2115), x + 2 \u2260 5,\n  use 0,\n  show 0 + 2 \u2260 5, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n", "$\\neg(\\forall (x : \\mathbb N),\\ x ^ 2 + 2  x = 3  x)$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers -- hide\n", "# Predicate logic\n## Level 16: Negating quantifiers 2\n\n", "\n**Theorem**: Prove that $\\neg (\\exists (x : \\mathbb N),\\ x + 2 = 0)$.\n\nIn words, we'll prove it's not the case that there exists a natural\nnumber $x$ such that $x + 2 = 0$.\n\n**Proof**: We must show $\\forall (x : \\mathbb N),\\ x + 2 \\ne 0$.\nAssume $x : \\mathbb N$. We must show $x + 2 \\ne 0$. \nThis holds by arithmetic. \u220e\n", "example : \u00ac(\u2203 (x : \u2115), x + 2 = 0) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), x + 2 \u2260 0,\n  assume x : \u2115,\n  show x + 2 \u2260 0, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. Remember that `\u2260` is typed as `\\ne`.\n\n", "$\\neg (\\exists (x : \\mathbb N),\\ 2x = 4x + 1)$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers2 -- hide\n", "# Predicate logic\n## Level 17: Negating quantifiers 3\n\n", "\n**Theorem**: Prove that\n$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ xy = x + y)$.\n\nIn proving this theorem, we need to push the negation through two\nquantifiers. After pushing the negation through the existential quantifier,\nthe target is to prove\n$\n\\forall (x : \\mathbb N),\\ \\neg(\\forall (y : \\mathbb N),\\ xy = x + y).\n$\n\nWe then push the negation through the inner quantifier, making the\ntarget\n$\n\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y).\n$\n\n**Proof**: We must show\n$\\forall (x : \\mathbb N),\\ \\exists (y : \\mathbb N),\\ xy \\ne x + y$.\nAssume $x : \\mathbb N$. We must show\n$\\exists (y : \\mathbb N),\\ xy \\ne x + y$. Take $y$ to be $1$. We\nmust show $x\\times 1 \u2260 x + 1$. This holds by arithmetic. \u220e\n", "example : \u00ac(\u2203 (x : \u2115), \u2200 (y : \u2115), x * y = x + y) :=\nbegin\n  push_neg,\n  show \u2200 (x : \u2115), \u2203 (y : \u2115), x * y \u2260 x + y,\n  assume x : \u2115,\n  show \u2203 (y : \u2115), x * y \u2260 x + y,\n  use 1,\n  show x * 1 \u2260 x + 1, linarith,\nend\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below.\n\n", "$\\neg (\\exists (x : \\mathbb N),\\ \\forall (y : \\mathbb N),\\ 3xy = xy^2 + y)$.\n", "end exlean -- hide", "import tactic.no_push_neg --hide\n", "# Predicate logic\n## Level 18: Negating quantifiers theorem 1\n\nThe next few levels are for the experts. We'll prove the equivalences\n* $\\neg (\\forall (x : X),\\ P(x)) \\leftrightarrow \\exists (x : X),\\ \\neg P(x)$ and\n* $\\neg (\\exists (x : X),\\ P(x)) \\leftrightarrow \\forall (x : X),\\ \\neg P(x)$.\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n", "Recall that if `h\u2081 : p` and `h\u2082 : \u00acp`, then `h\u2082 h\u2081` is a proof of\n`false`.\n\nAlternatively, remember that `absurd h\u2081 h\u2082` gives a proof of anything.\n", "Proving `false`", "variable (X : Type) -- hide\n", "$(\\forall (x : X),\\ \\neg P(x)) \\to \\neg(\\exists (x : X),\\ P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm1 --hide\n", "# Predicate logic\n## Level 19: Negating quantifiers theorem 2\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\n\n", "\nSuppose the context contains `h : \u00acp`, for some proposition `p`.\nSuppose also that the target is to prove `false`.\nAs `h : p \u2192 false`, it suffice to prove `p` and then use\nimplication elimination.\n\nRecall that Lean permits an (easier?) backward version of\nimplication elimination. By typing `apply h`, you change the\ntarget to one of proving `p`.\n", "Using negated hypotheses", "variable (X : Type) -- hide\n", "$\\neg(\\exists (x : X),\\ P(x)) \\to (\\forall (x : X),\\ \\neg P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm2 -- hide\n", "# Predicate logic\n## Level 20: Negating quantifiers theorem 3\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` in this level.\n\n", "\nAt some point in your proof, you will have introduced an\nexistentially-quantified statement into the context.\nRemember that you can decompose such a statement using the `cases`\ntactic.\n", "Dealing with the existentially-quantified statement", "variable (X : Type) -- hide\n", "$\\exists (x : X),\\ \\neg P(x) \\to \\neg(\\forall (x : X),\\ P(x))$.\n", "end exlean -- hide", "import predicate_logic.negating_quantifiers_thm3 tactic.localized --hide\n", "# Predicate logic\n## Level 21: Negating quantifiers theorem 4\n\n", "namespace exlean -- hide\n", "## Tasks\nProve the result below. You cannot use `push_neg` for this level.\nThis level is somewhat challenging!\n\n", "\nAfter doing the natural first step when proving an implication, I\nsuggest doing a proof by contradiction using `by_contra h\u2082`.\nDo the obvious things until you get stuck. At some point, you'll\nneed to use contradiction again.\n", "The structure of the proof.", "variable (X : Type) -- hide\n", "open_locale classical -- hide\n", "$\\neg(\\forall (x : X),\\ P(x)) \\to \\exists (x : X),\\ \\neg P(x)$.\n", "end exlean -- hide", "Sets", "import tactic.modded  tactic.linarith -- hide\n", "# Sets\n## Level 1: Set membership\n\nA set on a type $X$ is simply a predicate on that type.\n\nLet's define predicates $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nThen $\\mathsf{even}$ and $\\mathsf{even}'$ can be seen as sets\nof elements of type $\\mathbb Z$.\n\nWe write $10 \\in \\mathsf{even}$ (for instance) as a synonym for\n$\\mathsf{even}(10)$. More generally, $x \\in P$ is a synonym for\n$P(x)$ (given that $P$ is a predicate on a type $X$ and that $x : X$).\n\nHere's a proof of $10 \\in \\mathsf{even}$.\n\n**Proof**: We must show $\\mathsf{even}(10)$, namely that\n$\\exists(m : \\mathbb Z),\\ 10 = 2m$. Take $m$ to be $5$. Then\n$10 = 2 \\times 5$ follows by arithmetic.\n", "In Lean, we define sets much as we define predicates. The only\ndifference between the following defintion and the definition of\na predicate is the use of `set \u2124` in place of `\u2124 \u2192 Prop`.\n", "namespace exlean -- hide\n", "namespace even_sets -- hide\n", "def even : set \u2124 := \u03bb n, \u2203 (m : \u2124), n = 2 * m\n", "-- hide\n", "def even' : set \u2124 := \u03bb n, \u2203 (m : \u2124), n + 4 = 2 * m\n", "In Lean, `\u2208` is typed `\\in`. Here is a Lean proof that `10 \u2208 even`.\nNote that I have to type `(10 : \u2124)` so Lean knows I'm working with the\ninteger `10` rather than the natural number `10`.\n", "example : (10 : \u2124) \u2208 even :=\nbegin\n  show \u2203 (m : \u2124), 10 = 2 * m,\n  use 5,\n  show (10 : \u2124) = 2 * 5, linarith,\nend\n", "## Task\nProve that $10 \\in \\mathsf{even}'$, with $\\mathsf{even}'$ defined\nas above.\n", "$10 \\in \\mathsf{even}'$.\n", "end even_sets -- hide\n", "end exlean -- hide", "import sets.set_membership -- hide\n", "# Sets\n## Level 2: Equality of sets\n\nFrom the previous level, recall the definitions of the \nsets $\\mathsf{even}$ and $\\mathsf{even}'$ on\n$\\mathbb Z$ by\n$\\mathsf{even}(n) := \\exists(m : \\mathbb Z),\\ n = 2 m$ and\n$\\mathsf{even}'(n) := \\exists(m : \\mathbb Z),\\ n + 4 = 2 m$.\n\nRecall that for two predicates $P$ and $Q$ on a type $X$ to be\nequal means that $\\forall(x : X),\\ P(x) \\leftrightarrow Q(x)$.\nThis is the principle of extensionality of predicates.\n\nViewed as sets, $P = Q$ means\n$\\forall(x : X),\\ x \\in P \\leftrightarrow x \\in Q$.\n\nI claim that $\\mathsf{even} = \\mathsf{even}'$.\n\nHere's a sketch proof of the result.\n\n**Proof**:\nBy extensionality, we must show\n$\n\\forall (x : \\mathbb Z),\\ x \\in \\mathsf{even} \\leftrightarrow x \\in \\mathsf{even}'.$\n\nAssume $x : \\mathbb Z$. It suffices to show\n$x \\in \\mathsf{even} \\to x \\in \\mathsf{even}'$ and\n$x \\in \\mathsf{even}' \\to x \\in \\mathsf{even}$.\n\nFor the first of these, assume $h : x \\in \\mathsf{even}$.\nThen we have $k : \\mathbb Z$ such that $h_2 : x = 2 k$.\nWe must show $x \\in \\mathsf{even}'$. That is, that\n$\\exists(m : \\mathbb Z),\\ x + 4 = 2m$. Takes $m$ to be $k + 2$.\nWe must show $x + 4 = 2(k + 2)$. This holds by arithmetic.\n\nThe remaining part of the proof is left to the reader.\n", "namespace exlean -- hide\n", "namespace even_sets -- hide\n", "## Task\nBelow, I have given one direction of the proof that `even = even'`.\nIn particular, I have proved `even x \u2192 even' x` (for a given `x : \u2124`).\nYour task is to replace `sorry` with a proof that `even' x \u2192 even x`.\n", "$\\mathsf{even} = \\mathsf{even}'$.\n", "end even_sets -- hide\n", "end exlean -- hide", "import sets.even_even -- hide\n", "# Sets\n## Level 3: Set constructor notation\n\nLet $S$ be a predicate on a type $X$. Thus $S$ can be viewed\nas a set of elements of type $X$. It is common to represent the\nset $S$ via the 'set constructor' notation as\n$\\\\{x : X \\mid S(x)\\\\}$. \n\nHere, for example, is an definition, using set constructor notation,\nof the set of even integers.\n$T := \\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n = 2m \\\\}$.\n", "namespace exlean -- hide\n", "Let's show that $6 \\in T$.\n\n**Proof**: by definition, we must show $\\exists (m : \\mathbb Z),\\\n6 = 2m$. Take $m$ to be $3$. We show $2 = 2 \\times 3$ by \narithmetic. \u220e\n", "Below is the proof of this result in Lean. Note the use\nof `(6 : \u2124)` to let Lean know we're working with the integer `6`\nand not the natural number `6`.\n", "example : (6 : \u2124) \u2208 {n : \u2124 | \u2203 (m : \u2124), n = 2 * m} :=\nbegin\n  show \u2203 (m : \u2124), 6 = 2 * m,\n  use 3,\n  show (6 : \u2124) = 2 * 3, linarith,\nend\n", "## Task\nAdapt the proof above to show that the integer $7$ belongs to the set\n$\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n", "$7\\in\\\\{n : \\mathbb Z \\mid \\exists(m : \\mathbb Z),\\ n + 1 = 2m + 4\\\\}$.\n", "end exlean -- hide", "import sets.set_constructor  -- hide\n", "# Sets\n## Level 4: Finite sets\n\nThe set of natural numbers represented by $\\\\{1, 3, 7\\\\}$\nis the predicate $S$ on $\\mathbb N$ given by\n$S(x) := (x = 1) \\lor (x = 3) \\lor (x = 7)$.\n\nLikewise, the set $\\\\{3, 7, 3, 1\\\\}$ is the predicate $T$ on\n$\\mathbb N$ given by\n$T(x) := (x = 3) \\lor (x = 7) \\lor (x = 3) \\lor (x = 1)$.\n\nClearly, $\\forall(x : X),\\ x \\in S \\leftrightarrow x \\in T$. Thus,\n$S$ and $T$ are equal. \n", "namespace exlean -- hide\n", "In Lean, we use `finset` to define finite sets.\n", "namespace finset_test1 -- hide\n", "def S : finset \u2115 := {1, 3, 7}\n", "-- hide\n", "def T : finset \u2115 := {3, 7, 3, 1}\n", "Results that can be proved trivially by applying an algorithm (decidability) are proved in Lean\nusing `dec_trivial`. We can prove `S = T` using `dec_trivial`.\n", "If Lean knows that a given statement is 'decidable' (that is, it is given an algorithm for\ndetermining whether the statement is true or false), then `dec_trivial` can be used to prove the\ntheorem.\n", "example : S = T :=\nbegin\n  dec_trivial,\nend\n", "end finset_test1  -- hide\n", "## Task\nProve that two of the sets below are equal.\n", "namespace finset_test2 -- hide\n", "def S : finset \u2115 := {3, 2, 3, 5}\n", "-- hide\n", "def T : finset \u2115 := {2, 5, 1, 3}\n", "-- hide\n", "def U : finset \u2115 := {2, 5, 3, 5}\n", "$((S = T) \\lor (S = U)) \\lor (T = U)$.\n", "end finset_test2 -- hide\n", "end exlean -- hide", "import sets.finite_sets  -- hide\n", "# Sets\n## Level 5: The size of finite sets\n\nLet $S$ be a set on a type $X$. For a natural number $n$ to be the *size* of\n$S$ means that $n$ is the smallest natural number for which $S$ can be\nexpressed as $\\\\{a_1, \\dots, a_n\\\\}$. We write $|S|$ for the size of $S$. \n\nFor example, the size of the set $\\\\{1, 3, 4, 3, 1\\\\}$ of integers is $3$\nas the set can be expressed as $\\\\{1, 3, 4\\\\}$ but as no smaller set.\n\nIn Lean, the size (more formally called the *cardinality*) of a finite set `S`\nis denoted by `card S`.\n", "namespace exlean -- hide\n", "Equations involving cardinalities of sets can be proved trivially by\ndecidability, as below.\n", "namespace finset_test3 -- hide\n", "def S : finset \u2115 := {1, 3, 7}\n", "-- hide\n", "open finset -- hide\n", "example : \u2203 (m : \u2115), card S = m :=\nbegin\n  use 3,\n  dec_trivial,\nend\n", "end finset_test3  -- hide\n", "## Task\nFind the cardinality of the given set.\n", "namespace finset_test4 -- hide\n", "open finset -- hide\n", "def S : finset \u2115 := {3, 2, 3, 5, 1, 2, 7, 5}\n", "Given $S = \\\\{3, 2, 3, 5, 1, 2, 7, 5\\\\}$,\n$\\exists (m : \\mathbb N),\\ |S| = m$.\n", "end finset_test4 -- hide\n", "end exlean -- hide", "import sets.finite_sets_cardinality  -- hide\n", "# Sets\n## Level 6: The empty set\n\nGiven a type $X$, the empty set on $X$, denoted $\\varnothing$, is the set\ndefined so that $x \\in \\varnothing$ means $\\bot$.\n\nEqually, $\\varnothing$ can be viewed as the predicate $\\varnothing : X \\to \\mathsf{Prop}$\ndefined by $\\varnothing(x) := \\bot$.\n", "namespace exlean -- hide\n", "This definition gives rise to the interesting fact that, for any predicate $P$, the proposition\n$P(x)$ is *always* true on the assumption that $x \\in \\varnothing$.\n\n**Theorem**: Let $X$ be a type and let $P$ be a predicate on $X$. Then\n$\\forall (x : X),\\ x \\in \\varnothing \\to P(x)$.\n\n**Proof**: Assume $x : X$. Assume $h : x \\in \\varnothing$. But this just means\n$h : \\bot$. From false elimination on $h$, we show $P(x)$. \u220e\n", "Below is a Lean proof of the result. In Lean, we must specify the type of the empty set.\nHere, we are concerned with `\u2205 : set X`, the empty set of elements of type `X`.\n\nThe symbol `\u2205` is typed `\\empty`.\n", "variables {X : Type*} {P : X \u2192 Prop} -- hide\n", "\u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x)\n", "lemma vacuous_truth : \u2200 (x : X), x \u2208 (\u2205 : set X) \u2192 P(x) :=\nbegin\n  assume x : X,\n  assume h : x \u2208 \u2205,\n  given h : false,\n  from false.elim h,\nend\n", "namespace empty_set1 -- hide\n", "As another example, let $S$ be the set of natural numbers defined by\n$S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$. We'll show that $S = \\varnothing$.\n\n**Proof**: We must show (by extensionality), that given $n : \\mathbb N$,\n$n \\in S \\leftrightarrow n \\in \\varnothing$.\n\nThat is, we must show both $n \\in S \\to n \\in \\varnothing$ and\n$n \\in \\varnothing \\to n\\in S$.\n\n1. Assume $h : n \\in S$. That is, $h : n < 0$. This gives false, by arithmetic.\n2. Assume $h : n \\in \\varnothing$. That is, $h : \\bot$.\nWe show $n \\in S$ by false elimination on $h$. \u220e\n", "This can be proved in Lean as follows.\n", "def S : set \u2115 := {n : \u2115 | n < 0}   \n", "-- hide\n", "lemma empty_S : S = \u2205 :=\nbegin\n  ext n,\n  show n \u2208 S \u2194 n \u2208 \u2205, \n  split,\n  { show n \u2208 S \u2192 n \u2208 \u2205,\n    assume h : n \u2208 S,\n    given h : n < 0,\n    show false, linarith, },\n  { show n \u2208 \u2205 \u2192 n \u2208 S,\n    assume h : n \u2208 \u2205,\n    given h : false,\n    show n \u2208 S, from false.elim h, },\nend\n", "## Task\nSuppose $S$ is the set of natural numbers given by $S := \\\\{ n : \\mathbb N \\mid n < 0 \\\\}$.\nUsing the two theorems given above, prove \n$\\forall (x : \\mathbb N),\\ x \\in S \\to x = 5$.\n", "\nA good starting point is to rewrite the theorem statement using one of the results given\nin this level.\n\nYou should be able to complete the proof using one more line.\n", "Starting the proof", "$\\forall (x : \\mathbb N)\\, x \\in S \\to x = 5$.\n", "end empty_set1 -- hide\n", "end exlean -- hide", "import sets.empty_set  -- hide\n", "# Sets\n## Level 7 : Subsets\n\nLet $S$ and $T$ be sets on a type $X$. For $S$ to be a subset of $T$,\nwritten $S \\subseteq T$, means\n$\\forall (x : X),\\ x \\in S \\to x \\in T$.\n\nThis is abbreviated to $\\forall x \\in S,\\ x \\in T$.\n", "namespace exlean -- hide\n", "**Theorem** [Reflexivity of subset]:\nLet $X$ be a type and let $S$ be a set on $X$. Then $S \\subseteq S$.\n\n**Proof**: We must show $\\forall (x : X),\\ x \\in S \\to x \\in S$.\nAssume $x : X$. Assume $h : x \\in S$. We show $x \\in S$, from $h$. \u220e\n", "In Lean, we write `\u2286` as `\\sub`. Below, we prove reflexivity of `\u2286` in Lean.\n", "variable {X : Type*} -- hide\n", "S \u2286 S\n", "lemma subset_rfl {S : set X} : S \u2286 S :=\nbegin\n  show \u2200 x \u2208 S, x \u2208 S,\n  assume x : X,\n  assume h : x \u2208 S,\n  show x \u2208 S, from h,\nend\n", "Above we *proved* a subset result. Let's now *use* subset assumptions to prove\nanother result. The result we're interested in is 'antisymmetry' of the subset relation.\nThat is, on the assumptions that $h_1 : S \\subseteq T$ and $h_2 : T \\subseteq S$, we'll prove $S = T$.\n\n**Proof**: We must show $S = T$. That is, we must show $x \\in S \\leftrightarrow x \\in T$\n(given $x : X$). This requires proving each direction of the double implication.\n\n1. We'll show $x \\in S \\to x \\in T$. Assume $h : x \\in S$. We show $x \\in T$ from $h_1$ and $h$.\n2. We'll show $x \\in T \\to x \\in S$. Assume $h : x \\in T$. We show $x \\in S$ from $h_2$ and $h$.\n\u220e\n\nIn the proof above, our 'from $h_1 : S \\subseteq T$ and $h : x \\in S$ is a combination of\nfor all elimination and implication elimination. The same idiom is accessible in the Lean proof below.\n", "S = T \n", "theorem subset_antisymm {S T : set X} (h\u2081 : S \u2286 T) (h\u2082 : T \u2286 S) : S = T :=\nbegin\n  ext x,\n  show x \u2208 S \u2194 x \u2208 T,\n  split,\n  { show x \u2208 S \u2192 x \u2208 T,\n    assume h : x \u2208 S,\n    show x \u2208 T, from h\u2081 h, },\n  { show x \u2208 T \u2192 x \u2208 S,\n    assume h : x \u2208 T,\n    show x \u2208 S, from h\u2082 h, }\nend\n", "## Task\nProve the transitivity of $\\subseteq$. That is, given sets $S$, $T$, and $U$\non a type $X$, prove that if $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n\nYou may draw inspiration from parts of the proof of antisymmetry.\n", "Given sets $S$, $T$, and $U$\non a type $X$, one has $S \\subseteq T$ and $T \\subseteq U$, then $S \\subseteq U$.\n", "end exlean -- hide", "import sets.subset -- hide\n", "# Sets\n## Level 8 : Intersection and Union\n\n### Intersection\n\nLet $S$ and $T$ be sets on a type $X$. The *intersection* of $S$ and $T$, written $S \\cap T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\in T) \\\\}$.\n", "namespace exlean -- hide\n", "**Theorem** [Commutativity of intersection]:\nLet $X$ be a type and let $S$ and $T$ be sets on $X$. Then $S \\cap T = T \\cap S$.\n\n**Proof**: We must show $x \\in S \\cap T \\leftrightarrow x \\in T \\cap S$, given $x : X$.\nWe prove this by calculation.\n\\begin{align}\nx \\in S \\cap T  &\\leftrightarrow (x \\in S) \\land  (x \\in T) & & \\text{[by definition]} \\\\\\\\\n&\\leftrightarrow (x \\in T) \\land  (x \\in S)& &\\text{[by logic]} \\\\\\\\\n&\\leftrightarrow  x \\in T \\cap S.  & &\\text{[by definition]}\n\\end{align} \u220e\n", "In Lean, we write `\u2229` as `\\i`. Below, we prove commutativity of `\u2229`. \nWe use the Lean tactic `tauto!`, which proves any result in propositional logic.\n", "Proves any result in propositional logic.\n", "variable {X : Type*} -- hide\n", "lemma inter_comm (S T : set X) : S \u2229 T = T \u2229 S :=\nbegin\n  ext x,\n  show x \u2208 S \u2229 T \u2194 x \u2208 T \u2229 S,\n  calc x \u2208 S \u2229 T \u2194 (x \u2208 S) \u2227 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2227 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u2229 S           : by refl\nend\n", "### Union\n\nLet $S$ and $T$ be sets on a type $X$. The *union* of $S$ and $T$, written $S \\cup T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\lor (x \\in T) \\\\}$.\n", "In Lean, we write `\u222a` as `\\un`. Below is a Lean proof of the commutativity of union.\n", "lemma union_comm (S T : set X) : S \u222a T = T \u222a S :=\nbegin\n  ext x,\n  show x \u2208 S \u222a T \u2194 x \u2208 T \u222a S,\n  calc\n  x \u2208 S \u222a T \u2194 (x \u2208 S) \u2228 (x \u2208 T)    : by refl\n    ... \u2194  (x \u2208 T) \u2228 (x \u2208 S)  : by tauto!\n    ... \u2194 x \u2208 T \u222a S           : by refl\nend\n", "## Task\nProve the left distributivity of intersection over union. That is, given sets $S$, $T$, $U$\nof a type $X$, prove $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n\nTry a 'proof by calculation', as above. You should need only three calculation lines.\n", "Given sets $S$, $T$, and $U$\non a type $X$, one has  $S \\cap (T \\cup U) = (S \\cap T) \\cup (S \\cap U)$.\n", "end exlean -- hide", "import sets.intersection_union -- hide\n", "# Sets\n## Level 9 : Union and subset\n\nIn this level, we'll see that $S \\subseteq S \\cup T$ and\n$T \\subseteq S \\subset T$.\n", "namespace exlean -- hide\n", "variables {X : Type*} {S T : set X} -- hide\n", "We begin with a Lean proof of $S \\subseteq S \\cup T$.\n", "S \u2286 S \u222a T\n", "lemma subset_union_left : S \u2286 S \u222a T :=\nbegin\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2208 S \u222a T,\n  assume x : X,\n  assume h : x \u2208 S,\n  show (x \u2208 S) \u2228 (x \u2208 T), from or.inl h,\nend\n", "## Task\nShow that $T \\subseteq S \\cup T$. Do this in two different ways.\n\n1. Prove $T \\subseteq S \\cup T$ by adapting the proof above.\n2. Give a backward proof of $T \\subseteq S \\cup T$ as follows: first\nrewrite with commutativity of union; then use the result above.\n", "Given sets $S$ and $T$, one has $T \\subseteq S \\cup T$.\n", "end exlean -- hide", "import sets.subset_union -- hide\n", "# Sets\n## Level 10 : Intersections and subsets\n", "namespace exlean -- hide\n", "**Theorem**:\nLet $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$.\n\n**Sketch proof**: We must show both directions of the double implication.\n\n1. We'll show $U \\subseteq (S \\cap T) \\to (U \\subseteq S) \\land (U \\subseteq T)$\nAssume $h : U \\subseteq (S \\cap T)$. We'll show $(U \\subseteq S) \\land (U \\subseteq T)$.\nTo prove this is to prove two statements.\n\n  1.1. We'll show $U \\subseteq S$. Assume $x : X$. Assume $h_2 : x \\in U$. We must show\n    $x \\in S$.  We have $h_3 : x \\in S \\cap T$, from $h$ and $h_2$. The remainder of this\n    subproof is left for the reader.\n\n\n  1.2. We'll show $U \\subseteq T$. Do this yourself.\n\n\n2. We'll show $(U \\subseteq S) \\land (U \\subseteq T) \\to U \\subseteq (S \\cap T)$. Or rather,\nyou'll show this!  \u220e\n", "variable {X : Type*} -- hide\n", "## Task\nComplete the Lean proof below of the theorem above.\n", "Let $X$ be a type and let $S$, $T$, and $U$ be sets on $X$. \nThen $U \\subseteq (S \\cap T) \\leftrightarrow (U \\subseteq S) \\land (U \\subseteq T)$\n", "end exlean -- hide", "import sets.subset_inter -- hide\n", "# Sets\n## Level 11: Set difference\n\nLet $S$ and $T$ be sets on a type $X$. The *set difference* of $S$ and $T$, written $S \\setminus T$, is the set\n$\\\\{x : X \\mid (x \\in S) \\land (x \\notin T) \\\\}$.\n\n\n", "variable {X : Type*} -- hide\n", "namespace exlean -- hide\n", "## Task\nComplete the proof below.\n", "Let $S$, $T$, and $U$ be sets on a type $X$, then\n$(S \\setminus T)  \\cap (S \\setminus U) = S \\setminus (T \\cup U)$.\n", "end exlean -- hide", "import sets.set_difference -- hide\n", "# Sets\n## Level 12: Cartesian product\n\nLet $X$ and $Y$ be types. The *Cartesian product* of $X$ and $Y$, written $X \\times Y$, is the set of pairs\n$(x, y)$, where $x : X$ and $y : Y$. Given a term $z : X \\times Y$, we write $z = (z_1, z_2)$.\n\n\nLet $S$ be a set on $X$ and let $T$ be a set on $Y$. The *Cartesian product*\nof $S$ and $T$ is the set $\\\\{z : X \\times Y \\mid (z_1 \\in S) \\land (z_2 \\in T) \\\\}$.\n", "In Lean, we write `X \u00d7 Y` for the Cartesian product of types `X` and `Y`, where `\u00d7` is typed `\\x`.\n\nLikewise, we write `S \u00d7\u02e2 T` for the Cartesian product of two sets `S` and `T`. Here, `\u00d7\u02e2` is typed `\\x\\^s`.\n\nGiven `z : X \u00d7 Y`, we write `z.fst` and `z.snd` for the first and second elements of the pair `z`. Thus,\n`z = (z.fst, z.snd)`.\n", "Below is a Lean proof of the mathematical result $(A \\cup B) \\times S = (A \\times S) \\cup (B \\times S)$.\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} -- hide\n", "(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S)\n", "lemma union_prod {A B : set X} {S : set Y} :\n(A \u222a B) \u00d7\u02e2 S = (A \u00d7\u02e2 S) \u222a (B \u00d7\u02e2 S) :=\nbegin\n  ext x,\n  show x \u2208 (A \u222a B) \u00d7\u02e2 S \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S,\n  calc\n  x \u2208 (A \u222a B) \u00d7\u02e2 S  \u2194 (x.fst \u2208 A \u2228 x.fst \u2208 B) \u2227 x.snd \u2208 S : by refl\n    ... \u2194 (x.fst \u2208 A \u2227 x.snd \u2208 S) \u2228 (x.fst \u2208 B \u2227 x.snd \u2208 S) : by tauto!\n    ... \u2194 x \u2208 A \u00d7\u02e2 S \u222a B \u00d7\u02e2 S                               : by refl\nend\n", "## Task\nProve that $(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n", "$(A \\cap B) \\times S = (A \\times S) \\cap (B \\times S)$.\n", "end exlean -- hide", "import sets.union_prod -- hide\n", "# Sets\n## Level 13: Power set\n\nLet $S$ be a set on a type $X$. The *power set* of $S$, denoted $\\mathcal P(S)$, is the set of\nall subsets of $S$.\n\nThat is, $A \\in \\mathcal P(S)$ means $A \\subseteq S$.\n\nIn set constructor notation, the definition of $\\mathcal P(S)$ is\n$\n\\mathcal P(S) := \\\\{A : \\text{set}\\ X \\mid A \\subseteq S\\\\}.\n$\n\nThis illustrates that the members $A$ of the set $\\mathcal P(S)$ are terms of\ntype $\\text{set} X$. That is, each $A$ is itself a set of elements of type $X$.\n", "In Lean, the power set of `S` is written `\ud835\udcab(S)`, where `\ud835\udcab` is typed `\\power`.\n", "variables {X : Type*} -- hide\n", "namespace exlean -- hide\n", "Here is a Lean proof that $S \\in \\mathcal P(S)$, for every set $S$.\n", "example (S : set X) : S \u2208 \ud835\udcab(S) :=\nbegin\n  show S \u2286 S,\n  from subset_refl S,\nend\n", "## Task\nProve that for all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n", "For all sets $S$ and $T$ on a type $X$, if $S \\subseteq T$, then\n$\\mathcal P(S) \\subseteq \\mathcal P(T)$.\n", "end exlean -- hide", "import sets.power_set -- hide\n", "# Sets\n## Level 14: Power sets and intersections\n", "variables {X : Type*} -- hide\n", "namespace exlean -- hide\n", "## Task\nProve, by calculation, that for all sets $S$ and $T$ on a type $X$, \n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n", "Check the sidebar for a useful theorem you proved in a previous level\nof this world.\n", "A useful result", "For all sets $S$ and $T$ on a type $X$,\n$\\mathcal P(S \\cap T) = \\mathcal P(S) \\cap \\mathcal P(T)$.\n", "end exlean -- hide", "Functions", "import tactic.modded tactic.linarith -- hide\n", "# Functions\n## Level 1: Function extensionality\n\nLet $f : X \\to Y$ and $g : X \\to Y$ be functions. The principle of\nfunction extensionality asserts that $f = g$, given\n$\\forall(x : X),\\ f(x) = g(x)$.\n\n**Theorem**: Let $f : \\mathbb N \\to \\mathbb Z$ and \n$g : \\mathbb N \\to \\mathbb Z$ be functions given by\n$f(u) := 2u$ and $g(v) := v + v$. Then $f = g$.\n\n**Proof**: By the principle of extensionality, ot suffices to show that\n$\\forall(n : \\mathbb N),\\ f(n) = g(n)$. Assume $n : \\mathbb N$. We must show\n$f(n) = g(n)$. That is, $2n = n + n$. This holds by arithmetic.\n", "namespace exlean -- hide\n", "namespace function_test1 -- hide\n", "def f : \u2115 \u2192 \u2124 := \u03bb u, 2 * u\n", "-- hide\n", "def g : \u2115 \u2192 \u2124:= \u03bb v, v + v \n", "-- hide\n", "Here is a Lean proof of the result. We use the `ext` (extensionality)\ntactic with the variable `n` to replace the target of proving `f = g`\nwith the target of proving `f(n) = g(n)`, given `n : \u2115`.\n", "example : f = g :=\nbegin\n  ext n,\n  show f(n) = g(n),\n  show (2 : \u2124) * n = n + n, linarith,\nend\n", "## Task\nLet $c$ be an integer. Let $p$ and $q$ be functions from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$p(u) := 30u$ and $q(v) := c(c^2 + 4c - 11)v$. Given that $h : c^3 + 4c^2 - 11c - 30 = 0$,\nprove that $p = q$.\n", "In this exercise, you'll rewrite using an auxiliary equation, which can be proved using\n`linarith`.\n", "Proving an equation", "constant c : \u2124 -- hide\n", "-- hide\n", "def p : \u2124 \u2192 \u2124 := \u03bb u, 30 * u\n", "-- hide\n", "noncomputable -- hide\n", "def q : \u2124 \u2192 \u2124 := \u03bb v, c * (c^2 + 4 * c - 11) * v\n", "Let $c$ be an integer. Let $p$ and $q$ be functions from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$p(u) := 30u$ and $q(v) := c(c^2 + 4c - 11)v$. Suppose $h : c^3 + 4c^2 - 11c - 30 = 0$. Then $p = q$.\n", "end function_test1 -- hide\n", "end exlean -- hide", "import functions.function_extensionality -- hide\n", "# Functions\n## Level 2: Images of sets under functions \n\nLet $f : X \\to Y$ be a function and let $S$ be a set on $X$.\nThe *image* of $S$ under $f$, written $f(S)$, is the set\n$\n\\\\{y : Y \\mid \\exists(x : X), x \\in S \\land f(x) = y\\\\}.\n$\n\n**Theorem**: Let $f : X \\to Y$ be a function. Let $S$ and $T$ be sets of\nelements of $X$. If $S \\subseteq T$, then $f(S) \\subseteq f(T)$.\n\n**Proof**: Assume $h : S \\subseteq T$. We must show $f(S) \\subseteq f(T)$.\nAssume $y : Y$. Assume $h_2 : y \\in f(S)$. We must show $y \\in f(T)$.\nFrom $h_2$, we have $x : X$, $h_3 : x \\in S$, and $h_4 : f(x) = y$.\nWe must show $\\exists (z : X),\\ z \\in T \\land f(z) = y$. Take $z$ to be $x$.\nThen we must show $x \\in T \\land f(x) = y$. We prove each of these separately.\n\n1. We show $x \\in T$ from $h$ and $h_3$.\n\n2. We show $f(x) = y$, from $h_4$. \u220e\n\nIn the proof above, we implicitly perform exists elimination and both left and right\nand elimination when we decompose the hypothesis\n$h_2 : \\exists (x : X),\\ x \\in S \\land f(x) = y$.\n\nIn Lean, a compound expression such as this can be decomposed in one step using the `rcases`\n(for recursive cases) tactic.\n\nThis is used in the proof fragment below. The 'angle quotes' `\u27e8` and `\u27e9` are typed `\\<` and `\\>`.\n\nWe have the compound expression `h\u2082 : \u2203 (x : X), x \u2208 S \u2227 f(x) = y`.\n\nWe could perform a 'first level' decomposition by typing `rcases h\u2082 with \u27e8x, k\u2082 : x \u2208 S \u2227 f(x) = y\u27e9`, say.\nThis would be the same as `cases h\u2082 with x k\u2082` and would introduce a variable `x : X`\nand the assumption `k\u2082 : x \u2208 S \u2227 f(x) = y`. But the `k\u2082` can also be decomposed\n(via left and right and elimination).\n\nWe could do this by typing `cases k\u2082 with h\u2083 h\u2084`. Or we could decompose `h\u2082` entirely\nin one command by typing `rcases h\u2082 with \u27e8x, \u27e8h\u2083 : x \u2208 S, h\u2084 : f(x) = y\u27e9\u27e9`.\n\nEither way gives `h\u2083 : x \u2208 S` and `h\u2084 : f(x) = y`.\n\n**Note** that the image $f(S)$ is denoted in Lean by `f '' S`.\n", "Used for recursive elimination.\n\n## Examples\n* If `h : a \u2227 b` then `rcases h with \u27e8h\u2081 : a, h\u2082 : b\u27e9` replaces `h` with two hypotheses,\n`h\u2081 : a` and `h\u2082 : b`.\n\n* If `h : \u2203 (x : X), P(x)`, then `rcases h with \u27e8x, h\u2082 : P(x)\u27e9` replaces `h` with `x : X`\nand `h\u2082 : P(x)`.  \n\n* If `h : a \u2228 b`, then `rcases h with (h\u2081 : a) | (h\u2082 : b)` replaces the goal with two new goals,\none with a hypothesis `h\u2081 : a` and one with a hypothesis `h\u2082 : b`.\n\n* If `h : a = b`, then `rcases h with rfl` replaces every occurence of `b` in the context\nwith `a`.\n\n* These rules can be used recursively. Thus if `\u2203 (x : \u2115), Q(x) \u2228 (P(x) \u2227 y = 2 * x)`,\nthen `rcases h with \u27e8x, (h\u2082 : Q(x)) | \u27e8h\u2083 : P(x), rfl\u27e9 \u27e9` replaces `h` and creates two new goals.\nEach goal contains `x : \u2115`. The context of the first goal contains contains `h\u2082 : Q(x)`.\nIn the second goal, every instance of `y` is replaced with `2 * x`. The context of the\nsecond goal  contains `h\u2083: P(x)`.\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {S T : set X}-- hide\n", "## Task\nComplete the proof of the theorem below.\n", "Let $f : X \\to Y$ be a function. Let $S$ and $T$ be sets of\nelements of $X$. If $S \\subseteq T$, then $f(S) \\subseteq f(T)$.\n", "end exlean -- hide", "import functions.func_image1 -- hide\n", "# Functions\n## Level 3: Example of images of sets under functions\n\nLet $f : \\mathbb Z \\to \\mathbb Z$ be the function given by $f(u) = 2(u + 4)$.\n\nLet $S$ and $T$ be the sets of elements of $\\mathbb Z$ given by\n$S := \\\\{n : \\mathbb Z \\mid n \\ge -4 \\\\}$ and\n$T := \\\\{y : \\mathbb Z \\mid y \\ge 0 \\land \\exists(m : \\mathbb Z),\\ y = 2m \\\\}$.\n\nThen $f(S) = T$.\n\nAs this result is an equality of sets, we must prove that $y \\in f(S) \\leftrightarrow y \\in T$,\ngiven $y : \\mathbb Z$. This requires proving two implications.\n\nWe'll indicate how to prove one implication below in Lean and leave the complete proof for\nyou.\n", "namespace exlean -- hide\n", "namespace function_test2 -- hide\n", "def f : \u2124 \u2192 \u2124 := \u03bb u, 2 * (u + 4)\n", "-- hide\n", "def S : set \u2124 := {n : \u2124 | n \u2265 -4}\n", "-- hide\n", "def T : set \u2124 := {y : \u2124 | y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m} \n", "-- hide\n", "example : f '' S \u2286 T :=\nbegin\n  assume y : \u2124,\n  show y \u2208 f '' S \u2192 y \u2208 T,\n  assume h : y \u2208 f '' S,\n  given h : \u2203 (x : \u2124), x \u2208 S \u2227 f(x) = y,\n  show y \u2265 0 \u2227 \u2203 (m : \u2124), y = 2 * m,\n  rcases h with \u27e8x, \u27e8h\u2082 : x \u2265 -4, h\u2083 : 2 * (x + 4) = y\u27e9\u27e9,\n  split,\n  { linarith, },\n  { use x + 4,\n    linarith, },\nend\n", "## Task\nProve $f(S) = T$. You'll need to split this into two directions (via extensionality)\nand then prove each part separately. The proof above should help with the first\nimplication.\n", "$f(S) = T$, with $f$, $S$, and $T$ as above.\n", "end function_test2 -- hide\n", "end exlean -- hide", "import functions.func_image_example -- hide\n", "# Functions\n## Level 4: The image of an intersection\n\nIn this level, you'll prove that the image of an intersection is a subset of the intersection\nof the images.\n", "namespace exlean -- hide\n", "## Task\nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Prove\n$f(S \\cap T) \\subseteq f(S) \\cap f(T)$.\n", "variables {X : Type*} {Y : Type*} -- hide\n", "Let $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Then\n$f(S \\cap T) \\subseteq f(S) \\cap f(T)$.\n", "end exlean -- hide", "import functions.image_inter_subset -- hide\n", "# Functions\n## Level 5: The image of a union\n\nIn this level, we'll investigate the image of a union. Unions are constructions that depend on the\n`\u2228` logical connective. We'll first see how to decompose such statements using `rcases`.\n", "Given a hypothesis `h : p \u2228 q`, doing `rcases h with h\u2081 | h\u2081` splits the goal into\ntwo new goals, where `h\u2081 : p` in the first goal and `h\u2081 : q` in the second goal.\nHere, for instance, is one way of proving `p` on the assumption `h : (p \u2227 q) \u2228 (p \u2227 r)`. \n", "example (p q r : Prop) (h : (p \u2227 q) \u2228 (p \u2227 r)) : p :=\nbegin\n  rcases h with (h\u2081 : p \u2227 q) | (h\u2081 : p \u2227 r),\n  { given h\u2081 : p \u2227 q,\n    show p, from h\u2081.left, },\n  { given h\u2081: p \u2227 r,\n    show p, from h\u2081.left, }\nend\n", "The proof can be made even simpler by recursively decomposing each of the expressions `p \u2227 q` and `p \u2227 r`.\nHere, I use `-` to let Lean know I don't care about the other part of the hypothesis.\n", "example (p q r : Prop) (h : (p \u2227 q) \u2228 (p \u2227 r)) : p :=\nbegin\n  rcases h with \u27e8h\u2081 : p, -\u27e9 | \u27e8h\u2081 : p, -\u27e9,\n  { show p, from h\u2081, },\n  { show p, from h\u2081, }\nend\n", "namespace exlean -- hide\n", "## Task\nLet $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Prove\n$f(S \\cup T) = f(S) \\cup f(T)$.\n", "variables {X : Type*} {Y : Type*} -- hide\n", "Let $f : X \\to Y$ be a function and let $S$ and $T$ be sets on $X$. Then\n$f(S \\cup T) = f(S) \\cup f(T)$.\n", "end exlean -- hide", "import functions.image_union -- hide\n", "# Functions\n## Level 6: The preimage of a set under a function\n\nLet $f : X \\to Y$ be a function and let $U$ be a set on $Y$.\nThe *pre-image* of $U$ under $f$, written $f^{-1}(U)$, is the set\n$\n\\\\{x : X \\mid f(x) \\in U\\\\}.\n$\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} -- hide\n", "f\u207b\u00b9'(U) \u2286 f\u207b\u00b9'(V)\n", "In Lean, we write `f\u207b\u00b9'(U)` for $f^{-1}(U)$. This is typed `f\\-1'(U)`.\n\n**Theorem**: Suppose that $f : X \\to Y$, that $U$ and $V$ are sets of elements of $Y$\nand that $U \\subseteq V$. Then $f^{-1}(U) \\subseteq f^{-1}(V)$.\n\nWe prove this in Lean below.\n", "lemma preimage_mono (f : X \u2192 Y) (U V : set Y) (h : U \u2286 V) : f\u207b\u00b9'(U) \u2286 f\u207b\u00b9'(V) :=\nbegin\n  assume x : X,\n  assume h\u2082 : x \u2208 f\u207b\u00b9'(U),\n  given h\u2082 : f(x) \u2208 U,\n  show f(x) \u2208 V, from h h\u2082, \nend\n", "## Task\nLet $f : X \\to Y$ be a function and let $U$ and $V$ be sets on $Y$. Prove\n$f^{-1}(U \\cap V) = f^{-1}(U) \\cap f^{-1}(V)$.\n", "Let $f : X \\to Y$ be a function and let $U$ and $V$ be sets on $Y$. Then\n$f^{-1}(U \\cap V) = f^{-1}(U) \\cap f^{-1}(V)$.\n", "end exlean -- hide", "import functions.preimage data.real.basic -- hide\n", "# Functions\n## Level 7: Surjective functions\n\nFor the function $f : X \\to Y$ to be *surjective* means that\n$\\forall (y : Y),\\ \\exists(x : X),\\ f(x) = y$.\n", "namespace exlean -- hide\n", "**Lemma**: Let $f : \\mathbb R \\to \\mathbb R$ be the function $f(x) := 2x$. Then $f$ is\nsurjective.\n\n**Proof**: We must show $\\forall (y : \\mathbb R),\\ \\exists (x : \\mathbb R),\\ 2x = y$.\nAssume $y : \\mathbb R$. Take $x$ to be $y/2$. Then $2(y/2) = y$ follows by arithmetic. \u220e\n", "namespace func_surj1 -- hide\n", "open function -- hide\n", "The same result can be proved in Lean, as below.\n", "def f : \u211d \u2192 \u211d := \u03bb x, 2 * x\n", "-- hide\n", "example : surjective f :=\nbegin\n  show \u2200 (y : \u211d), \u2203 (x : \u211d), 2 * x = y,\n  assume y : \u211d,\n  use y / 2,\n  linarith,\nend\n", "## Task\nLet $g : \\mathbb R \\to \\mathbb R$ be the function $g(x) := 3x + 5$. Prove that $g$ is surjective.\n", "def g : \u211d \u2192 \u211d := \u03bb x, 3 * x + 5 \n", "Let $g : \\mathbb R \\to \\mathbb R$ be the function $g(x) := 3x + 5$. Then $g$ is surjective.\n", "end func_surj1 -- hide\n", "end exlean -- hide", "import functions.preimage -- hide\n", "# Functions\n## Level 8: Not surjective functions\n", "namespace exlean -- hide\n", "**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := 2x$. Then $f$ is\nnot surjective.\n\n**Proof**: For $f$ to *be* surjective means\n$\\forall (y : \\mathbb Z),\\ \\exists(x : \\mathbb Z),\\ 2x = y$.\nWe want to prove the negation of this statement, which is\n$\\exists (y : \\mathbb Z),\\ \\forall (x : \\mathbb Z),\\ 2x \u2260 y$.\nTake $y$ to be $1$. We must show $\\forall(x : \\mathbb Z), 2x \\ne 1$.\nAssume $x : \\mathbb Z$. Assume $h : 2x = 1$. But for natural numbers $a$ and $b$, we know\nif $ab = 1$, then $a = 1$. Thus, $2 = 1$, a contradiction. \u220e\n", "namespace func_surj2 -- hide\n", "open function -- hide\n", "The same result can be proved in Lean, as below. We use the Lean theorem\n`nat.eq_one_of_mul_eq_one_right` which returns a proof of `a = 1` given a proof\nof `a * b = 1`.\n", "def f : \u2115 \u2192 \u2115 := \u03bb x, 2 * x\n", "-- hide\n", "a = 1\n", "example : \u00ac(surjective f) :=\nbegin\n  push_neg,\n  show \u2203 (y : \u2115), \u2200 (x : \u2115), 2 * x \u2260 y,\n  use 1,\n  assume x : \u2115,\n  assume h : 2 * x = 1,\n  have h\u2082: 2 = 1, from nat.eq_one_of_mul_eq_one_right h,\n  linarith,\nend\n", "## Task\nLet $g : \\mathbb N \\to \\mathbb N$ be the function $g(x) := 3x + 5$. Prove that $g$ is not surjective.\n", "Hint : How to proceed\nTry adapting the proof above. Try to arrange things so that you can prove \n`3 * x = 1`, for some `x`.\n", "def g : \u2115 \u2192 \u2115 := \u03bb x, 3 * x + 5\n", "Let $g : \\mathbb N \\to \\mathbb N$ be the function $g(x) := 3x + 5$. Then $g$ is not surjective.\n", "end func_surj2 -- hide\n", "end exlean -- hide", "import functions.not_surjective -- hide\n", "# Functions\n## Level 9: Injective functions\n\nFor the function $f : X \\to Y$ to be *injective* means that for all $x_1$ and $x_2$ of type\n$X$, if $f(x_1) = f(x_2)$, then $x_1 = x_2$.\n\nMore formally, $\\forall (x_1\\ x_1 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\n", "namespace exlean -- hide\n", "**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := 2x$. Then $f$ is\ninjective.\n\n**Proof**: Assume $x_1, x_2 : \\mathbb Z$. Assume $h : f(x_1) = f(x_2)$. We must show $x_1 = x_2$.\nBy definition, $h : 2x_1 = 2x_2$. The result $x_1 = x_2$ follows by arithmetic. \u220e\n", "namespace func_inj1 -- hide\n", "open function -- hide\n", "This result is proved in Lean below.\n", "def f : \u2124 \u2192 \u2124 := \u03bb x, 2 * x\n", "-- hide\n", "example : injective f :=\nbegin\n  assume x\u2081 x\u2082 : \u2124,\n  assume h : f(x\u2081) = f(x\u2082),\n  given h : 2 * x\u2081 = 2 * x\u2082,\n  show x\u2081 = x\u2082, linarith,\nend\n", "## Task\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := 3x + 5$. Prove that $g$ is injective.\n", "def g : \u2124 \u2192 \u2124 := \u03bb x, 3 * x + 5\n", "Let $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := 3x + 5$. Then $g$ is injective.\n", "end func_inj1 -- hide\n", "end exlean -- hide", "import functions.injective -- hide\n", "# Functions\n## Level 10: Not injective functions\n", "namespace exlean -- hide\n", "**Lemma**: Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x(x - 3)$. Then $f$ is not\ninjective.\n\nBefore proving this, consider the negation of 'injective'. In general, for $f : X \\to Y$ to be injective\nmeans $\\forall (x_1\\ x_1 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\nNegating this and pushing the negation through the quantifiers gives\n$\n\\exists (x_1\\ x_2 : X),\\ \\neg(f(x_1) = f(x_2) \\to x_1 = x_2).\n$\n\nOne result of our work on propositional logic is that $(p \\to q) \\leftrightarrow (\\neg p \\lor q)$,\nfor propositions $p$ and $q$. Thus (by propositional extensionality, de Morgan's law, and double negation),\n$\\neg(p \\to q) = \\neg(\\neg p \\lor q) = p \\land \\neg q$.\n\nThus, the negation of $f$ being injective is\n$\n\\exists (x_1\\ x_2 : X),\\ f(x_1) = f(x_2) \\land x_1 \\ne x_2.\n$\n\n**Proof**: \n\nWe must show $\\exists (x_1\\ x_2 : \u2124),\\ f(x_1) = f(x_2) \\land x_1 \\ne x_2$.\nTake $x_1$ to be $0$ and $x_2$ to be $3$. We must show $f(0) = f(3) \\land 0 \\ne 3$.\nThat is, to show $0 = 0 \\land 0 \\ne 3$. Each of these two statements can be proved by arithmetic.\n \u220e\n", "namespace func_inj2 -- hide\n", "open function -- hide\n", "This result is proved in Lean below.\n", "def f : \u2124 \u2192 \u2124 := \u03bb x, x * (x - 3)\n", "-- hide\n", "example : \u00ac(injective f) :=\nbegin\n  show \u00ac(\u2200 (x\u2081 x\u2082 : \u2124), f(x\u2081) = f(x\u2082) \u2192 x\u2081 = x\u2082),\n  push_neg,\n  show \u2203 (x\u2081 x\u2082 : \u2124), f(x\u2081) = f(x\u2082) \u2227 x\u2081 \u2260 x\u2082,\n  use 0, use 3,\n  show (0 : \u2124) = 0 \u2227 (0 : \u2124) \u2260 3,\n  split,\n  { linarith, },\n  { linarith, },\nend\n", "## Task\nLet $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := x^3 + 3x^2 - 10x - 24$.\nProve that $g$ is not injective.\n", "def g : \u2124 \u2192 \u2124 := \u03bb x, x^3 + 3 * x^2 - 10 * x - 24\n", "Let $g : \\mathbb Z \\to \\mathbb Z$ be the function $g(x) := x^3 + 3x^2 - 10x - 24$.\nThen $g$ is not injective.\n", "end func_inj2 -- hide\n", "end exlean -- hide", "import functions.not_injective -- hide\n", "# Functions\n## Level 11: Bijective functions\n\nFor a function $f : X \\to Y$ to be *bijective* means that\n$f$ is injective and $f$ is surjective.\n", "namespace exlean -- hide\n", "namespace func_bij1 -- hide\n", "open function -- hide\n", "## Task\nLet $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x + 3$.\nProve that $f$ is bijective.\n", "def f : \u2124 \u2192 \u2124 := \u03bb x, x + 3\n", "-- hide\n", "Let $f : \\mathbb Z \\to \\mathbb Z$ be the function $f(x) := x + 3$.\nThen $f$ is bijective.\n", "end func_bij1 -- hide\n", "end exlean -- hide", "import functions.bijective -- hide\n", "# Functions\n## Level 12: Image of an injective function\n", "namespace exlean -- hide\n", "open function -- hide\n", "## Task\nSuppose $f : X \\to Y$ is an injective function. Suppose $S$ and $T$\nare sets on $X$. Given that $f(S) \\subseteq f(T)$, prove that $S \\subseteq T$.\n\nNote: this is a question about equality of *sets*.\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y} {S T : set X} -- hide\n", "Suppose $f : X \\to Y$ is an injective function. Suppose $S$ and $T$\nare sets on $X$. Given that $f(S) \\subseteq f(T)$, then $S \\subseteq T$.\n", "end exlean -- hide", "import functions.image_of_injective -- hide\n", "# Functions\n## Level 13: The composition of two functions\n\nLet $f : X \\to Y$ and $g : Y \\to Z$ be functions. The *composition*\nof $g$ and $f$, denoted $g \\circ f$ is the function of type $X \\to Z$\ndefined by $(g \\circ f)(x) := g(f(x))$.\n", "namespace exlean -- hide\n", "namespace func_compo_1 -- hide\n", "open function -- hide\n", "In the example below, we show that if $f$ and $g$ are functions from $\\mathbb Z$\nto $\\mathbb Z$ given by $f(x) := x + 3$ and $g(y) = y^2 - 9$,\nthen for every $u : \\mathbb Z$, we have $(g \\circ f)(u) = u(6 + u)$.\n\nIn Lean, `\u2218` is typed `\\o`.\n", "def f : \u2115 \u2192 \u2124 := \u03bb x, x + 3\n", "-- hide\n", "def g : \u2124 \u2192 \u2124 := \u03bb y, y ^ 2 - 9\n", "-- hide\n", "example (u : \u2115) : (g \u2218 f)(u) = u * (6 + u) :=\nbegin\n  show g(f(u)) = u * (6 + u),\n  show g(u + 3) = u * (6 + u),\n  show ((u + 3)^2 - 9 : \u2124) = u * (6 + u),\n  linarith,\nend\n", "end func_compo_1 -- hide\n", "As another example, we prove that function composition is associative. That is,\ngiven $p : X \\to Y$, $q : Y \\to Z$ and $r : Z \\to W$, we'll show\n$(r \\circ q) \\circ p = r \\circ (q \\circ p)$.\n\nIn fact this result follows by reflexivity. However, to illustrate other\nuseful techniques, we give a slightly longer proof.\n", "variables {X : Type*} {Y : Type*} {Z : Type*} {W : Type*} -- hide\n", "(r \u2218 q) \u2218 p = r \u2218 (q \u2218 p) \n", "lemma comp.assoc (p : X \u2192 Y) (q : Y \u2192 Z) (r : Z \u2192 W) :\n(r \u2218 q) \u2218 p = r \u2218 (q \u2218 p) :=\nbegin\n  ext x, -- By extensionality, it suffices to ...\n  show (r \u2218 q)(p(x)) = r((q \u2218 p)(x)),\n  show r(q(p(x))) = r(q(p(x))),\n  from rfl,\nend\n", "## Task\nGiven functions $r$ and $q$ from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$q(y) := y + y^2$ and $r(u) := u^2 + 5u + 6$, find a function $p$\nfrom $\\mathbb Z$ to $\\mathbb Z$ such that $q \\circ p = r$.\n\nIn the Lean proof below, replace the `_` with an expression, to give a\ndefinition of `p`. You are then left with the task of proving the equality\n`q \u2218 p = r`. Ask yourself: what is it to prove the equality of two functions?\n", "Do this by hand first. Try a solution of the form $p(x) := ax + b$\nwhere $a$ and $b$ are parameters to be determined.\n", "A suggested approach", "namespace func_compo_1\ndef r : \u2124 \u2192 \u2124 := \u03bb u, u^2 + 5 * u + 6\n", "-- hide\n", "def q : \u2124 \u2192 \u2124 := \u03bb y, y + y^2\n", "Given functions $r$ and $q$ from $\\mathbb Z$ to $\\mathbb Z$ defined by\n$q(y) := y + y^2$ and $r(u) := u^2 + 5u + 6$. There exists a function $p$\nfrom $\\mathbb Z$ to $\\mathbb Z$ such that $q \\circ p = r$.\n", "end func_compo_1 -- hide\n", "end exlean -- hide", "import functions.composite -- hide\n", "# Functions\n## Level 14: The composition of two injective functions\n\n", "namespace exlean -- hide\n", "open function -- hide\n", "## Task\nProve that the composition of two injective functions is injective.\n", "variables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n", "Let $g : Y \\to Z$ and $f : X \\to Y$ be injective functions.\nThen $g \\circ f$ is injective.\n", "end exlean -- hide", "import functions.comp_inj -- hide\n", "# Functions\n## Level 15: The composition of two surjective functions\n", "namespace exlean -- hide\n", "open function -- hide\n", "## Task\nProve that the composition of two surjective functions is surjective.\n", "variables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n", "Let $g : Y \\to Z$ and $f : X \\to Y$ be surjective functions.\nThen $g \\circ f$ is surjective.\n", "end exlean -- hide", "import functions.comp_surj -- hide\n", "# Functions\n## Level 16: Images and surjective functions\n\nThis level will challenge your understanding of composition,\nsurjective functions, images, and preimages.\n", "namespace exlean -- hide\n", "open function -- hide\n", "## Task\nLet $f : X \\to Y$ and $g : Y \\to Z$ be surjective functions.\nSuppose $W$ is a set on $Z$. Prove that there exists a set\n$S$ on $X$ such that $(g \\circ f)(S) = W$.\n", "variables {X : Type*} {Y : Type*} {Z : Type*} {g : Y \u2192 Z} {f : X \u2192 Y}  -- hide\n", "Let $f : X \\to Y$ and $g : Y \\to Z$ be surjective functions.\nSuppose $W$ is a set on $Z$. Then there exists a set\n$S$ on $X$ such that $(g \\circ f)(S) = W$.\n", "end exlean -- hide", "import functions.comp_image_of_surjective -- hide\n", "# Functions\n## Level 17: Identity and inverses\n", "Given a type $X$, the identity function on $X$, denoted $\\text{id}_X$,\nis the function from $X$ to $X$ defined by $\\text{id}_X(x) := x$.\n\nGiven $f : X \\to Y$, it follows that $f \\circ \\text{id}_X = f$\nand $\\text{id}_Y \\circ f = f$.\n\nIn Lean, the identity function on a type `X` is denoted `@id X`.\nIn most situations, Lean can infer the type, in which case you\ncan denote the identity function as `id`.\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} -- hide\n", "example (f : X \u2192 Y) : f \u2218 id = f :=\nbegin\n  from rfl\nend\n", "-- hide\n", "example (f : X \u2192 Y) : id \u2218 f = f :=\nbegin\n  from rfl\nend\n", "Suppose $p : X \\to Y$ is a function. For a function $f : Y \\to X$ to \nbe a *left inverse* of $p$ means that $f \\circ p = \\text{id}_X$.\n\nLikewise, for a function $g : Y \\to X$ to be a *right inverse* of $p$ means that\n$p \\circ f = \\text{id}_Y$.\n", "namespace compo2 -- hide\n", "Let $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. \n\n\nConsider the function $g_1 : \\mathbb Z \\to \\mathbb N$ defined\n*piecewise* by\n\n$g_1(y) :=\n\\begin{cases}\nn, & \\text{if $y = n + 2$ is a natural number}, \\\\\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$\n\nThen $g_1$ is a left inverse of $f$. Indeed, let $n : \\mathbb N$.\nThen\n$g_1(f(n)) = g_1(n + 2) = (n + 2) - 2 = n$,\nas $n + 2$ is a natural number.\n", "Here is our Lean definition of `f`.\n", "def f : \u2115 \u2192 \u2124 := \u03bb x, x + 2\n", "Below, we prove `\u2203 (g : \u2124 \u2192 \u2115), g \u2218 f = id`. The first step is\nto give a piecewise definition of a function `g`. We do this\nvia a Lean `match` expression. Compare this with the definition\ngiven above.\n\nAs the `match` expression of `g\u2081` consists of two cases, we use `split`\nto ask Lean to provide a proof in each of the cases.\n", "example : \u2203 (g : \u2124 \u2192 \u2115), g \u2218 f = id :=\nbegin\n  let g\u2081 : \u2124 \u2192 \u2115 := \u03bb y,\n  match y with \n  | (n + 2 : \u2115) := n\n  | _           := 0\n  end,\n  use g\u2081, show g\u2081 \u2218 f = id,\n  ext x, show g\u2081(f(x)) = x,\n  split, -- consider each of the cases of the definition of `g\u2081`.\nend\n", "Interestingly, $f$ has more than one left inverse!\n", "## Task\nSuppose $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. Find a function $g : \\mathbb Z \\to \\mathbb N$ such\nthat $g(1) = 42$ and such that $g$ is a left inverse of $f$.\n\nYou should be able to do this by adapting the proof above.\n", "Suppose $f : \\mathbb N \\to \\mathbb Z$, where\n$f(x) := x + 2$. Then there exists a function\n$g : \\mathbb Z \\to \\mathbb N$ such that $g(1) = 42$ and such that\n$g$ is a left inverse of $f$.\n", "end compo2 -- hide\n", "end exlean -- hide", "import functions.identity_lr_inverse -- hide\n", "# Functions\n## Level 18: Uniqueness of inverses\n", "**Theorem**:\nSuppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n\n**Sketch Proof**: We are given $h_1 : g_1 \\circ f = \\text{id}_X$ and\n$h_2 : f \\circ g_2 = \\text{id}_Y$.\n\nSo\n\\begin{align}\ng_1 & = g_1 \\circ \\text{id}_Y & & \\text{by definition} \\\\\\\\\n& = \\dots & & \\dots \\\\\\\\\n& = \\text{id}_X \\circ g_2 & & \\dots \\\\\\\\\n& = g_2 & & \\text{by definition} \\\\\\\\\n\\end{align} \u220e\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g\u2081 g\u2082 : Y \u2192 X} -- hide\n", "## Task\nComplete the sketch proof above and write it as a Lean proof.\n", "Suppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n", "end exlean -- hide", "import functions.uniqueness_of_inverse -- hide\n", "# Functions\n## Level 19: A function with a left inverse is injective\n", "**Theorem**:\nSuppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a left inverse of $f$.\nThen $f$ is injective.\n\n**Sketch Proof**:\nWe must show $\\forall (x_1\\ x_2 : X),\\ f(x_1) = f(x_2) \\to x_1 = x_2$.\nAssume $x_1,\\ x_2 : X$. Assume $h : f(x_1) = f(x_2)$. We must show $x_1 = x_2$.\nNow\n\n\\begin{align}\nx_1 & = \\text{id}_X(x_1) & & \\text{by definition} \\\\\\\\\n& = \\dots & & \\dots \\\\\\\\\n& = \\text{id}_X(x_2) & & \\dots \\\\\\\\\n& = x_2 & & \\text{by definition} \\\\\\\\\n\\end{align} \u220e\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g : Y \u2192 X} -- hide\n", "open function -- hide\n", "## Task\nComplete the sketch proof above and write it as a Lean proof. At some point in your\nproof, you'll need to prove an equation. I suggest proving this by calculation.\n", "Suppose $f : X \\to Y$. Suppose $g_1 : Y \\to X$ is a left inverse of $f$.\nSuppose $g_2 : Y \\to X$ is a right inverse of $f$. Then $g_1 = g_2$.\n", "end exlean -- hide", "import functions.inj_of_left_inv -- hide\n", "# Functions\n## Level 20: A function with a right inverse is surjective\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y} {g : Y \u2192 X}  -- hide\n", "open function -- hide\n", "## Task\nSuppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a right inverse of $f$.\nProve that $f$ is surjective.\n", "Suppose $f : X \\to Y$. Suppose $g : Y \\to X$ is a right inverse of $f$.\nThen $f$ is surjective.\n", "end exlean -- hide", "import functions.surj_of_right_inv-- hide\n", "# Functions\n## Level 21: A surjective function has a right inverse\n\nThe remaining levels are only for the experts. Our aim is to prove (partial)\nconverses of two of the previous results. For a function $f : X \\to Y$, we\nhave proved:\n\n* If $f$ has a right inverse, then $f$ is surjective.\n* If $f$ has a left inverse, then $f$ is injective.\n\nWe'll now prove:\n\n* If $f$ is surjective, then $f$ has a right inverse\n* If $f$ is injective *and* there is a term of type $X$, then $f$ has a left inverse.\n\nHowever, we cannot prove these results without relying on another principle of\nclassical (i.e. non-constructive) mathematics. This is the *axiom of choice*.\n", "The axiom of choice is best explained via an example. Let $U$ denote the type of all modules\ncurrently running at Exeter and let $V$ denote the type of all students at Exeter.\n\nLet the two-variable predicate $R$ on $U$ and $V$ be defined so that $R(u,v)$ is the proposition\nthat student $v$ is enrolled on module $u$.\n\nWe know that for every module $u$, there is a student $v$ who is enrolled on $u$. That is,\n$\\forall (u : U),\\ \\exists (v : V),\\ R(u, v)$.\n\nThe axiom of choice asserts, under these hypotheses, that there is a function $g : U \\to V$ such that\n$R(u,g(u))$ holds for every $u : U$.\n\nIn our example, this means that for every module $u$, $g(u)$ is a student enrolled on $u$.\nIn other words, the axiom of choice guarantees the existence of a function that has (informally) *chosen*, for\neach module $u$, a student $v$ enrolled on $u$. Crucially, the axiom of choice is non-constructive: it does not\ngive an algorithm for finding such a function.\n\nMoreover such a function is not (necessarily) unique! There are \nmany functions with this property.\n", "section aoc -- hide\n", "open classical -- hide\n", "variables {U : Type*} {V : Type*} {R : U \u2192 V \u2192 Prop} -- hide\n", "As a more mathematical example, suppose we have a function $p : \\mathbb Q \\to \\mathbb Z$ with the \nproperty that for every $u : \\mathbb Q$, there exists a $v : \\mathbb Z$ such that $p(uv) > v$.\n\nBy the axiom of choice, we know that there is a function $g : \\mathbb Q \\to \\mathbb Z$ such that\nfor every $u : \\mathbb Q$, $p(ug(u)) > g(u)$.\n", "In Lean, the axiom of choice is called `axiom_of_choice`. Here's the example above in Lean.\n", "\u2203 g : U \u2192 V, \u2200 (u : U), R u (g u)\n", "example (p : \u211a \u2192 \u2124) (h : \u2200 (u : \u211a), \u2203 (v : \u2124), p(u * v) > v) :\n\u2203 (g : \u211a \u2192 \u2124), \u2200 (u : \u211a), p(u * g(u)) > g(u) :=\nbegin\n  from axiom_of_choice h,\nend\n", "Here is a prototypical application of the axiom of choice.\n\n", "example (h : \u2200 (u : U), \u2203 (v : V), R u v) : \u2203 (g : U \u2192 V), \u2200 (u : U), R u (g u) :=\nbegin\n  from axiom_of_choice h\nend\n", "end aoc -- hide\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y} -- hide\n", "open function -- hide\n", "open classical -- hide\n", "## Task\nSuppose $f : X \\to Y$. Suppose that $f$ is surjective. Prove, using the axiom of choice, that $f$ has a right inverse.\n", "Think about your the hypothesis `h` relates in the theorem statement below relates to the `h`\nin the example above. What corresponds to `U`, `V` and `R u v`?\n", "How does the axiom of choice help?", "Suppose $f : X \\to Y$. Suppose that $f$ is surjective. Then $f$ has a right inverse.\n", "end exlean -- hide", "import functions.right_inv_of_surjective -- hide\n", "# Functions\n## Level 22: An injective function has a left inverse\n\n\n", "namespace exlean -- hide\n", "variables {X : Type*} {Y : Type*} {f : X \u2192 Y}  -- hide\n", "open function -- hide\n", "open classical -- hide\n", "## Task\nThis is the hardest level so far. Your task is to use the axiom of choice and\nother classical reasoning methods to prove that if $f : X \\to Y$ is injective and\nif there is some term $d$ of type $X$, then $f$ has a left inverse.\n\nYou are given a sketch of the start of the proof. Complete the proof of hypothesis `h\u2082`.\nDetermine what results from applying the axiom of choice to `h\u2082`, then complete the\nremainder of the proof.\n", "Suppose $f : X \\to Y$. Suppose that $f$ is injective. Suppose $d$ is a term of the type\n$X$ (so the type isn't empy). Then $f$ has a left inverse.\n", "end exlean -- hide", "Real numbers", "import order tactic.modded sets.powerset_inter -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 1: Upper bound definition\n\nLet $X$ be an type equipped with an preorder (a relation that is\nreflexive and transitive). Let $S$ be a set on $X$. Then $u : X$ is said to be an\n*upper bound* of $S$ if for every $x : X$, if $x \\in S$, then $x \\le u$.\n", "variables  {X : Type*} [preorder X] -- hide\n", "def is_upper_bound (S : set X) (u : X) := \u2200 (x : X), x \u2208 S \u2192 x \u2264 u\n", "As a simple example, we'll show that $10$ is an upper bound of the set $S$ of rational numbers $x$\nsuch that $x \\le 5$.\n\n**Proof**. Suppose $x : \\mathbb Q$. Suppose $x \\in S$. Then $x \\le 5$. But $5 \\le 10$, so $x \\le 10$.\n\u220e\n", "namespace up1 -- hide\n", "def S := {x : \u211a | x \u2264 5}\n", "-- hide\n", "example : is_upper_bound S 10 :=\nbegin\n  show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 10,\n  assume x : \u211a,\n  assume h : x \u2208 S,\n  given h : x \u2264 5,\n  show x \u2264 10, linarith,\nend\n", "end up1 -- hide\n", "## Task\n\nAdapt the proof above to show that $7$ is an upper bound of the set $T$ of rational numbers $x$\nsuch that $3x + 5 \\le  25$.\n", "namespace up1 -- hide\n", "def T := {x : \u211a  | 3 * x + 5 \u2264 23}\n", "The set $T$ of rational numbers $x$ such that $3x + 5 \\le  23$ has $7$ as an upper bound.\n", "end up1 -- hide\n", "end exlean -- hide", "import reals.upper_bounds -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 2: Upper bound second example\n", "## Task\n\nIn this level, $S$ is the set of rational numbers $x$ such that either $-4 < x < 0$ or $2 < x < 10$,\na union of two intervals of rational numbers. You are asked to prove that $12$ is an upper bound of $S$.\n\nIn addition to the ideas introduced in the previous level, you will need to employ or elimination, together\nwith and elimination. The quickest approach is to use the `rcases` tactic from the Functions World.\n", "You should begin with the following template.\n```\nshow \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 12,\nsorry,\n```\n", "A proof template", "namespace up2 -- hide\n", "-- hide\n", "def S := {x : \u211a | ((-4 < x) \u2227 (x < 0)) \u2228 ((2 < x) \u2227 (x < 10))}\n", "Let $S$ be the set of rational numbers $x$ such that either $-4 < x < 0$ or $2 < x < 10$. Then $12$ is an upper\nbound of $S$.\n", "end up2\n", "end exlean -- hide", "import reals.upper_bounds2 -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 3: Sets that are bounded above\n", "variables  {X : Type*} [preorder X] -- hide\n", "For a set $S$ to be bounded above means that $S$ has an upper bound.\n", "def bounded_above (S : set X) := \u2203 (u : X), is_upper_bound S u\n", "For example, let $S$ be the set of rational numbers $x$ such that $x - 2 \\le 5$.\nTo show that $S$ is bounded above is to exhibit a value $u$ and a proof that $u$\nis an upper bound of $S$. We do this below in Lean\n", "namespace ub_bdd_above -- hide\n", "def S := {x : \u211a | x - 2 \u2264 5} \n", "-- hide\n", "example : bounded_above S :=\nbegin\n  show \u2203 (u : \u211a), is_upper_bound S u,\n  use 7, -- Take \"u\" to be 7.\n  show \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 7,\n  assume x : \u211a,\n  assume h : x \u2208 S,\n  given h : x - 2 \u2264 5,\n  show x \u2264 7, linarith,\nend\n", "end ub_bdd_above -- hide\n", "From your study of school algebra, you know that for a ordered type such as $\\mathbb Z$, $\\mathbb Q$, or $\\mathbb R$ with `nice' addition,\nsubtraction and multiplication, given $a < b$ and $0 < a$, one can deduce $a ^ 2 < b ^2$.\n\nWe have this in Lean as the theorem `sq_lt_sq_of_pos`\n", "a ^ 2 < b ^ 2\n", "lemma sq_lt_sq_of_pos {R : Type*} {a b : R} [linear_ordered_ring R] -- hide\n", "(h : a < b) (h\u2082 : 0 < a) : a ^ 2 < b ^ 2 := sq_lt_sq' (lt_trans (neg_lt_zero.mpr (lt_trans h\u2082 h)) h\u2082) h -- hide\n", "example (a b : \u211a) (h : a < b) (h\u2082 : 0 < a) : a ^2 < b ^2 :=\nbegin\n  from sq_lt_sq_of_pos h h\u2082,\nend\n", "We'll use this result to help in working with sets of numbers $x$ that satisfy a condition like $x^2 < 5$.\n\nLet $S$ be the set of all rational numbers $x$ such that $x^2 < 1$. We'll prove that $5$ is an upper bound of $S$.\n\n**Proof**: Assume that $x : \\mathbb Q$ and that $x \\in S$. Then (by definition of $S$), we have\n$x ^ 2 < 1$. Our aim is to show $x \\le 5$.\n\nSuppose, for a contradiction, that $\\neg (x \\le 5)$. We deduce that $5 < x$. But $0 < 5$, so\nwe deduce $5 ^ 2 < x ^ 2$. But this gives a contradiction with the assumption $x^2 < 1$. \u220e\n", "Let's prove this in Lean. One thing to look out for is that in our Lean proof of $0 < 5$,\nwe need to specify that we are dealing with *rational* numbers rather than natural numbers.\nWe do this by using a type annotation in `(0 : \u211a) < 5`.\n", "## Task\nLet $T$ be the set of rational numbers $x$ for which $(x + 1)^2 < 8$. Your task is to\nshow that $T$ is bounded above.\n\nTo do this, you need to *find* such a value $u$ and then show that it is an upper bound. For\nthe second part of the proof, you may adapt the proof above.\n", "namespace ubsq -- hide\n", "def T := {x : \u211a  | (x + 1) ^ 2 < 17}\n", "-- hide\n", "Let $T$ be the set of rational numbers $x$ for which $(x + 1)^2 < 17$. Then $T$ is\nbounded above\n", "end ubsq -- hide\n", "end exlean -- hide", "import reals.upper_bounds_squares -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 4: Lower bounds\n", "variables  {X : Type*} [preorder X] -- hide\n", "Let $S$ be a set on an preordered type $X$. For a term $v$ of type $X$ to be\na *lower bound* of $S$ means that for all $x : X$, if $x \\in S$, then $v \\le x$.\n\nHere is the definition in Lean.\n", "def is_lower_bound (S : set X) (v : X) := \u2200 (x : X), x \u2208 S \u2192 v \u2264 x\n", "For a set $S$ to be *bounded below* means that there exists a term\n$v : X$ for which $v$ is a lower bound of $S$.\n", "def bounded_below (S : set X) := \u2203 (v : X), is_lower_bound S v\n", "For a set to be *bounded* means that it is bounded above and bounded below.\n", "def bounded (S : set X) := (bounded_above S) \u2227 (bounded_below S)\n", "## Task\nLet $T$ be the set of rational numbers $x$ such that $2x + 3 > 26$.\nShow that $T$ is bounded below.\n\nYou should be able to do this by choosing an appropriate value $v$ then\n(adapting the work on upper bounds), showing that $v$ is a lower bound of $T$.\n", "namespace lb1 -- hide\n", "def T := {x : \u211a  | 2 * x + 3 > 26 }\n", "-- hide\n", "The set $T$ defined above is bounded below.\n", "end lb1 -- hide\n", "end exlean -- hide", "import reals.lower_bounds -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 5: Using upper bounds & lower bounds\n\nWe've seen how to *prove* that a term is an upper bound of a set. If we are *given* that a term is\nan upper bound of a set, how do we use that information?\n", "variables  {X : Type*} {S T : set X} [preorder X] -- hide\n", "We start by proving that if $S \\subseteq T$ and if $u$ is an upper bound of $T$, then\nthen $u$ is an upper bound of $S$.\n\nIn the Lean proof below, we start with `h\u2081 : S \u2286 T` and `h\u2082 : is_upper_bound T u`. By definition,\n`h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u`.\n\nTo show `is_upper_bound S u` is to show `\u2200 (x : X), x \u2208 S \u2192 x \u2264 u`.\n\nThis is a `\u2200` statement, so we assume `x : X`. We have to prove the implication `x \u2208 S \u2192 x \u2264 u`.\nThus we assume `h\u2083 : x \u2208 S` and are left with proving `x \u2264 u`. From the hypothesis `h\u2081 : S \u2286 T` and\nthe deduction `h\u2083 : x \u2208 S`, we derive `h\u2084 : x \u2208 T`.\n\nFinally, we use the upper bound property `h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u`. We apply this to `x`\nand to `h\u2082 : x \u2208 T` and derive `x \u2264 u`.\n", "(u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u\n", "lemma is_upper_bound_of_is_upper_bound_of_subset\n(u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u :=\nbegin\n  given h\u2082 : \u2200 (x : X), x \u2208 T \u2192 x \u2264 u,\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2264 u,\n  assume x : X,\n  assume h\u2083 : x \u2208 S,\n  have h\u2084 : x \u2208 T, from h\u2081 h\u2083,\n  show x \u2264 u, from h\u2082 x h\u2084,\nend\n", "## Implicit variables\nOne small time-saving measure is to realise, in using `\u2200 {x : X}, x \u2208 T \u2192 x \u2264 u`, that the quantity\n`x` is implicitly determined by a proof of `x \u2208 T`. We can ask Lean to try to infer that variable by\nusing braces in `h\u2082 : \u2200 {x : X}, x \u2208 T \u2192 x \u2264 u` below.\n\nOur final deduction is then from `h\u2082 h\u2084`, rather than `h\u2082 x h\u2084`. Use this technique if you find it\nhelpful.\n", "example (u : X) (h\u2081 : S \u2286 T) (h\u2082 : is_upper_bound T u) :\nis_upper_bound S u :=\nbegin\n  -- Using {x : X} in place of (x : X) makes x implicit.\n  given h\u2082 : \u2200 {x : X}, x \u2208 T \u2192 x \u2264 u,\n  show \u2200 (x : X), x \u2208 S \u2192 x \u2264 u,\n  assume x : X,\n  assume h\u2083 : x \u2208 S,\n  have h\u2084 : x \u2208 T, from h\u2081 h\u2083,\n  show x \u2264 u, from h\u2082 h\u2084, -- Note that `x` does not appear in this line\nend\n", "## Task\n\nAdapt either of the proofs above to show that if $S$ and $T$ are sets and if $v$ is a lower bound\nof $S$, then $v$ is a lower bound of $T$.\n", "If $S$ and $T$ are sets and if $v$ is a lower bound of $S$, then $v$ is a lower bound of $T$.\n", "end exlean -- hide", "import reals.using_bounds -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 6: Not an upper bound\n", "For a set $S$ to have $u$ as an upper bound means\n$\\forall (x : X), x \\in S \\to x \\le u$.\n\nFrom our study of predicate and propositional logic, we know that\nthe statement \"$u$ is *not* an upper bound of $S$\" is equivalent to\n$\\exists (x : X), x \\in S \\land u < x$.\n", "namespace not_upb -- hide\n", "In this example, let $S$ be the set of all integers such that\n$x ^ 2 \\le 100$. We'll show that the integer $5$ is not an\nupper bound of $S$.\n\n**Proof**: We must show $\\neg (\\forall (x : \\mathbb Z), x \\in S \\to x \\le 5)$.\nEquivalently, to show $\\exists(x : \\mathbb Z), x ^ 2 \\le 100 \\land 5 < x$.\n\nTake `$x$' to be $10$. We must show $10^2 \\le 100$ and $5 < 10$.\nEach of these follows by arithmetic. \u220e\n", "Here is the corresponding Lean proof. Note the use of type annotations\nso Lean knows we are dealing with integers not natural numbers.\n\nWe also introduce a new tactic, `norm_num`. This is particularly useful\nfor deadling with numeric expressions.\n", "Proves numeric equations and inequalities.\n", "def S := {x : \u2124 | x ^ 2 \u2264 100}\nexample : \u00ac(is_upper_bound S 5) :=\nbegin\n  show \u00ac(\u2200 (x : \u2124), x \u2208 S \u2192 x \u2264 5),\n  push_neg,\n  show \u2203 (x : \u2124), x ^2 \u2264 100 \u2227 5 < x,\n  use 10, -- Take \"x\" to be 10.\n  split,\n  { show (10 : \u2124) ^2 \u2264 100, norm_num, },\n  { show (5 : \u2124) < 10, norm_num, },\nend\n", "end not_upb -- hide\n", "## Task\n\nLet $T$ be the set of rational numbers $x$ such that $(x + 2)^3 \\le 800$.\nShow that $7$ is not an upper bound of $T$.\n\n**Use the `norm_num` tactic** for proving any numerical equations or inequalities.\n", "namespace not_upb -- hide\n", "def T := {x : \u211a | (x + 2) ^ 3 \u2264 800}\n", "The rational number $7$ is not an upper bound of the set $T$ above.\n", "end not_upb\n", "end exlean -- hide", "import reals.not_upper_bound -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 7: Sets without upper bounds\n", "## Task\n\nLet $T$ be the set of natural numbers $x$ such that $x = 3m$, for some natural number $m$.\nProve that $T$ has no upper bound. That is, prove that $T$ is not bounded above.\n\nThis *challenging* level tests your understanding of logic and of the definitions seen so far.\n", "namespace no_upb -- hide\n", "def T := {x : \u2115 | \u2203 (m : \u2115), x = 3 * m}\n", "Let $T$ be the set of natural numbers $x$ such that $x = 3m$, for some natural number $m$.\nThen $T$ is not bounded above\n", "end no_upb -- hide\n", "end exlean -- hide", "import reals.has_no_upper_bound -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 8: No smaller upper bound\n", "variables  {X : Type*} [preorder X] -- hide\n", "Let $S$ be a set on an preordered type $X$. Let $u : X$. We can ask the question:\n\"is every upper bound of $S$ no smaller than $u$?\"\n\nThat is, is it the case that for every $t : X$, if $t$ is an upper bound of $S$,\nthen $u \\le t$?\n", "def no_smaller_upper_bound (S : set X) (u : X) :=\n\u2200 (t : X), (is_upper_bound S t) \u2192 u \u2264 t\n", "As an example, we'll show that for the set $S$ of rational numbers $x$ for which\n$(x + 2) ^ 3 \\le 3000$, there is no smaller upper bound than $12$.\n\n**Proof**: We must show that for all $t : \\mathbb Q$, if $t$ is an\nupper bound of $S$, then $12 \\le t$.\n\nAssume $t : \\mathbb Q$. Assume that $t$ is an upper bound of $S$.\n\nThat is, we have assumed for all $x : \\mathbb Q$, if $x \\in S$, then $x \\le t$.\n\nWe must show $12 \\le t$.\n\nSuppose, for a contradiction, that $\\neg(12 \\le t)$. We must prove $\\bot$.\n\nObserve (by a numerical calculation) that $12 \\in S$, as $(12 + 2)^3 = 2744 \\le 3000$.\n\nBy the assumption that $t$ is an upper bound of $S$, we deduce $12 \\le t$.\n\nThis contradicts the assumption that $\\neg(12 \\le t)$. \u220e\n", "Here is the proof in Lean.\n", "namespace no_smaller -- hide\n", "def S := {x : \u211a | (x + 2) ^ 3 < 3000}\n", "-- hide\n", "example : no_smaller_upper_bound S 12 :=\nbegin\n  show \u2200 (t : \u211a), (is_upper_bound S t) \u2192 12 \u2264 t,\n  assume t : \u211a,\n  assume h : is_upper_bound S t,\n  given h : \u2200 (x : \u211a), x \u2208 S \u2192 x \u2264 t,\n  show 12 \u2264 t, by_contra k, -- Assume, for a contradction,\n  given k : \u00ac(12 \u2264 t),      -- that \u00ac(12 \u2264 t)\n  have h\u2082 : (12 : \u211a) \u2208 S,\n  { show ((12 : \u211a) + 2) ^ 3 < 3000, norm_num, },\n  have h\u2083 : (12 : \u211a) \u2264 t, from h 12 h\u2082,\n  show false, linarith,\nend\n", "end no_smaller -- hide\n", "## Task\n\nLet $T$ be the set of rational numbers $x$ such that $3 < x$ and $x < 10$. Show that\n$T$ has no smaller upper bound than $2$.\n\n**Remember to use type annotations** when dealing with numerals.\n\nTo prove numeric inequalities, **use the `norm_num` tactic**.\n", "namespace no_smaller -- hide\n", "def T := {x : \u211a | 3 < x \u2227 x < 10}\n", "Let $T$ be the above set. Then $T$ has no smaller upper bound than $2$.\n", "end no_smaller -- hide\n", "end exlean -- hide", "import reals.no_smaller_ub -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 9: Suprema\n", "variables  {X : Type*} [preorder X] -- hide\n", "Let $S$ be a set on an preordered type $X$. For a term $u : X$ to be a *supremum* of $S$\n(also called a *least upper bound* of $S$) is for: $u$ to be an upper bound of $S$ *and*\nfor $S$ to have no smaller upper bound than $u$.\n\nThe word *suprema* is just the plural form of supremum.\n", "def is_sup (S : set X) (u : X) := (is_upper_bound S u) \u2227 (no_smaller_upper_bound S u)\n", "namespace sup1 -- hide\n", "**Theorem**: Let $T := \\\\{x : \\mathbb Q \\mid x < 1 \\\\}$. Then $1$ is a supremum of $T$.\n\n**Proof**: The proof splits into two parts.\n\n1. We show $1$ is an upper bound of $T$.\n   Assume $x : \\mathbb Q$ and that $x \\in T$. We must show $x \\le 1$.\n   But $x \\in T$ means $x < 1$. From this, $x \\le 1$ follows.\n\n2. We show $T$ has no smaller upper bound than $1$.\n  That is, we show for all rational numbers $v$, if $v$ is an upper bound\n  of $T$, then $1 \\le v$.\n  Suppose not, for a contradiction.\n\n  Then we have a rational number $v$ such that $v$ is an upper bound\n  of $T$ and $v < 1$.\n  \n  Write $x := (v + 1)/2$. Then $x$ is a rational number and $v < x < 1$.\n  As $x < 1$, we have $x \\in T$. But $v$ is an upper bound of $T$,\n  whence $x \\le v$. It follows that $v < v$, a contradiction. \u220e\n", "This can be proved in Lean. Below, I use `rcases` to perform recursive\nelimination. If you prefer, you could instead use two applications of `cases`.\n", "def T := {x : \u211a | x < 1}\n", "-- hide\n", "lemma is_sup_T_1 : is_sup T 1 :=\nbegin\n  split,\n  { show is_upper_bound T 1,\n    show \u2200 (x : \u211a), x < 1 \u2192 x \u2264 1,\n    assume x : \u211a,\n    assume h : x < 1,\n    show x \u2264 1, linarith, },\n  { show no_smaller_upper_bound T 1,\n    show \u2200 (t : \u211a), is_upper_bound T t \u2192 1 \u2264 t, by_contra k,\n    push_neg at k,\n    given k : \u2203(t : \u211a), is_upper_bound T t \u2227 t < 1,\n    rcases k with \u27e8t, h\u2081, h\u2082\u27e9,\n    given h\u2081 : \u2200 (x : \u211a), x < 1 \u2192 x \u2264 t,\n    given h\u2082 : t < 1,\n    have h\u2083 : (t + 1)/2 < 1, linarith,\n    have : t < (t + 1)/2, linarith,\n    have : (t + 1)/2 \u2264 t, from h\u2081 ((t + 1)/2) h\u2083,\n    show false, linarith, },\nend\n", "end sup1 -- hide\n", "Often, we are interested in *whether* a set has a supremum.\nWe define the predicate `has_sup` so that `has_sup S` is the\nproposition `\u2203 (u : X), is_sup S u`.\n", "def has_sup (S : set X) := \u2203 (u : X), is_sup S u\n", "-- hide\n", "## Task\n\nLet $S$ be the set of rational numbers $x$ such that $x \u2264 1$.\nThen $S$ has a supremum.\n\nThis proof should be easier than that of the theorem above.\n\n**Remember to use type annotations** when dealing with numerals.\n\nTo prove numeric inequalities, **use the `norm_num` tactic**.\n", "namespace sup1 -- hide\n", "def S := {x : \u211a | x \u2264 1}\n", "The set $S$ above has a supremum.\n", "end sup1 -- hide\n", "end exlean -- hide", "import reals.suprema -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 10: Uniqueness of supremum\n", "variables {X : Type*} [partial_order X] -- hide\n", "A *partial order* on a type $X$ is a preorder (a reflexive, transitive relation) that is\nantisymmetric. Recall that for a relation\n$\\le$ to be antisymmetric means that if $a \\le b$ and $b \\le a$, then $a = b$.\n\nHere is how to use antisymmetry in Lean:\n", "a = b\n", "example (a b : X) (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) : a = b :=\nbegin\n  from le_antisymm h\u2081 h\u2082,\nend\n", "It can be clearer to apply antisymmetry *backward*. That is, to prove $a = b$, it\nsuffices to prove $a \\le b$ and to prove $b \\le a$.\n", "example (a b : X) (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) : a = b :=\nbegin\n  apply le_antisymm,\n  { show a \u2264 b, from h\u2081, },\n  { show b \u2264 a, from h\u2082, },\nend\n", "## Task\n\nLet $S$ be a set on a partially ordered type $X$. Suppose that $u_1$ and $u_2$ are suprema of $S$.\nProve that $u_1 = u_2$.\n", "I suggest a backward application of antisymmetry.\n```\n  apply le_antisymm,\n  { show u\u2081 \u2264 u\u2082,\n    sorry, },\n  { show u\u2082 \u2264 u\u2081,\n    sorry, }\n```\n", "A proof template", "variables {S : set X} {u\u2081 u\u2082 : X} -- hide\n", "If a set $S$ has suprema $u_1$ and $u_2$, then $u_1 = u_2$.\n", "end exlean -- hide", "import reals.sup_uniqueness -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 11: The maximum of two numbers\n\nWe take a brief pause from our discussion of suprema\nto study the maximum function. This will be highly relevant for our future study in this\nworld and the next.\n", "variables {X : Type*} [linear_order X] -- hide\n", "Let $X$ be a type with a partial order. Suppose, additionally, that for all $a, b : X$,\nthat either $a \\le b$ or $b \\le a$. An order relation with these properties is said to be\na *linear order*.\n\nThe *maximum* function on a linear order is defined so that\n$$\n\\max(a, b) :=\n\\begin{cases}\na, & \\text{if } b \\le a, \\\\\\\\\nb, & \\text{otherwise}.\n\\end{cases}\n$$\n", "From this definition, we easily extract a theorem with two parts.\n\n**Theorem**: For all $a$ and $b$ of a linear ordered type $X$\n\n* $a \\le \\max(a,b)$ and\n* $b \\le \\max(a,b)$.\n", "In Lean, these theorems are called `le_max_left` and `le_max_right`, respectively.\n", "example (a b : X) : a \u2264 max a b :=\nbegin\n  from le_max_left a b,\nend\n", "-- hide\n", "example (a b : X) : b \u2264 max a b :=\nbegin\n  from le_max_right a b\nend\n", "a \u2264 max a b\n", "b \u2264 max a b\n", "If you invoke `le_max_left` with the `apply` tactic, then Lean will create new goals\nfor the inputs and, where possible, close the goals automatically.\n", "example (a b : X) : a \u2264 max a b :=\nbegin\n  apply le_max_left,\nend\n", "## Task\nLet $a$, $b$, $c$ be terms of a linear ordered type $X$. Show that\n$\\max(a,b) \\le \\max(\\max(a,b),c)$.\n", "Let $a$, $b$, $c$ be terms of a linear ordered type $X$. Then\n$\\max(a,b) \\le \\max(\\max(a,b),c)$.\n", "end exlean -- hide", "import reals.maximum -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 12: Proving a maximum is at most another number\n\nIn the last level, we saw $a \\le \\max(a,b)$ and $b \\le \\max(a,b)$,\nproving a maximum of two numbers is at least the first number and is at least the second number.\n\nLikewise, one can show that if $a \\le c$ and $b \\le c$, then $\\max(a,b) \\le c$, proving that\na maximum of two numbers is at most a third number if each of the two numbers is at most the\nthird number.\n\nIn Lean, this theorem is called `max_le`.\n", "variables {X : Type*} [linear_order X] -- hide\n", "(h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : nax a b  \u2264 c\n", "example (a b c : X) (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c :=\nbegin\n  from max_le h\u2081 h\u2082,\nend\n", "It's often most convenient to use this theorem backward. That is, to replace the goal\nof proving `max a b \u2264 c` with two goals: one of proving `a \u2264 c` and the other of proving\n`b \u2264 c`.\n\nWe show this below in Lean.\n", "example (a b c : X) (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c :=\nbegin\n  apply max_le,\n  { show a \u2264 c, from h\u2081},\n  { show b \u2264 c, from h\u2082}\nend\n", "**Theorem**: Let $a$, $b$, $c$ be terms of a linear ordered type $X$.\nThen $\\max(a, b) \\le \\max(a, \\max(b,c))$.\n\n**Proof**:\nIt suffices to prove $a \\le \\max(a, \\max(b,c))$ and to prove $b \\le \\max(a, \\max(b,c))$.\n\n1. We show $a \\le \\max(a, \\max(b,c))$ by the fact that a maximum of two numbers is at least\nthe first number.\n\n2. We show $b \\le \\max(a, \\max(b,c))$ as follows. Note that\n\\begin{align}\nb &\\le \\max(b,c) & & \\text{[a maximum of two numbers is at least the first number]}\\\\\\\\\n&\\le \\max(a,\\max(b,c)). & & \\text{[a maximum of two numbers is at least the second number]}\n\\end{align}\n\u220e\n", "This proof can be written in Lean. Note the use of proof by calculation.\n", "max a b \u2264 max a (max b c)\n", "lemma max_le_max_left (a b c : X) : max a b \u2264 max a (max b c) :=\nbegin\n  apply max_le,\n  { show a \u2264 max a (max b c), apply le_max_left,  },\n  { show b \u2264 max a (max b c), \n    calc\n    b \u2264 max b c           : by apply le_max_left\n    ... \u2264 max a (max b c) : by apply le_max_right, },\nend\n", "## Task\nProve that $\\max(a,b) \\le \\max(b,a)$. You will need to use `max_le`, `le_max_right`, and\n`le_max_left`.\n", "$\\max(a,b) \\le \\max(b,a)$.\n", "end exlean -- hide", "import reals.max_le -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 13: Associativity of maximum\n", "variables {X : Type*} [linear_order X] -- hide\n", "In this challenging level, you will prove the associativity of maximum. That is, you will prove\n$$\n\\max(\\max(a,b), c) = \\max(a,\\max(b,c)).\n$$\n", "As another example (which may help in your proof), we extract a result from the theorem you\nproved in the previous level.\n", "max a b = max b a\n", "lemma max_eq_max_swap (a b : X) : max a b = max b a :=\nbegin\n  apply le_antisymm,\n  { show max a b \u2264 max b a, apply max_le_max_swap, },\n  { show max b a \u2264 max a b, apply max_le_max_swap, },\nend\n", "## Task\nProve that $\\max(\\max(a,b), c) = \\max(a,\\max(b,c))$, for all $a$, $b$, $c$ terms in a linear\nordered type $X$. You will benefit from understanding the theorems and reading the examples\nin the previous two levels.\n", "$\\max(\\max(a,b), c) = \\max(a,\\max(b,c))$\n", "end exlean -- hide", "import reals.max_le -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 14: Sets without an upper bound\n", "variables {X : Type*} [linear_order X] -- hide\n", "The maximum function can be used profitably to show that a given set has no upper bound.\n\n**Theorem**: Let $S$ be the set of rational numbers $x$ such that $x^2 > 1$. Then\n$S$ is not bounded above.\n\n**Proof**: Suppose, for a contradiction, that $S$ has an upper bound. Let $u$ be this\nupper bound. Let $x := \\max(2,u + 1)$.\nBy properties of maximum, we have $2 \\le x$ and $u + 1 \\le x$. From these, one can\nshow $x \\in S$, whence $x \\le u$. But this contradicts $u + 1 \\le x$. \u220e\n", "We give this proof below in Lean. The only tricky part of the Lean translation is deducing $x ^ 2 > 1$\nfrom $2 \\le x$. For this, we use the result `sq_le_sq_of_nonneg_of_le`\nthis proves `a ^ 2 \u2264 b ^ 2` given `a \u2264 b` and `0 \u2264 a`\n", "/- Axiom : sq_le_sq_of_nonneg_of_le (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) :\na ^ 2 \u2264 b ^ 2 \n-/\nlemma sq_le_sq_of_nonneg_of_le {R : Type*} {a b : R} [linear_ordered_ring R] \n(h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) : a ^ 2 \u2264 b ^ 2 :=\nsq_le_sq' (le_trans (neg_le_neg h\u2081) (le_trans (neg_nonpos.mpr h\u2082) h\u2082 )) h\u2081\n", "Here is a protypical application of the result.\n", "example (a b : \u211a) (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 a) : a ^ 2 \u2264 b ^ 2 :=\nbegin\n  apply sq_le_sq_of_nonneg_of_le,\n  { show a \u2264 b, from h\u2081 },\n  { show 0 \u2264 a, from h\u2082 },\nend\n", "With this in hand, we move on to our Lean proof.\n", "example : \u00ac(bounded_above {x : \u211a | x ^ 2 > 1}) :=\nbegin\n  let S := {x : \u211a | x ^ 2 > 1},\n  assume h : bounded_above S,\n  given h : \u2203 (u : \u211a), is_upper_bound S u,\n  rcases h with \u27e8u, h\u2082 : is_upper_bound S u\u27e9,\n  let x := max 2 (u + 1),\n  have h\u2083 : 2 \u2264 x, apply le_max_left,\n  have h\u2084 : u + 1 \u2264 x, apply le_max_right,\n  have h\u2085 : x  ^ 2 \u2265 2 ^ 2,\n  { apply sq_le_sq_of_nonneg_of_le,\n    { show 2 \u2264 x, linarith, },\n    { show (0 : \u211a) \u2264 2, linarith }, },\n  have h\u2086 : x \u2208 S,\n  { show x ^ 2 > 1, linarith, },\n  have h\u2086 : x \u2264 u, from h\u2082 _ h\u2086,\n  show false, linarith,\nend\n", "## Task\nLet $S$ be the set of rational numbers $x$ for which $(x + 1)^2 > 12$.\nBy adapting the proof above, show that $S$ has no upper bound.\n", "Let $S$ be the set of rational numbers $x$ for which $(x + 1)^2 > 12$.\nThen $S$ is not bounded above.\n", "end exlean -- hide", "import reals.max_assoc -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 15: The supremum of a union\n", "variables {X : Type*} [linear_order X] -- hide\n", "## Task\nIn this challenging level, your task is to show that the supremum of a\nunion of two sets is the maximum of their suprema.\n", "\nStart by using uniqueness of supremum. This leaves you with the goal of proving that\n$\\max(u,v)$ is a supremum of $S \\cup T$. That is, to prove\n$\\max(u,v)$ is an upper bound of $S \\cup T$ and that $S\\cup T$ has no smaller upper bound\nthan $\\max(u,v)$.\n```\n  apply sup_unique h\u2083,\n  show is_sup (S \u222a T) (max u v),\n  split,\n  { show is_upper_bound (S \u222a T) (max u v),\n    sorry, },\n  { show no_smaller_upper_bound (S \u222a T) (max u v),\n    sorry, },\n```\n", "A proof template", "Remember the results `subset_union_left` and `subset_union_right` from \nthe Sets world. These show `S \u2286 S \u222a T` and `T \u2286 S \u222a T`, respectively.\n", "Useful results on sets", "variables {S T : set X} {u v w : X} -- hide\n", "Let $S$ and $T$ be sets with suprema. Then $\\sup(S \\cup T) = \\max(\\sup(S ), \\sup (T))$\n", "end exlean -- hide", "import reals.suprema -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 16: Supremum challenge\n", "variables  {X : Type*} [preorder X] -- hide\n", "## Task\n\nLet $T$ be the set of rational numbers $x$ such that $x^2 < 1$.\nShow that $1$ is a supremum of $T$.\n\nThis is a somewhat challenging level.\n", "\nRecall that if `h\u2081 : a < b` and `h\u2082 : 0 < a`, then\n`sq_lt_sq_of_pos h\u2081 h\u2082` is a proof of `a ^ 2 < b ^ 2`.\n", "A helpful result", "namespace sup2 -- hide\n", "def T := {x : \u211a | x ^ 2 < 1}\n", "Let $T$ be the above set. Then 1 is a supremum of $S$.\n", "end sup2 -- hide\n", "end exlean -- hide", "import library.real_field tactic.modded tactic.linarith -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 17: Completeness\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field -- hide\n", "The type of real numbers, $\\mathbb R$ has all the 'algebraic' properties of the \ntype $\\mathbb Q$ of rational numbers (for example, associativity of addition,\nmultiplicative inverses for non-zero numbers, etc.). It also shared the\norder properties of $\\mathbb Q$ (for example if $a < b$ and $c < d$< then $a + b < c + d$).\n\nAdditionally, the type $\\mathbb R$ has the *completeness property*: every non-empty set of real\nnumbers that has an upper bound has a supremum.\n", "example (S : set \u211d) (h\u2081 : S.nonempty) (h\u2082 : bounded_above S) : has_sup S :=\nbegin\n  from completeness h\u2081 h\u2082,\nend\n", "has_sup S\n", "## Task\n\nSuppose $S$ and $T$ are sets of real numbers. Suppose $S$ is non-empty,\nthat $T$ has a supremum, and that $S \\subseteq T$. Show that $S$ has\na supremum.\n", "Recall the result `is_upper_bound_of_is_upper_bound_of_subset`\nfrom a previous level.\n", "A useful result", "variables {S T : set \u211d} -- hide\n", "Suppose $S$ and $T$ are sets of real numbers. Suppose $S$ is non-empty,\nthat $T$ has a supremum, and that $S \\subseteq T$. Then $S$ has\na supremum.\n", "end exlean -- hide", "import reals.completeness -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 18: The Archimedean property\n\nThe Archimedean property of $\\mathbb R$ asserts that for every real\nnumber $x$, there exists a natural number $n$ such that $x < n$.\n\nThis can be proved using the completeness property. Here is a sketch proof.\n\n**Proof sketch**: Let $x$ be a real number. We want to prove that\nthere exists a natural number $n$ such that $x < n$. Suppose, for a\ncontradiction, that for all natural numbers $n$, we have $n \\le x$.\nLet $S$ be the set of all real numbers $n$ such that $n$ is a natural number\nand $n \\le x$. Then (by our assumption), every natural number is in $S$.\n\nIn particular, $0 \\in S$, so $S$ is non-empty.\n\nOne can show that $S$ is bounded above (by $x$).\n\nThus, by the completness property of $\\mathbb R$, we deduce that $S$\nhas a supremum. Let $u$ be this supremum.\n\nOne may show that $u - 1$ is an upper bound of $S$. This contradicts\nthe assumption that there is $S$ has no upper bound smaller than $u$. \u220e\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nYour task is to prove the Archimedean property of $\\mathbb R$ using Lean.\nDo this by fleshing out the skeleton proof below.\n\nThe informal proof above glosses over some serious difficulties. One such difficulty is\nthe fact the quantities (such as $n$) play dual roles as natural numbers and as real \nnumbers. This is in evidence in the definition of $S$ above.\n\nIn the skeleton Lean proof, the set $S$ is defined to be the\nset of all real numbers $m$ such that for some natural number $n$, $m = n$ and $n \\le x$.\n", "For every real\nnumber $x$, there exists a natural number $n$ such that $x < n$.\n", "end exlean -- hide", "import reals.archimedean -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 19: Arbitrarily small reciprocals of natural numbers\n\nA corollary (simple consequence) of the Archimedean property is that there are arbitrarily\nsmall reciprocals of natural numbers.\n\nThat is, given any real number $\\varepsilon > 0$, there exists a non-zero natural number $n$\nsuch that $1 / n < \\varepsilon$.\n\nThis result is very important for proofs regarding convergence of sequences of real numbers.\n", "**Proof outline**: By the completeness property, there exists an integer $n$ such that\n$1/\\varepsilon < n$. We'll show $n\\ne 0$ and $1 / n < \\varepsilon$.\nBy assumption, $\\varepsilon > 0$, so $0 < 1 / \\varepsilon$. But $1 / \\varepsilon < n$, so\n$0 < n$. It follows that $n \\ne 0$.\n\nIt remains to show $1 / n < \\varepsilon$. Equally (as $0 < n$), to show $1 / \\varepsilon < n$, which\nwe have already shown. \u220e\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nComplete the Lean proof below. You should only need one line.\n\nThe proof contains  theorems\nyou have not seen before. You need not learn these theorems, but\nyou may wish to investigate their effects via the Lean Infoview\npane in the top-right of this window.\n", "variable {t : \u211d} -- hide\n", "For every positive real number $t$, there exists a positive natural number $n$ such that\n$1/n < t$.\n", "end exlean -- hide", "import reals.small_reciprocals -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 20: An arbitrarily small non-negative number is zero\n\nIn the last level, we showed that for every positive real number $\\varepsilon$,\nthere is a non-zero natural number $n$ such that $1/n < \\varepsilon$.\n\nUsing this result, you will prove that if $a$ is a non-negative real number\nsuch that $a < \\varepsilon$ for every positive real number, then $a = 0$.\n", "**Proof outline**:\nWe know $a < 0$ or $a = 0$ or $0 < a$. Consider each case separately.\n1. Suppose $a < 0$, But we've assumed $0 \\le a$. This is a contradiction.\n2. Suppse $a = 0$. This is precisely what we wished to prove.\n3. Suppose $0 < a$. By the theorem from the previous level, we have\na natural number $n$ such that $n \\ne 0$ and $1/n < a$. From this,\nit is possible to derive a contradiction, the remaining details of this\nargument, gentle reader, are left for your amusement. \u220e \n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nComplete the Lean proof below. The proof contains some tactics and theorems\nyou have not seen before. You need not learn these tactics and theorems but\nyou may wish to investigate their effects via the Lean Infoview\npane in the top-right of this window.\n", "If $a$ is a non-negative real number\nsuch that $a < \\varepsilon$ for every positive real number, then $a = 0$.\n", "end exlean -- hide", "import reals.arbitrarily_small_number_is_zero -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 21: Absolute values\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "Let $a$ be a real number (more generally a term in a linear ordered type). The\n*absolute value* of $a$, written $|a|$ is defined to be $\\max(a,-a)$.\n\nThus $|5| = \\max(5,-5) = 5$, while $|-10| = \\max(-10,-(-10)) = 10$.\n\nAs with the maximum function, the absolute value function is crucial to the study of\nreal analysis.\n\nIn this level, we'll prove the following theorems.\n\n* If $|a| \\le b$, then $a \\le b$.\n\n* If $|a| \\le b$, then $-b \\le a$.\n", "Here is a Lean proof of the second theorem, which we prove by appeal to our results on\nmaxima, together with results on negating inequalities and equations.\n", "-b \u2264 a\n", "variables {a b : \u211d} -- hide\n", "lemma neg_le_of_abs_le (h : |a| \u2264 b) : -b \u2264 a :=\nbegin\n  given h : max a (-a) \u2264 b,\n  calc\n  -b \u2264 -(max a (-a)) : by {rw neg_le_neg_iff, from h }\n  ... \u2264 -(-a)        : by {rw neg_le_neg_iff, apply le_max_right }\n  ... = a            : by rw neg_neg,\nend\n", "## Task\nProve that if $a$ and $b$ are real numbers and if $|a| \\le b$, then $-b \\le a$.\nThis is easier than the proof above. Other than the given hypothesis, you should\nonly need to use one result on maxima.\n", "If $a$ and $b$ are real numbers and if $|a| \\le b$, then $a \\le b$.\n", "end exlean -- hide", "import reals.absolute_values -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 22: A condition for boundedness\n\nUsing the Archimedean property, you will show that a set $S$ of real numbers is\nbounded if and only if there exists a natural number $M$ such that\n$|x| \\le M$, for all $x \\in S$.\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nComplete the Lean proof below. You'll need results on maxima and absolute\nvalues. You will need the Archimedean property of $\\mathbb R$.\n", "variable {S : set \u211d} -- hide\n", "Let $S$ be a set of real numbers. The set $S$ is bounded if and only if\nthere exists a natural number $M$ such that for all $x \\in S$,\n$|x| \\le M$.\n", "end exlean -- hide", "import reals.bounded_iff -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 23: Existence of a square root of 2: finding a supremum \n\nIt is well known to school students that there is no rational number whose square is $2$.\nIn the next few levels, we will prove that there *is* a real number whose square is $2$.\nThese levels are somewhat challenging.\n\nThe idea is to describe a set whose supremum is a square root of $2$.\n", "**Proof outline**:\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$.\nClearly $S$ is non-empty and bounded above, thus it has a supremum. Call this $u$\n\nWe'll show $u^2 = 2$ by showing $u^2 \\le 2$ and $2 \\le u^2$.\n\nTo show $u^2 \\le 2$, assume, for a contradiction, that $2 < u^2$.\nOn this assumption, one can find an upper bound $t$ of $S$ such that $t < u$,\ncontradicting the assumption that $S$ has no smaller upper bound that $u$.\n\n\nTo show $2 \\le u^2$, assume, for a contradiciton, that $u ^ 2 < 2$.\nOn this assumption, one can find an element $x$ of $S$ such that $u < x$,\ncontradicting the assumption that $u$ is an upper bound of $S$.\n\u220e \n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## A useful result\n\nIn the proof below, you will need the result that if $0 \\le a$ and $a < b$, then\n$a^2 < b^2$. We call this result `sq_lt_sq_of_nonneg_of_lt`.\n", "a ^ 2 < b ^ 2 :=\n", "example (a b : \u211d) (h\u2081 : a < b) (h\u2082 : 0 \u2264 a) : a ^ 2 < b ^ 2 :=\nbegin\n  from sq_lt_sq_of_nonneg_of_lt h\u2081 h\u2082,\nend\n", "## Task\nLet $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$.\nShow that $S$ has a supremum.\n\nRemember to use the `norm_num` tactic for purely numerical results and the\n`linarith` tactic for arithemtic results involving variables.\n", "Let $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$. Then $S$ has a\nsupremum.\n", "end exlean -- hide", "import reals.sqrt2_supremum -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 24: Positivity of upper bound for the square root of 2 set\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nContinuing from the previous level, let\n$S$ be the set of non-negative real numbers such that $x ^ 2 < 2$.\n\nSuppose $u$ is an upper bound of $S$. Your task is to prove that $u$ is positive.\n\nI suggest a proof by contradiction. The Lean fragment below\nstarts your proof.\n", "Let $S$ be the set of non-negative real numbers such that $x ^ 2 < 2$. Suppose $u$ is an upper bound of $S$.\nThen $u$ is positive.\n", "end exlean -- hide", "import reals.sqrt2_set_ub_pos -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 25: The supremum squared is at most 2\n\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nIn this level, you will show $u \\le 2$. The idea is to use assume that\n$2 < u ^2$ and thereby derive a contradiction. In particular, you will show that there is an upper bound $y$,\nof $S$ that is smaller than $u$.\n\nThe upper bound $y$ will take the form $u - 1 /n$ where $n$ is a natural number chosen so that\n$1/n < (u ^ 2 - 2) / (2u)$. The existence of a such a natural number $n$ is guaranteed by the corollary to\nthe Archimedean property of $\\mathbb R$.\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "namespace sqrt2_lemmas\nlemma goo {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)\n(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < u ^ 2 - (2 * u) * (1 / (n : \u211d)) :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,\n  suffices : (2 * u) * (1 / (n : \u211d)) < u ^2 - 2, linarith,\n  suffices : (2 * u) * (1 / (n : \u211d)) < (2 * u) * ((u ^2 - 2) / (2 *u)),\n  { have h\u2083 : (2 * u) * ((u ^2 - 2) / (2 *u)) =  u ^ 2 - 2,\n    { rw mul_comm, rw div_mul_cancel, linarith, },\n    rwa \u2190h\u2083, },\n  apply mul_lt_mul_of_pos_left,\n  { from h, },\n  { show 0 < 2 * u, linarith, },\nend\nlemma boo {n : \u2115} (u : \u211d) (hne : n \u2260 0) : -- don't change this\nu ^ 2 - (2 * u) * (1 / (n : \u211d))  \u2264 (u - 1 / (n : \u211d))^2 :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have : 0 < 1 / (n : \u211d), from one_div_pos.mpr npos,\n  rw (show \u2200 (v : \u211d), (u - v)^2 = u ^2 - (2 * u) * v + v ^ 2, from \u03bb v, by ring ),\n  suffices : (u ^ 2 - 2 * u * (1 / \u2191n)) + 0 \u2264 (u ^ 2 - 2 * u * (1 / \u2191n)) + (1 / \u2191n) ^ 2,\n  { linarith, },\n  apply add_le_add,\n  { reflexivity, },\n  { rw [pow_two],\n    apply le_of_lt,\n    apply mul_pos; assumption, },\nend\nend sqrt2_lemmas\nlemma le_of_sq_le_sq_of_nonneg {a b : \u211d} (h\u2081 : 0 \u2264 b) (h\u2082 : a ^ 2 \u2264 b ^ 2) :\na \u2264 b :=\nbegin\n  by_contra k,\n  given k : \u00ac(a \u2264 b),\n  have h\u2083 : b < a, linarith,\n  have : b * b < a * a,\n  { from mul_self_lt_mul_self h\u2081 h\u2083, },\n  linarith,\nend\nlemma two_lt_sub_one_div_sq_of_archi {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : 0 < u)\n(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d))^2 :=\nbegin\n  have gtr := sqrt2_lemmas.goo hne upos h,\n  have er := sqrt2_lemmas.boo u hne,\n  linarith,\nend\nlemma nonneg_sub_one_div_nat_of_pos {u : \u211d} {n : \u2115} (hne : n \u2260 0) (upos : (0 : \u211d) < u) \n(usqgt : 2 < u ^ 2)\n: (0 : R) \u2264 u - 1 / (n : \u211d) :=\nbegin\n  by_contra p, \n  have : u \u2264 1 / (n : \u211d), linarith,\n  have h\u2082 : 1 \u2264 (n : \u211d),\n  { rwa [\u2190nat.cast_one, nat.cast_le, nat.one_le_iff_ne_zero], },\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero], },\n  have h\u2084 : 1 / (n : \u211d) \u2264 1 / (1 : \u211d),\n  { rwa one_div_le_one_div npos zero_lt_one, },\n  have h\u2085 : u \u2264 1 / (1 : \u211d), linarith,\n  rw (show 1 / (1 : \u211d) = 1, from div_one 1) at h\u2085,\n  have : u * u \u2264 1 * 1, from mul_le_mul h\u2085 h\u2085 (le_of_lt upos) zero_le_one,\n  linarith,\nend\n", "## Useful results\n\nIn your proof, you'll need a few results.\n", "(h : 1 / (n : \u211d) < (u ^2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d))^2 \n", "(usqgt : 2 < u ^ 2)\n: (0 : R) \u2264 u - 1 / (n : \u211d) \n\n", "The result `two_lt_sub_one_div_sq_of_archi` proves $2 < (u - 1 /n)^2$ on the assumptions\n$n \\ne 0$, $0 < u$, and $1 / n < (u ^ 2 - 2) / (2  u)$.\n", "example (u : \u211d) (n : \u2115) (hne : n \u2260 0) (upos : 0 < u) (h : 1 / (n : \u211d) < (u ^ 2 - 2) / (2 * u)) :\n2 < (u - 1 / (n : \u211d)) ^ 2:=\nbegin\n  from two_lt_sub_one_div_sq_of_archi hne upos h,\nend\n", "The result `nonneg_sub_one_div_nat_of_posi` proves $0 \\le u - 1/n$ on the assumptions\n$n \\ne 0$, $0 < u$, and $2 < u^2$.\n", "example (u : \u211d) (n : \u2115) (hne : n \u2260 0) (upos : 0 < u) (usqgt : 2 < u ^ 2) : 0 \u2264 u - 1 / (n : \u211d) :=\nbegin\n  from nonneg_sub_one_div_nat_of_pos hne upos usqgt,\nend\n", "## Task\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nYour task is to show $u^2 \\le 2$ by completing the proof sketched out below. Use the lemmas mentioned above\nand any relevant lemmas from previous levels.\n", "Let $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$\nbe a supremum of $S$. Then $u^2 \\le 2$.\n", "end exlean -- hide", "import reals.sqrt2_set_sup_sq_le_2 -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 26: The supremum squared is at least 2\n\nYou will now prove the other direction of the inequality you proved in the previous level.\n\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nIn this level, you will show $2 ^ \\le u^2$. You'll start by assuming $u ^2 < 2$, for a contradiction.\n\nIndeed, you'll find that $u$ is not an upper bound of $S$. To do this, you'll take $y$ to be $u + 1 / n$,\nwhere $n$ is a natural number chosen so that $1 / n < (2 - u ^ 2) / (2  u + 1)$. You can then prove that $y \\in S$,\nand that $u < y$.\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "namespace sqrt2_lemmas\nlemma add_sq_le_of_pos_of_ne_zero {n : \u2115} {u : \u211d} (hne : n \u2260 0) :\n(u + 1 / (n : \u211d))^2 \u2264 \nu ^ 2 + (1 / (n : \u211d)) * (2 * u + 1) :=\nbegin\n  have npos : (0 : \u211d) < n,\n  { rwa [\u2190nat.cast_zero, nat.cast_lt, pos_iff_ne_zero] }, \n  suffices : u ^2 + (2 * u) * (1 / (n : \u211d)) + (1 / (n : \u211d)) ^ 2 \u2264 \n    u ^ 2 + (1 / (n : \u211d)) * (2 * u + 1),\n  { rwa (show \u2200 (v : \u211d), (u + v)^2 = u ^2 + (2 * u) * v + v ^ 2, from \u03bb v, by ring ), },\n  rw add_assoc,\n  apply add_le_add_left,\n  rw [mul_add, mul_one],\n  have hnge1 : 1 \u2264 (n : \u211d),\n  { rwa [\u2190nat.cast_one, nat.cast_le, nat.one_le_iff_ne_zero], },\n  have : 1 / (n : \u211d)^2 \u2264 1 / (n : \u211d),\n  { rw one_div_le_one_div _ npos ,\n    { show (n : \u211d) \u2264 (n : \u211d) ^2,\n      suffices : (n : \u211d) * 1 \u2264 n * n,\n      { rw mul_one at this,\n        rwa [pow_two], },\n      from mul_le_mul_of_nonneg_left hnge1 (le_of_lt npos), },\n    { rw [pow_two],\n      apply mul_pos npos npos, } },\n  apply add_le_add,\n  { linarith },\n  { rwa one_div_pow 2, },\nend\nlemma sq_add_lt_two_of_archi {n : \u2115} {u : \u211d} (upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)):\nu ^2 + 1 / (n : \u211d) * (2*u + 1) < 2 :=\nbegin\n  suffices h\u2082 : u ^2 + 1 / (n : \u211d) * (2*u + 1) < u ^2 + (2 - u^2),\n  { rwa (show u ^2 + (2 - u^2) = 2, by linarith) at h\u2082,  },\n  apply add_lt_add_left,\n  have : 2 - u ^ 2 = ( (2 - u^2) / (2 * u + 1)) * (2 * u + 1),\n  { rw div_mul_cancel,\n    linarith,  },\n  rw this,\n  apply mul_lt_mul_of_pos_right,\n  { from h, },\n  { linarith, }\nend\nend sqrt2_lemmas\nlemma add_sq_lt_two_of_archi {n : \u2115} {u : \u211d} (hne : n \u2260 0)\n(upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)) :\n(u + 1/(n : \u211d)) ^2  < 2 :=\nbegin\n  from lt_of_le_of_lt\n    (sqrt2_lemmas.add_sq_le_of_pos_of_ne_zero hne)\n    (sqrt2_lemmas.sq_add_lt_two_of_archi upos h)\nend\n", "## A useful result\n\nYou'll need the result `add_sq_lt_two_of_archi`. This proves $(u + 1 /n) ^2 < 2$, given the\nassumptions $n \\ne 0$, $0 < u$, and $1 / n < (2 - u ^ 2) / (2 u + 1)$.\n\nHere is an example.\n", "example (n : \u2115) (u : \u211d) (hne : n \u2260 0) (upos : 0 < u) (h : 1/(n : \u211d) < (2 - u ^ 2) / (2 * u + 1)) :\n(u + 1/(n : \u211d)) ^2  < 2 :=\nbegin\n  from add_sq_lt_two_of_archi hne upos h,\nend\n", "## Task\nLet $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$ be a supremum of $S$.\n\nYour task is to show $2 \\le u ^ 2$. I give you the first few lines of the proof. You'll need to use\nthe lemma `add_sq_lt_two_of_archi` and adapt the proof given in the previous level.\n\nNote that the structure of this proof will be different (indeed somewhat simpler) than that of the\nproof in the previous level. In this level, you'll be deriving a contradiction from the fact that\n$u$ is an upper bound of $S$. In the previous level, you needed to use the more complicated fact that\n$S$ has no smaller upper bound than $u$.\n", "Let $S$ be the set of real numbers $x$ such that $0 \\le x^2 < 2$. Let $u$\nbe a supremum of $S$. Then $2 \\le u ^2$.\n", "end exlean -- hide", "import reals.sqrt2_set_sup_sq_ge_2 -- hide\n", "namespace exlean -- hide\n", "# Real Numbers\n\n## Level 27: Proof of existence of a square root of 2\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field set -- hide\n", "## Task\nYou've done all the hard work. It now remains to combine the results of the previous\nfew levels to prove the exists of a square root of 2!\n", "There is a real number $u$ such that $u ^ 2 = 2$.\n", "end exlean -- hide", "Sequences", "import reals.sqrt2_exists -- hide\n", "namespace exlean -- hide\n", "variables {R : Type*} [myreal_field R] -- hide\n", "open_locale myreal -- hide\n", "open myreal_field -- hide\n", "# Sequences\n\n## Level 1: Convergence of a sequence\n\nA *sequence of real numbers* (henceforth a *sequence*) is simply \na function from $\\mathbb N$ to $\\mathbb R$.\n\nLet $a$ be a sequence. For $a$ to converge to a real number $w$\nmeans that:\n$$\n\\forall (\\varepsilon > 0), \\exists (N : \\mathbb N),\n\\forall (n > N), |a(n) - w |< \\varepsilon.\n$$\n\nThis is shorthand for:\n$$\n\\forall (\\varepsilon : \\mathbb R), \\varepsilon > 0 \\to\n\\exists (N : \\mathbb N), \\forall (n : \\mathbb N), \nn > N \\to |a(n) - w |< \\varepsilon.\n$$\n", "Here is the definition in Lean.\nNote that `\u03b5` is typed `\\e`.\n", "def converges_to (a : \u2115 \u2192 \u211d) (w : \u211d) :=\n  \u2200 (\u03b5 > 0), \u2203 (N : \u2115), \u2200 (n > N), |a(n) - w| < \u03b5\n", "Let $f$ be the sequence defined by $f(n) := 5$. We'll show that\n$f$ converges to $5$.\n", "namespace const_example -- hide\n", "def f (n : \u2115) : \u211d := 5\n", "-- hide\n", "example : converges_to f (5 : \u211d) :=\nbegin\n  assume (\u03b5 : \u211d) (\u03b5pos : \u03b5 > 0),\n  use 10,  -- There's nothing special about 10. \n  assume (n : \u2115) (h : n > 10),\n  show |f(n) - (5 : \u211d)| < \u03b5,\n  calc\n  | 5 - 5 | = 0 : by simp\n  ... < \u03b5       : \u03b5pos\nend\n", "end const_example -- hide\n", "## Task\n\nWith $f$ as above, suppose that $g : \\mathbb N \\to \\mathbb N$\nis a function. By adapting the argument above,\nprove that $f \\circ g$ converges to $5$.\n", "namespace const_example -- hide\n", "With $f$ as above, suppose that $g : \\mathbb N \\to \\mathbb N$\nis a function. Then $f \\circ g$ converges to $5$.\n", "end const_example -- hide\n", "end exlean -- hide", "Strong Induction", "import tactic.linarith tactic.ring_exp tactic.modded strong_induction.basic -- hide\n", "# Strong Induction\n\n## Level 1: Strong induction\n\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "(h\u2081 : P(0))\n(h\u2082 : \u2200 (k : \u2115), (\u2200 m : \u2115, m \u2264 k \u2192 P(m)) \u2192 P (k + 1)) :\n\u2200 (n : \u2115), P(n)\n", "open nat -- hide\n", "Strong induction is used to prove that a predicate $P$ holds for every natural number $n$.\nTo apply strong induction you need to prove:\n* [Base case] $P(0)$.\n* [Inductive step] For all $k : \u2115$, $P(k + 1)$ follows from the inductive hypothesis\nthat for all $m : \u2115$, if $m \\le k$, then $P(m)$ holds.\n", "### Strong induction example\n\nA sequence $f : \u2115 \u2192 \u2124$ is defined by $f(0) \u2254 2$, $f(1) \u2254 8$, and\n$f (n + 2) \u2254 8 f(n + 1) - 15 f(n)$.\n", "By strong induction, we'll prove that $f(n) = 3^n + 5^n$, for every natural number $n$.\n\n\nTo start, we give a handwritten proof. In a less formal proof, there may be multiple\nbase cases. In the proof below, there is only one base case. However,  the induction step\nproceeds by considering separately the cases where $k = 0$ and where $k = p + 1$ for a\nnatural number $p$. The $k=0$ case corresponds to the 'additional base case' of proving\n$P(1)$ in a less formal proof.\n", "**Proof**:\n\nLet $P$ be the predicate defined so that\n$P(x)$ is $f(x) = 3 ^ x + 5 ^ x$.\n\n* Base case: We must show $P(0)$, namely, $f(0) = 3^0 + 5^0$.\n  This is true by definition of $f$.\n\n* Inductive step: Assume $k$ is a natural number. Assume\n  the inductive hypothesis: that for all natural numbers $m$, if\n  $m \\le k$, then $P(m)$.\n  We must show $P(k + 1)$.\n\n  Now $k$ is either $0$ or is of the form $p + 1$, for some natural\n  number $p$. Consider both cases separately.\n\n    * In the case where $k$ is $0$, we must show $P(0 + 1)$. Equally, that\n      $f(1) = 3^1 + 5 ^ 1$. This is true by definition of $f$.\n\n    * In the case where $k$ is $p+1$, the inductive hypothesis asserts\n      that for all natural numbers $m$, if $m \\le p + 1$, then\n      $P(m)$. We must show $P((p + 1) + 1)$.\n\n      Restating this, we know that for all natural numbers $m$,\n      if $m \\le p + 1$, then $f(m) = 3^m + 5^m$.\n\n      We must show $f(p + 2) = 3^{p + 2} + 5^{p + 2}$.\n\n      But,\n      $$\n      \\begin{align}\n      f(p + 2) &= 8f(p+1) - 15f(p) && \\text{[by definition of $f$]} \\\\\\\\\n      &= 8(3^{p+1}+5^{p+1}) - 15f(p) && \\text{[by the induction hypothesis, as $p + 1 \\le p + 1$]} \\\\\\\\\n      &= 8(3^{p+1}+5^{p+1}) - 15(3^p + 5^p) && \\text{[by the induction hypothesis, as $p \\le p + 1$]} \\\\\\\\\n      &= (24-15)3^p + (40 - 15)5^p && \\\\\\\\\n      &= 3^{p+2} + 5^{p+2}, &&\n      \\end{align}\n      $$\n\n      as required. \u220e\n", "### Strong induction in Lean\n\nAs an example of strong induction in Lean, we'll prove the result above.\nWe begin with a Lean definition of the function $f$.\n", "namespace strong_sequence -- hide\n", "def f : \u2115 \u2192 \u2124 \n| 0 := 2\n| 1 := 8\n| (n + 2) := 8 * f(n + 1) - 15 * f(n)\n", "The above uses a defintion by *pattern matching* to construct a function `f : \u2115 \u2192 \u2124` to that\n`f(0) = 2`, `f(1) = 8`, and `f(n + 2) = 8 * f(n + 1) - 15 * f(n)`, for every natural number `n`.\n\nIn the Lean proof below, we start by definining the predicate `P` as an anonymous (or 'lambda') function.\nFor example `\u03bb x, x ^ 2` is the function that sends `x` to `x ^ 2`. We define `P` to be the predicate\nthat takes `x` to the proposition `f(x) = 3 ^ x + 5 ^ x`. Note `\u03bb` is typed `\\la` in Lean.\n\nHaving defined `P`, we prove both the base case (which I've called `base`) and the inductive step\n(which I've called `ind_step`). To conlude, we apply strong induction to these two hypotheses. \n\nIn the inductive step, we introduce the induction variable `k` and the induction hypothesis `ih`.\nNext, in a procedure common to proofs by induction, we consider cases for `k`.\n\nAs `k` is a natural number, either `k = 0` or `k` is the successor of some natural number `p`.\nIn the later case, we make things easy for ourselves by replacing `succ p` with `p + 1`.\n\nNote that we apply the induction hypothesis twice: once to `p + 1` and again to `p`.\n", "`ring_exp` is used to prove equations involving variable exponents.\n\n### Example\n```\nexample (x : \u2115) : \n  3 ^ x + 3 ^ (x + 1) = 4 * 3 ^ x :=\n  by ring_exp\n```\n", "example (x : \u2115) : 3 ^ x + 3 ^ (x + 1) = 4 * 3 ^ x := by ring_exp\nexample (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,                    -- This is comment. It is ignored by Lean.\n  { show f(0) = 3 ^ 0 + 5 ^ 0,        -- Show P(0)\n    refl, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show f(1) = 3 ^ 1 + 5 ^ 1,      -- Show P(1)\n      refl, },\n    { given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 (f(m) = 3 ^ m + 5 ^ m),\n      show f(p + 2) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      calc\n      f(p + 2) = 8 * f(p + 1) - 15 * f(p)     : by refl\n      ... = 8*(3^(p + 1) + 5^(p+1)) - 15*f(p) : by rw ih (p + 1) (by linarith)\n      ... = 8*(3^(p + 1) + 5^(p+1)) -\n              15*(3^ p + 5 ^ p)               : by rw ih p (by linarith)\n      ... = 3 ^ (p + 2) + 5 ^ (p + 2)         : by ring_exp }, },\n  apply strong_induction base ind_step,\nend\n", "The Lean proof is virtually a direct translation of the handwritten proof. There are two points\nworth noting.\n\n1.  The induction hypothesis, applied to a natural number `m`, requires a proof that `m \u2264 p + 1`.\n    In the proof by calculation, we consider the application `ih (p + 1) (by linarith)`. Here,\n    `p + 1` takes the place of `m` and `(by linarith)` automatically provides a proof of the\n    desired input `p + 1 \u2264 p + 1`. Likewise, in `ih p (by linarith)`, the text `(by linarith)`\n    produces a proof of `p \u2264 p + 1`.\n2.  The tactic `ring_exp` is used to do the 'algebra' in the last step. It can prove many\n    equations that involve variable exponents.\n", "### A backward alternative\n\nIn both the handwritten proof and the Lean proof, we ended with having to prove\n$f(p + 2) = 3^{p + 2} + 5^{p + 2}$ on the inductive hypothesis that for all natural numbers $m$,\nif $m \\le p + 1$, then $f(m) = 3^m + 5^m$. We did this by calculation.\n\nAn alternative is a backward proof, as below\n\n$$\n\\begin{align}\n&&      f(p + 2) &= 3^{p + 2} + 5^{p + 2}  && \\\\\\\\\n&\\iff & 8f(p + 1) - 15f(p) &= 3^{p + 2} + 5^{p + 2} && \\\\\\\n&\\iff & 8(3^{p + 1} + 5^{p + 1}) - 15f(p) &= 3^{p+2} + 5^{p+2} && \\text{[by the inductive hypothesis]}  \\\\\\\\\n&\\iff & 8(3^{p + 1} + 5^{p + 1}) - 15(3^p + 5^p) &= 3^{p+2} + 5^{p+2} && \\text{[by the inductive hypothesis]}  \\\\\\\\\n&\\iff & (24-15)3^p + (40-15)5^p &= 3^{p+2} + 5^{p+2}. &&\\text{[by algebra]}   \\\\\\\\\n\\end{align}\n$$\nThe last line is true by a simple numerical calculation.\n", "We can write much the same proof in Lean. To save clutter our Lean proof below includes only\nthe justifications and does not show all the equations proved thereby.\n", "example (n : \u2115) : f(n) = 3 ^ n + 5 ^ n :=\nbegin\n  let P := \u03bb x, f(x) = 3 ^ x + 5 ^ x, -- The predicate.\n  have base : P 0,                    -- The base case.\n  { show f(0) = 3 ^ 0 + 5 ^ 0,        \n    refl, },                          \n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show f(1) = 3 ^ 1 + 5 ^ 1,  \n      refl, },\n    { given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 (f(m) = 3 ^ m + 5 ^ m),\n      show f(p + 2) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      show 8 * f(p + 1) - 15 * f(p) = 3 ^ (p + 2) + 5 ^ (p + 2),\n      rw ih (p + 1) (by linarith),  -- Replace f(p + 1) with 3^(p + 1) + 5^(p + 1)\n      rw ih p (by linarith),        -- Replace f(p) with 3^p + 5^p\n      ring_exp, }, },               -- Complete the inductive step by algebra\n  apply strong_induction base ind_step,\nend\n", "### Task\n\nA sequence $g : \\mathbb{N} \\to \\mathbb{Z}$ is defined by $g(0) \u2254 11$, $g(1) \u2254 26$, and\n$g(n + 2) \u2254 5g(n + 1) - 6g(n)$.\n\n* By adapting either of the `calc` or backward proofs above, prove that\n  $g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n* Do the same thing by hand.\n", "def g : \u2115 \u2192 \u2124 \n| 0 := 11\n| 1 := 26\n| (n + 2) := 5 * g(n + 1) - 6 * g(n)\n", "$g(n) = 4 \\times 3 ^ n + 7 \\times 2 ^ n$, for each natural number $n$.\n", "end strong_sequence -- hide\n", "end exlean\n", "import tactic.linarith strong_induction.basic tactic.modded -- hide\n", "# Strong Induction\n\n## Level 2: Strong induction with a different base case\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "open nat -- hide\n", "Often we want to prove that a predicate holds for all sufficiently large natural numbers. Here,\nwe'll demonstrate that every natural number $n \\ge 2$ can be expressed in the form $n = 2 s + 3 t$\nfor natural numbers $s$ and $t$.\n\nOne approach to this is to think of the proof as involving strong induction where the base case\nis to prove the result for $n = 2$.\nThis approach requires creating a new and more general version of strong induction.\n\nInstead, our approach is to use the ordinary version of strong induction, but where the predicate\nasserts $c + 2 = 2 s + 3 t$. Clearly, to prove the result is to prove that this predicate holds\nfor *every* natural number.\n\n### An English-language proof\n\n**Theorem**: Every natural number $n \\ge 2$ can be expressed as $n = 2s + 3t$, for some\nnatural numbers $s$ and $t$.\n\n**Proof**: Let $n \\ge 2$ be a natural number. We must show there exist natural numbers $s$ and $t$\nsuch that $n = 2s + 3t$. But $n = c + 2$, for some natural number $c$. Thus, it suffices\nto prove there exists natural numbers $s$ and $t$ such that $c + 2 = 2s + 3t$.\n\nWe proceed by strong induction on $c$.\nLet $P$ denote the predicate defined so that $P(x)$ means there exists natural numbers $s$ and $t$\nsuch that $2 + x = 2s + 3t$.\n\n* Base case: we must show $P(0)$, that there exist integers $s$ and $t$ such that $0 + 2 = 2s + 3t$.\n  Clearly, taking $(s,t) = (1,0)$ suffices.\n\n* Inductive step: assume $k$ is a natural number. Assume the inductive hypothesis, that for\n  all natural numbers $m$, if $m \\le k$, then $P(m)$ holds. We must show $P(k + 1)$.\n\n  Now $k$ is either $0$ is has the form $p + 1$, for a natural number $p$. Consider both\n  cases separately.\n\n    * In the case where $k$ is $0$, we must show $P(0 + 1)$. That is, we must show\n      there exist natural numbers $s$ and $t$ such that $2 + 1 = 2s + 3t$.\n      Take $(s,t) = (0,1)$. Then the result is trivially true.\n    * In the case where $k$ is $p + 1$, the inductive hypothesis\n      states that for all natural numbers $m$, if $m \\le p + 1$, then $P(m)$ holds.\n      We must show $P(p + 2)$. That is, we must show there exist natural numbers $s$ and $t$\n      such that $2 + (p + 2) = 2s + 3t$.\n\n      As $p \\le p + 1$, we know $P(p)$ (from the inductive hypothesis). That is,\n      we know there exist natural numbers $x$ and $y$ such that $2 + p = 2x + 3y$.\n\n      But then,\n      $$\n      \\begin{align}\n      2 + (p + 2) &= (2 + p) + 2 \\\\\\\\\n      &= (2x + 3y) + 2 \\\\\\\\\n      &= 2(x + 1) + 3 y, \\\\\\\\\n      \\end{align}\n      $$\n      So we may take '$s$' to be $x + 1$ and '$t$' to be $y$. \u220e\n", "### A Lean proof\n\nTo begin the Lean proof, we convert the original problem, that of proving a result for all\n$n \\ge 2$, into a statement about all natural numbers $c$, where $n = c + 2$. \n\nTo translate between the original formulation and the new one, we use the result `le_iff_exists_add`.\nThis asserts `a \u2264 n` if and only if `\u2203 (c : \u2115), n = a + c`.\n", "example (n a: \u2115) : a \u2264 n \u2194 \u2203 (c : \u2115), n = a + c := le_iff_exists_add\n", "The remainder of the proof uses strong induction.\n", "example (n : \u2115) (h : 2 \u2264 n) : \u2203 (s t : \u2115), n = 2 * s + 3 * t :=\nbegin\n  rw le_iff_exists_add at h, -- These two lines adjust the predicate\n  rcases h with \u27e8c, rfl\u27e9,     -- for the different base case.\n  show \u2203 (s t : \u2115), 2 + c = 2 * s + 3 * t,\n", "  -- hide\n", "  let P := \u03bb x, \u2203 (s t : \u2115), 2 + x = 2 * s + 3 * t,\n  have base : P 0,\n  { show \u2203 (s t : \u2115), 2 = 2 * s + 3 * t,    -- Show P(0)\n    use [1, 0],\n    show 2 = 2 * 1 + 3 * 0, norm_num, },\n  have ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n  { assume k : \u2115,\n    assume ih : \u2200 (m : \u2115), m \u2264 k \u2192 P m,\n    show P(k + 1),\n    cases k with p,\n    { show \u2203 (s t : \u2115), 3 = 2 * s + 3 * t,  -- Show P(1)\n      use [0, 1],\n      show 3 = 3 * 0 + 3 * 1, norm_num, },\n    show P(p + 2),                          -- Show P(p + 2)\n    given ih : \u2200 (m : \u2115), (m \u2264 p + 1) \u2192 \u2203 (x y : \u2115), 2 + m = 2 * x + 3 * y,\n    have hpp : \u2203 (x y : \u2115), 2 + p = 2 * x + 3 * y, from ih p (by linarith),\n    rcases hpp with \u27e8x, y, hst : 2 + p = 2 * x + 3 * y\u27e9,\n    use [x + 1, y],\n    show 2 + (p + 2) = 2 * (x + 1) + 3 * y, linarith, },\n  apply strong_induction base ind_step,\nend\n", "Every natural number $n$ at least 8 can be expressed as $n = 3s + 5t$ for natural numbers $s$\nand $t$.\n", "end exlean -- hide", "import data.set.basic strong_induction.basic tactic.linarith tactic.modded -- hide\n", "# Strong Induction\n\n## Level 3: Minimal elements\n", "namespace exlean -- hide\n", "Let $S$ be a set of natural numbers. A natural number $n$ is said to be a _minimal element_ of $S$\nif $n \\in S$ and for every every $m \\in S$, $n \\le m$.\n", "example (n : \u2115) (S : set \u2115) (h : min_element n S ) :\nn \u2208 S \u2227 (\u2200 (m : \u2115), m \u2208 S \u2192 n \u2264 m) := h\n", "namespace min_element_example -- hide\n", "Let the function $f : \\mathbb N \\to \\mathbb N$ be given by $f(x) = 5 x + 7$ and let $T$ be the set\nof natural numbers $x$ for which $f(x) \\ge 400$.\n", "def f (x : \u2115) := 5 * x + 7\ndef T : set \u2115 := {x : \u2115 | f x \u2265 400}\n", "We'll show that $79$ is a minimal element of $T$. To do this, we split the target into two goals:\n1. to prove $79 \\in T$ and\n2. to prove that every element of $T$ is at least $79$.\n", "example : min_element 79 T :=\nbegin\n  split, \n  { show 5 * 79 + 7 \u2265 400,\n    norm_num, }, -- This follows by arithmetic.\n  { show \u2200 (m : \u2115), 5 * m + 7 \u2265 400 \u2192 79 \u2264 m,\n    assume m : \u2115,\n    assume h : m \u2208 T,\n    linarith, },\nend\n", "In the example above, we proved a `min_element` statement. In the next examples, we'll use\n`min_element` hypotheses.\n\nFirst, suppose $S$ is a set of natural numbers and that the natural number $x$ is a minimal\nelement of $S$. We can deduce that $x \\in S$.\n", "example (S : set \u2115) (x : \u2115) (h : min_element x S) : x \u2208 S :=\nbegin\n  from h.left,\nend\n", "Now suppose $S$ is a set of natural numbers and that $8$ is a minimal element of $S$.\nWe'll show that $8 \\le s$, for all $s \\in S$.\n", "example (S : set \u2115) (h : min_element 8 S) : \u2200 (s \u2208 S), 8 \u2264 s :=\nbegin\n  from h.right,\nend\n", "end min_element_example -- hide\n", "variables {S : set \u2115} {x y : \u2115} -- hide\n", "### Task\n\nProve uniquenss of minimal element. For this level, you won't need induction.\n", "The Lean lemma `le_antisymm` asserts that `x = y` follows given `x \u2264 y` and `y \u2264 x`.\n", "A useful lemma on inequalities", "Try this:\n```\nrcases h\u2081 with \u27e8hxin : x \u2208 S, hxmin : \u2200 (s \u2208 S), x \u2264 s\u27e9,\nrcases h\u2082 with \u27e8hyin : y \u2208 S, hymin : \u2200 (s \u2208 S), y \u2264 s\u27e9,\napply le_antisymm,\n{ show x \u2264 y,\n  sorry, },\n{ show y \u2264 x,\n  sorry },\n```\n\n", "A proof template", "If a set $S$ of natural numbers has a minimal element, then that element is unique.\n", "end exlean -- hide", "import data.set.basic tactic.norm_num tactic.linarith strong_induction.basic tactic.modded -- hide\n", "# Strong Induction\n\n## Level 4: The Well Ordering Principle\n", "namespace exlean -- hide\n", "open_locale classical -- hide\n", "open set nat --hide\n", "In the previous level, we show that if a set $S$ of natural numbers has a minimal element, then\nthat element is unique.\n\nIn this level, you'll show that every non-empty set of natural numbers has a minimal element. The\n(challenging) proof requires strong induction.\n", "### Nonempty sets\n\nIn Lean, a set `S` is nonempty if `\u2203 x, x \u2208 S`.\n\nAs an example, consider the set $\\\\{x : \\mathbb N \\mid x ^ 2 + 2x + 15 = 0\\\\}$. We'll show this set\nis nonempty.\n", "example : set.nonempty {x : \u2115 | x * x + 2 * x = 15} :=\nbegin\n  use 3, -- Take 3 for `x`.\n  show 3 * 3 + 2 * 3 = 15,\n  norm_num,\nend\n", "Start with proof by contradiction. Type `by_contra h\u2081`.\nThen push the negation through the quantifiers with `push_neg at h\u2081`.\n", "How to start!", "If you've taken the hint above, your goal now will be to prove `false`. This isn't evidently \nsomething amenable to strong induction!\n\nHowever, you can show that it suffices to prove `\u2200 (x : \u2115), x \u2209 S` by filling in the `sorry` below\n(the `tidy`  tactic can help with this).\n```\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ sorry, },\n```\nThis leaves you with the goal of proving, by strong induction, that `\u2200 (x : \u2115), x \u2209 S`.\n", "How to introduce strong induction", "The `tidy` tactic calls on a small set of other tactics to try to close the goal.\nIf a goal can be proved in a fairly straightforward manner from the assumptions, the\n`tidy` tactic can sometimes find a proof.\n", "The `tidy` tactic calls on a small set of other tactics to try to close the goal.\nIn this problem, if you have proved there is a natural number that is less that 0,\n`tidy` can derive a contradiction.\n", "Using the `tidy` tactic", "Recall that you can use `linarith` to prove inequalities. For example,\nif you know `m < k + 1` (for natural numbers `m` and `k`), then you can\nintroduce the hypothesis `hm : m \u2264 k` via\n```\nhave hm : m \u2264 k, by linarith,\n```\n", "Proving inequalities", "If you get stuck, try the following:\n```\nby_contra h\u2081,\ngiven h\u2081 : \u00ac\u2203(n : \u2115), (n \u2208 S \u2227 (\u2200 (m \u2208 S), n \u2264 m)),\npush_neg at h\u2081,\ngiven h\u2081 : \u2200 (n : \u2115), n \u2208 S \u2192 (\u2203 (m : \u2115), m \u2208 S \u2227 m < n),\nsuffices hs : \u2200 (x : \u2115), x \u2209 S,\n{ rcases h with \u27e8d, h : d \u2208 S\u27e9,\n  sorry, },\nlet P := \u03bb x, x \u2209 S,\nhave base : P 0,\n{ sorry, },\nhave ind_step : \u2200 (k : \u2115), (\u2200 (m : \u2115), m \u2264 k \u2192 P m) \u2192 P (k + 1),\n{ sorry, },\napply strong_induction base ind_step,\n```\n", "A proof template", "Every nonempty set of natural numbers has a minimal element.\n", "end exlean -- hide", "Divisibility", "import tactic.ring tactic.modded -- hide\n", "#  Divisibility\n\n## Level 1: The definition of divisibility\n\nThe notation `x \u2223 y` means `\u2203 (m : \u2124), y = x * m`. Here, the symbol, `\u2223` is typed `\\|` or `\\mid`.\n", "namespace exlean -- hide\n", "def myint_dvd : \u2124 \u2192 \u2124 \u2192 Prop := \u03bb (x y : \u2124), \u2203 (m : \u2124), y = x * m -- hide\n", "For example, we will prove that `5 \u2223 10`. We begin by nothing that the target is to show\n`\u2203 (m : \u2124), 10 = 5 * m`. \n\nIt remains to *find* an `m` that works. Let's use `2`. After that, we must prove `10 = 5 * 2`. But\nthis follows by definition of multiplication. A `norm_num` proof works.\n", "If the target is `\u22a2 \u2203 (x : \u03b1), P x` and if `y : \u03b1`, then `use y` changes the target to\n`\u22a2 P y`.\n\n### Example\nWith a target `\u22a2 \u2203 (x : \u2124), x + 5 = 23`, typing `use 18` changes the target to `\u22a2 18 + 5 = 23`.\n", "example : (5 : \u2124) \u2223 10 :=\nbegin\n  show \u2203 (m : \u2124), 10 = 5 * m,\n  use 2, -- \u22a2 10 = 5 * 2\n  norm_num,\nend\n", "\nThe `norm_num` tactic proves numerical goals. For example, it will close the goal\n`\u22a2 10 * 3 + 5 = 37 - 7`\n", "If you were to write the proof 'by hand', you might write the following:\n\n> By definition, it suffices to show there exists an integer `m` such that `10 = 5 * m`.\n> Take `2` for `m`. Then we must show `10 = 5 * 2`.\n> This is true by arithmetic.\n", "### Tasks\n* By making a minor variation to the proof above, show that `6 \u2223 72`.\n\n* Write the same proof by hand.\n", "`6 divides 72`\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_definition -- hide\n", "#  Divisibility\n\n## Level 2: Reflexivity of divisibility\n", "namespace exlean --hide\n", "In this short level, your task is to prove reflexvity of the divisiblity relation.\n", "As in the previous level, a good starting point is to rephrase the target\nof showing `a \u2223 a` using the definition of divisibility. That is, you must\nshow $\\exists m,\\ a = am$.\n\nYou are left with the task of proving an existentially-quantified statement.\nTherefore, you must exhibit an integer $m$ together with a proof of $a = am$.\n", "How to start the proof", "`a \u2223 a`, for every integer `a`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_refl -- hide\n", "#  Divisibility\n\n## Level 3: Every number is a factor of zero\n", "namespace exlean --hide\n", "### Task\nProve that every number is a factor of zero. You can do this using the style of proof required\nfor the previous two levels.\n", "Let `a` be an integer. Then `a \u2223 0`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_zero tactic.modded -- hide\n", "#  Divisibility\n\n## Level 4: A multiplication lemma\n", "namespace exlean --hide\n", "In the last level, you *proved* a divisibility statement. In this level, you'll *decompose* given\ndivisibility statements.\n\nTo prove a statement of the form `x \u2223 y` is to prove an existentially-quantified statement.\nYou do this by exists introduction (the `use` tactic in Lean).\n\nOn the other hand, if `h` is the hypothesis `a \u2223 b`, then `h` is a proof of the\nexistentially-quantified statement `\u2203 (m : \u2124), b = a * m`. You can decompose `h`into to an integer\n`k` and a hypothesis `h\u2082 : b = a * k` via `cases h with m h\u2082`.\nIn handwritten mathematics, this is exists elimination.\n", "### An addition result\n\nBelow, I present a proof that given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, then `a \u2223 b + c` follows.\n\nThe use of `given` tactics isn't strictly necessary, but is useful\nin ensuring you understand the definitions.\n", "variables {a b c d : \u2124} -- hide\n", "(h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c\n", "theorem dvd_add (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c :=\nbegin\n  given h\u2081 : \u2203 m\u2081, b = a * m\u2081,\n  -- By definition, `h\u2081 : \u2203 m\u2081, b = a * m\u2081`\n  cases h\u2081 with m\u2081 h\u2083, -- This gives `m\u2081 : \u2124` and\n  given h\u2083 : b = a * m\u2081, -- `h\u2083 : b = a * m\u2081`.\n  cases h\u2082 with m\u2082 h\u2084, -- This gives `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n  show \u2203 m, b + c = a * m,\n  use (m\u2081 + m\u2082), -- Take `m\u2081 + m\u2082` for `m`.\n  show b + c = a * (m\u2081 + m\u2082),\n  calc\n  b + c = (a * m\u2081) + (a * m\u2082) : by rw [h\u2083, h\u2084]\n    ... = a * (m\u2081 + m\u2082)       : by linarith,\nend\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n", "`linarith` proves many 'algebraic' equations and inequalities. For example, it can prove\n`(x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2`. It can pr\n", "Extracing the comments from the above gives a handwritten proof:\n\n> From `h_1` and `h_2`, we are given `m\u2081 : \u2124` and `h\u2083 : b = a * m\u2081`, and we are given  `m\u2082 : \u2124` and `h\u2084 : c = a * m\u2082`.\n> We must show `\u2203 (m : \u2124), b + c = a * m`.\n>\n> Take `m\u2081 + m\u2082` for `m`. We must show `b + c = a * (m\u2081 + m\u2082)`.\n> But\n> $$\n> \\begin{align}\n> b + c &= (a \\times m_1) + (a \\times m_2) && \\text{[from $h_3,\\ h_4$]} \\\\\\\\\n>  & = a \\times (m_1 + m_2), && \n> \\end{align}\n> $$\n> completing the proof. \u220e\n", "### Tasks\n* Adapting the Lean proof above, show that if `h : a \u2223 b`, then `a \u2223 b * c` for all integers `c`.\n\n* Write the same proof by hand.\n", "Let `a, b` be integers. Given `h : a \u2223 b`, we have `a \u2223 b * c`, for all integers `c`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_mul_of_dvd_left -- hide\n", "#  Divisibility\n\n## Level 5: Numbers divisible by zero\n", "namespace exlean --hide\n", "Which numbers are divisible by zero? You'll prove that a number is divisible by zero if and only \nif that number is itself zero.\n", "### Tasks\nLet $a$ be an integer. Prove that $a$ is divisibile by $0$ if and only if $a = 0$.\n", "Try this to begin with.\n```\nsplit,\n{ show 0 \u2223 a \u2192 a = 0,\n  sorry, },\n{ show a = 0 \u2192 0 \u2223 a,\n  sorry, },\n```\n", "A proof template", "\nWhile completing the proof of each `sorry`, ask yourself: what *kind* of statement am I being\nasked to prove? What is the context? Remember you can rephrase hypotheses using `given`\nand rephrase the target using `show`.\n\nYou can decompose an existentially-quantified hypothesis using `cases` (as in the previous level).\nThe `linarith` tactic will use any equations and inequalities in the context to try to prove the\ntarget.\n", "Proof ideas", "variables {a : \u2124} -- hide\n", "Let $a$ be an integer. Then $a$ is divisibile by $0$ if and only if $a = 0$.\n", "end exlean -- hide", "import tactic.linarith divisibility.zero_dvd_iff-- hide\n", "#  Divisibility\n\n## Level 6: A second multiplication lemma\n", "namespace exlean --hide\n", "variables {a b c d : \u2124} -- hide\n", "### Tasks\n* Adapting the Lean proof of `dvd_add` from a previous level, show that if `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, then\n`a * c \u2223 b * d`.\n\n* Write the same proof by hand.\n", "### Typing subscripts\n\nIn Lean, type `h\u2081` as `h\\1`.\n", "Let `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : c \u2223 d`, we have `a * c \u2223 b * d`.\n", "end exlean -- hide", "import tactic.linarith divisibility.mul_dvd_mul -- hide\n", "#  Divisibility\n\n## Level 7: Divisibility of linear combinations\n", "namespace exlean --hide\n", "Here are some of the properties of the divisibility relation that you've seen so far:\n\n* [Definition] `a \u2223 b` means `\u2203 (m : \u2124), b = a * m`.\n\n* [Reflexivity] `dvd_refl : a \u2223 a`.\n\n* `dvd_add` given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b + c`.\n\n* `dvd_mul_of_dvd_left` given `h : a \u2223 b`, we have `a \u2223 b * c`, for any `c : \u2124`.\n\nIn this level, you will *use* those results to prove other theorems.\n\nAs an example, let's consider how you might prove a new addition result.\n\n**Theorem**: $a \\mid (b + c) + d$ follows given that $a$ divides $b$, $c$, and $d$.\n", "Here is a 'forward' proof.\n\n**Proof**: From $a \\mid b$ and $a \\mid c$, we have $a \\mid b + c$. Using this, with the proof\nof $a\\mid d$, gives a proof of $a \\mid (b + c) + d$. \u220e\n\nI call this a 'forward' proof as it invovles adding hypotheses to the context until we have\nenough hypotheses to complete the goal.\n\nHere is the same proof in Lean.\n", "variables {a b c d s t : \u2124} -- hide\n", "example (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  have h\u2084 : a \u2223 b + c, from dvd_add h\u2081 h\u2082,\n  show a \u2223 (b + c) + d, from dvd_add h\u2084 h\u2083,\nend\n", "Contrast this with a 'backward' proof of the same result.\n\n**Proof**: By properties of divisibility, it suffices to show $a \\mid b + c$ and $a \\mid d$.\nTo prove the first of these, it suffices to show $a \\mid b$ and $a \\mid c$. Both of these\nare assumptions. The last requirement, that $a \\mid d$, is also an assumption. \u220e\n\nI call this proof 'backward' as it breaks the main goal into smaller subgoals and deals with\neach of those in turn.\n", "How do we do this in Lean?\n\nIf we had proof of `a \u2223 (b + c)` and a proof of `a \u2223 d`, we could feed these into `dvd_add` to\ngive a proof of `a \u2223 (b + c) + d`.\n\nTo do this backward, `apply dvd_add` transforms the goal of proving `a \u2223 (b + c)` into\ntwo subgoals: to prove `a \u2223 b + c` and to prove `a \u2223 d`.\n\nThe resulting proof is longer, but has the advantage that no additional hypotheses are added\nto the context. It is often mentally easier to break down a large goal into smaller goals\nthan to construct a proof from the ground up.\n", "example (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add,    -- 2 goals `\u22a2 a \u2223 b + c` and `\u22a2 a \u2223 d`\n  { show a \u2223 b + c, -- Goal 1.  \n    apply dvd_add,  -- 2 subgoals `\u22a2 a \u2223 b` and `\u22a2 a \u2223 c`\n    { show a \u2223 b, \n      from h\u2081, },\n    { show a \u2223 c,\n      from h\u2082, }, },\n  { show a \u2223 d,     -- Goal 2.\n    from h\u2083, },\nend\n", "The same proof can be written more concisely via a forward application of `dvd_add` in the first\ngoal.\n", "example (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  apply dvd_add,    \n  { show a \u2223 b + c,\n    from dvd_add h\u2081 h\u2082, },\n  { show a \u2223 d,\n    from h\u2083, },\nend\n", "Or, to be *really* terse, you can do everything forward. As a downside, the proof is harder to\nunderstand.\n", "example (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) (h\u2083 : a \u2223 d) : a \u2223 (b + c) + d :=\nbegin\n  from dvd_add (dvd_add h\u2081 h\u2082) h\u2083,\nend\n", "Most theorems have conditions under which they hold. For example, `dvd_add` states that\n`a \u2223 b + c` given the conditions `a \u2223 b` and `a \u2223 c`. If the target is `\u22a2 a \u2223 b + c`, then\ntyping `apply dvd_add` creates two new goals: (1) to prove `a \u2223 b` and (2) to prove `a \u2223 c`.\n\nThe use of `apply` can be shortened. If the hypotheses `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c` are in the\ncontext, then the target `a \u2223 b + c` can be proved with `apply dvd_add h\u2081 h\u2082`.\n", "### Tasks\n* By applying some of the results above, prove that if `a \u2223 b` and `a \u2223 c`, then `a` divides any\nlinear combination of `b` and `c`. That is, `a \u2223 b * s + c * t`, for all integers `s` and `t`. \n\n* Write the same proof by hand.\n\n* Give a backward proof if you've already written a forward proof. And vice-versa.\n", "If you were writing this proof by hand, you might start by saying that it suffices (by `dvd_add`)\nto prove `a \u2223 b * s` and `a \u2223 c * t`. To do this in Lean, type `apply dvd_add`. Here's an\nexample of this kind of reasoning.\n", "Given `h\u2081 : a \u2223 b` and `h\u2082 : a \u2223 c`, we have `a \u2223 b * s + c * t`, for all integers `s` and `t`.\n", "end exlean -- hide\n", "import tactic.linarith divisibility.dvd_mul_add_mul-- hide\n", "#  Divisibility\n\n## Level 8: Transtivity of divisibility\n", "namespace exlean --hide\n", "variables {a b c : \u2124} -- hide\n", "Let `a, b, c, d` be integers. Given `h\u2081 : a \u2223 b` and `h\u2082 : b \u2223 c`, we have `a \u2223 c`.\n", "end exlean -- hide", "import tactic.linarith divisibility.dvd_trans  -- hide\n", "# Divisibility\n\n## Level 9: Antisymmetry\n", "namespace exlean -- hide\n", "open int -- hide\n", "The divisibility relation is antisymmetric.\nThat is, suppose `a` and `b` are non-negative integers such that\n`a \u2223 b`, and `b \u2223 a`, then `a = b`.\n", "variables {a b c d : \u2124} -- hide\n", "a = b\n", "theorem dvd_antisymm (H1 : 0 \u2264 a) (H2 : 0 \u2264 b) : a \u2223 b \u2192 b \u2223 a \u2192 a = b :=  -- hide\n", "dvd_antisymm H1 H2                                                        -- hide\n", "In Lean, this result is called `dvd_antisymm`. We can apply it forward\nto give a proof of `a = b` from hypotheses `h\u2081 : 0 \u2264 a`, `h\u2082 : 0 \u2264 b`,\n`h\u2083 : a \u2223 b`, and `h\u2084 : b \u2223 a`.\n", "example (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  from dvd_antisymm h\u2081 h\u2082 h\u2083 h\u2084,\nend\n", "This presupposed we have proved the necessary hypotheses. In some\ncases, it is easier to apply the result backwards.\n", "example (h\u2081 : 0 \u2264 a) (h\u2082 : 0 \u2264 b) (h\u2083 : a \u2223 b) (h\u2084 : b \u2223 a) : a = b :=\nbegin\n  apply dvd_antisymm h\u2081 h\u2082,\n  { show a \u2223 b,\n    from h\u2083, },\n  { show b \u2223 a,\n    from h\u2084, },\nend\n", "In this level, we'll prove an if and only if (`\u2194`) statement. To split an `\u2194` statement into two\nimplications, use the `split` tactic.\n\nIn the example below, the initial goal is $\\vdash a = 2b + c \\leftrightarrow c = a - 2b$. After using the\n`split` tactic, we have two new goals: (1) $\\vdash a = 2b + c \\to c = a - 2b$ and \n(2) $\\vdash c = a - 2b \\to a = 2b + c$.\n", "example : a = 2 * b + c \u2194 c = a - 2 * b :=\nbegin\n  split, \n  { show (a = 2 * b + c) \u2192 (c = a - 2 * b),\n    assume h : a = 2 * b + c,\n    show c = a - 2 * b, linarith },\n  { show (c = a - 2 * b) \u2192 (a = 2 * b + c),\n    assume h : c = a - 2 * b,\n    show a = 2 * b + c, linarith, },\nend\n", "\nThe `split` tactic splits a 'compound' target into multiple goals. \n\nFor example, `split` turns the target `\u22a2 p \u2194 q` into two goals: (1) to prove\n`p \u2192 q` and (2) to prove `q \u2192 p`.\n\nEqually, if the target is `\u22a2 p \u2227 q`, then `split` creates goals (1) `\u22a2 p` and (2) `\u22a2 q`.\n", "\nSuppose `P` is a predicate. Recall that if `h : \u2200 (x : \u03b1), P(x)` and if `y : \u03b1`, then\n`specialize h y` replaces `h` with `P(y)`.\n", "Specialzing a universally-quantified statement.", "\nSuppose `h : p \u2194 q`. Then the tactic `cases h with h\u2082 h\u2083` replaces `h` with `h\u2082 : p \u2192 q` and\n`h\u2083 : q \u2192 p`.\n", "Decomposing a `\u2194` statement.", "The proposition $\\forall(a : \\mathbb Z), b \\mid a \\leftrightarrow c \\mid a$ holds\nif and only if $b = c$.\n", "end exlean -- hide\n", "import tactic.linarith divisibility.dvd_antisymm  -- hide\n", "# Divisibility\n\n## Level 10: Common divisor basics\n", "namespace exlean -- hide\n", "Let $m$, $n$, and $d$ be integers. For $d$ to be a _common divisor_ of $m$ and $n$ means that\n$d \\mid m$ and $d \\mid n$.\n", "def common_divisor (m n d : \u2124) := (d \u2223 m) \u2227 (d \u2223 n)\n", "Using the above definition, we'll show that $5$ is a common divisor of $20$ and $30$.\n", "example : common_divisor 20 30 5 :=\nbegin\n  split, -- We'll show 1) `5 \u2223 20` and 2) `5 \u2223 30`.\n  { use 4,  -- 1) `\u22a2 5 \u2223 20`, it suffices to show `20 = 5 * 4`.\n    norm_num, }, -- This holds by arithmetic.\n  { use 6,  -- 2) `\u22a2 30 = 5 * 6`, it suffices to show `\u22a2 30 = 5 * 6`.\n    norm_num, }, -- This holds by arithmetic.\nend\n", "### Tasks\n\n* Adapt the Lean proof above to show that $4$ is a common divisor of $48$ and $60$.\n\n* Give a handwritten proof of the same result.\n\n", "$4$ is a common divisor of $48$ and $60$.\n", "end exlean -- hide", "import tactic.linarith divisibility.common_divisors  -- hide\n", "# Divisibility\n\n## Level 11: Common divisor results\n", "namespace exlean -- hide\n", "### Tasks\n\nIn this level, you'll *decompose* the hypothesis that `d` is a common divisor of `a` and `b` to\nprove that `c` is a common divisor of `a` and `b`, under the hypothesis that `c \u2223 d`.\n\nAs `common_divisor a b d` is a conjunctive (an 'and') statement, it can be decomposed into\nits constituent parts using the `cases` tactic. See the example below.\n", "variables {d a b c s t : \u2124} -- hide\n", "example (h\u2081 : common_divisor a b d) : common_divisor a (a * s + b * t) d :=\nbegin\n  cases h\u2081 with hda hdb, -- `hda : d \u2223 a`, `hdb : d \u2223 b`.\n  given hda : d \u2223 a,\n  given hdb : d \u2223 b,\n  show (d \u2223 a) \u2227 (d \u2223 a * s + b * t),\n  split, -- 2 goals: (1) `\u22a2 d \u2223 a` and (2) `\u22a2 d \u2223 a * s + b * t`.\n  { show d \u2223 a,\n    from hda, }, -- (1) follows from `hda`\n  { show d \u2223 a * s + b * t,\n    apply dvd_mul_add_mul hda hdb, }, -- (2) follows from\n  -- our previous result on divisibility of linear combinations.\nend\n", "The transitivity of divisibility, `dvd_trans` is your friend.\n\n", "A useful result", "Given `d` is a common divisor of `a` and `b` and given `c \u2223 d`, we have `c` is a common divisor of\n`a` and `b`.\n", "end exlean -- hide", "import tactic.linarith divisibility.common_divisors2  -- hide\n", "# Divisibility\n\n## Level 12: Greatest common divisors\n", "namespace exlean -- hide\n", "open int -- hide\n", "Recall that for $d$ to be a common divisor of $a$ and $b$ means that $d \\mid a$ and $d \\mid b$.\n", "To say that $m$ and $n$ have no greater common divisor than $d$\nmeans that for every integer $e$, if $e$ is a common divisor of $m$\nand $n$, then $e \\mid d$.\n", "def no_greater_common_divisor (m n d : \u2124) :=\n\u2200 (e : \u2124), common_divisor m n e \u2192 e \u2223 d\n", "For $d$ to be a _greatest common divisor_ of $m$ and $n$ means that\n* $d$ is a common divisor of $m$ and $n$ and\n* $m$ and $n$ have no greater common divisor than $d$.\n", "def greatest_common_divisor (m n d : \u2124) := (common_divisor m n d) \u2227 \n  no_greater_common_divisor m n d\n", "There are similarities between this definition and the definition of infimum in the\nreal number world. As with infima (and suprema), we can prove that there is (up to sign)\na unique greatest common divisor of two integers.\n", "**Warning**: the definition `greatest_common_divisor` is a predicate, not an ordinary function.\nSo, `greatest_common_divisor m n d` is the *proposition* that $d$ is a greatest common\ndivisor of $m$ and $n$. It is *not* an integer.\n\n", "### Task\n\nShow that if the non-negative integers $d$ and $e$ are both greatest common divisors of $m$ and $n$,\nthen $d = e$.\n", "variables {d e m n : \u2124} -- hide\n", "Recall that `apply dvd_antisymm k\u2081 k\u2082,` will reduce the goal to two goals (1) `\u22a2 d \u2223 e` and\n(2) `\u22a2 e \u2223 d`.\n", "Proving an equality", "If the non-negative integers $d$ and $e$ are both greatest common divisors of $m$ and $n$,\nthen $d = e$.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_uniqueness -- hide\n", "# Divisibility\n\n## Level 13: Greatest common divisor of an integer and zero\n", "namespace exlean -- hide\n", "open int -- hide\n", "As a next example of theorems regarding greatest common divisors, you will prove\nthat the greatest common divisor of $a$ and $0$ is $a$, for any integer $a$.\n\nThat is, you will prove:\n\n* $a$ is a common divisor or $a$ and $0$ and\n* there is no greater common divisor of $a$ and $0$ than $a$.\n", "Recall that `greatest_common_divisor d a b` is a conjunctive statement. Thus, you can\nsplit the goal in two using the `split` tactic.\n", "Starting the proof", "`a` is a greatest common divisor of `a` and `0`, for every integer `a`.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_zero -- hide\n", "# Divisibility\n\n## Level 14: Commutativity of greatest common divisor\n", "namespace exlean -- hide\n", "open int -- hide\n", "variables {a b d c : \u2124} -- hide\n", "Suppose $a$, $b$, and $d$ are integers. We've seen how to *prove* that $d$ is a greatest common\ndivisor of $a$ and $b$. If instead we are *given* that $d$ is a greatest common divisor of $a$ and\n$b$, what can we do with this information?\n\n**Theorem**: Suppose $c \\mid d$ and suppose that $d$ is a greatest common divisor of $a$ and $b$.\nThen $c$ is a common divisor of $a$ and $b$.\n\n**Proof**: As $d$ is a greatest common divisor of $a$ and $b$, we have that $d$ is a common\ndivisor of $a$ and $b$. Thus, $d \\mid a$ and $d \\mid b$. But $c \\mid d$. So, by the transitivity\nof divisibility (applied twice), we have $c \\mid a$ and $c \\mid b$.\n\nThus, $c$ is a common divisor of $a$ and $b$. \u220e\n", "There are several ways to prove this in Lean. Suppose `hcd` is the hypothesis that `c \u2223 d`\nand that `h` is the hypothesis `greatest_common_divisor a b d`.\nWe can decompose `h` into `h\u2081 : common_divisor a b d` and `h\u2082  : no_greater_common_divisor a b d`\nvia  `cases h with h\u2081 h\u2082`.\n\nThen `h\u2081` can be further decomposed via `cases h\u2081 with hda hdb` into `hda : d \u2223 a` and\n`hdb : d \u2223 b`.\n\nThe target `common_divisor a b d` is a conjunction (an and statement) that can be proved backward\nvia `split`.\n", "example (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  cases h with h\u2081 h\u2082,\n  given h\u2081 : common_divisor a b d,\n  cases h\u2081 with hda hdb,\n  given hda : d \u2223 a,\n  given hdb : d \u2223 b,\n  show common_divisor a b c,\n  split,\n  { show c \u2223 a, from dvd_trans hcd hda, }, \n  { show c \u2223 b, from dvd_trans hcd hdb, },\nend\n", "Rather than using `cases` to extract named hypotheses, we can drill down into `h` directly\nusing left and right 'and elimination'.\n\nAs `h` is the proof of an and statement, `h.left` is a proof of `common_divisor a b d`, which means\n`(d \u2223 a) \u2227 (d \u2223 b)`. Thus, `h.left.right` is a proof `d \u2223 b`.\n", "example (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  have hda : d \u2223 a, from h.left.left,\n  have hdb : d \u2223 b, from h.left.right,\n  split,\n  { show c \u2223 a, from dvd_trans hcd hda, }, \n  { show c \u2223 b, from dvd_trans hcd hdb, },\nend\n", "For a one-line proof, we can use `and.intro` rather than `split`, thereby giving a forward proof\nof the and statement `common_divisor a b c`.\n", "example (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  from and.intro (dvd_trans hcd h.left.left) (dvd_trans hcd h.left.right),\nend\n", "### The `rcases` tactic\n\nAn alternative approach is to use `rcases` (short for 'recursive cases'). This combines the\nease-of-use of `cases` with the readability of a forward proof.\n\nI'll start with a simple example from propositional logic.\n", "variables (p q r : Prop) -- hide\n", "example (h : p \u2227 q) : q \u2227 p :=\nbegin\n  rcases h with \u27e8hp : p, hq : q\u27e9,\n  show q \u2227 p, from and.intro hq hp,\nend\n", "Above, the line `rcases h with \u27e8hp : p, hq : q\u27e9` decomposes `h : p \u2227 q` into two hypotheses:\n`hp : p` and `hq : q`. This has exactly the same effect as `cases h with hp hq`.\n\nHere, the 'French quotes' `\u27e8` and `\u27e9` are typed `\\<` and `\\>`.\n\nThere's not much point using `rcases` for a simple example like this. Its power becomes apparent\nwith more complicated examples.\n", "example (h : (p \u2227 q) \u2227 r) : r \u2227 q :=\nbegin\n  rcases h with \u27e8\u27e8hp, hq\u27e9, hr\u27e9,\n  show r \u2227 q, from and.intro hr hq,\nend\n", "As we don't need the hypothesis `hp` in the example above, We could instead have used the pattern\n`\u27e8\u27e8-, hq\u27e9, hr\u27e9`. The `-` tells `rcases` not to introduce the proof of `p` as a hypothesis.\n\n`rcases` can do many more things. See the Tactic sidebar for details.\n\nFor now, we'll use `rcases` to prove the theorem stated at the top of this level.\n", "Used for recursive elimination.\n\n## Examples\n* If `h : a \u2227 b` then `rcases h with \u27e8h\u2081 : a, h\u2082 : b\u27e9` replaces `h` with two hypotheses,\n`h\u2081 : a` and `h\u2082 : b`.\n\n* If `h : \u2203 (x : X), P(x)`, then `rcases h with \u27e8x, h\u2082 : P(x)\u27e9` replaces `h` with `x : X`\nand `h\u2082 : P(x)`.  \n\n* If `h : a \u2228 b`, then `rcases h with (h\u2081 : a) | (h\u2082 : b)` replaces the goal with two new goals,\none with a hypothesis `h\u2081 : a` and one with a hypothesis `h\u2082 : b`.\n\n* If `h : a = b`, then `rcases h with rfl` replaces every occurence of `b` in the context\nwith `a`.\n\n* These rules can be used recursively. Thus if `\u2203 (x : \u2115), Q(x) \u2228 (P(x) \u2227 y = 2 * x)`,\nthen `rcases h with \u27e8x, (h\u2082 : Q(x)) | \u27e8h\u2083 : P(x), rfl\u27e9 \u27e9` replaces `h` and creates two new goals.\nEach goal contains `x : \u2115`. The context of the first goal contains contains `h\u2082 : Q(x)`.\nIn the second goal, every instance of `y` is replaced with `2 * x`. The context of the\nsecond goal  contains `h\u2083: P(x)`.\n", "example (hcd : c \u2223 d) (h : greatest_common_divisor a b d) : common_divisor a b c :=\nbegin\n  rcases h with \u27e8\u27e8hda : d \u2223 a, hdb : d \u2223 b \u27e9, -\u27e9,\n  show (c \u2223 a) \u2227 (c \u2223 b),\n  split,\n  { show c \u2223 a,\n    from dvd_trans hcd hda,},\n  { show c \u2223 b,\n    from dvd_trans hcd hdb, },\nend\n", "### Task\nProve that if $d$ is the greatest common divisor of $a$ and $b$, then $d$ is the greatest\ncommon divisor of $b$ and $a$. You may wish to use the `rcases` tactic to decompose the\nhypothesis.\n", "You can begin with the `rcases` tactic.\n```\nrcases h with \u27e8\u27e8hda : d \u2223 a, hdb : d \u2223 b\u27e9, hngt : no_greater_common_divisor a b d\u27e9,\nshow ((d \u2223 b) \u2227 (d \u2223 a)) \u2227 (no_greater_common_divisor b a d),\nsorry,\n```\n", "A proof template", "At some point in the proof, you will need to show `e \u2223 d`. Note that this can be seen as the\nconclusion of the statement `no_greater_common_divisor a b d`, which should be the hypothesis\n`hngt` if you followed my proof template above.\n\nIn detail, `hngt : \u2200 (e : \u2124), common_divisor a b e \u2192 e \u2223 d`.\nUsing `apply hngt` will thereby change the goal of proving `e \u2223 d` into the goal of proving\n`common_divisor a b e`.\n", "Showing `e \u2223 d`", "If $d$ is a greatest common divisor of $a$ and $b$, then $d$ is a greatest common divisor of\n$b$ and $a$.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_comm  -- hide\n", "# Divisibility\n\n## Level 15: Division\n", "namespace exlean -- hide\n", "open int -- hide\n", "The division lemma states that if `a` and `b` are integers with `b \u2260 0`, then there exist integers\n`q` and `r` for which `a = b * q + r` and `0 \u2264 r < |b|`.\n\nThe quantity `q` is called the quotient and `r` is called the remainder.\n\nIn Lean, the absolute value of `b` may be written `abs b` or `|b|`.\n", "variables (a b : \u2124) -- hide\n", "\u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|)\n", "lemma division (h : b \u2260 0) : \u2203 (q r : \u2124), a = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|) :=     -- hide\n", "\u27e8a/b, a % b, by rw [add_comm, mod_add_div a b], mod_nonneg a h, mod_lt a h\u27e9  -- hide\n", "example (h : b \u2260 0) : \u2203 (q r : \u2124), 700 = b * q + r \u2227 (0 \u2264 r \u2227 r < |b|) :=\nbegin\n  apply division 700 b h,\nend\n", "variables {q\u2081 r\u2081 q\u2082 r\u2082 : \u2124} -- hide\n", "### Task\nIn this level, your task is to show uniqueness of the quotient and remainder.\nMore precisely, suppoer you have integers $a$ and $b$ with $b \\ne 0$. Suppose\n$a = bq_1 + r_2$ and $a = bq_2 + r_2$ for integers $q_1, q_2, r_1, r_2$ such that\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$. Then $q_1 = q_2$ and $r_1 = r_2$.\n\n**Warning**: this level is challenging. Feel free to skip it.\n\nThe following lemma will be useful.\n", "lemma abs_sub_lt {x y c : \u2124} (h\u2081 : 0 \u2264 x \u2227 x < c) (h\u2082 : 0 \u2264 y \u2227 y < c) : |x - y| < c :=\nbegin\n  rw abs_sub_lt_iff,\n  split;\n  linarith,\nend\n", "Other useful results include:\n\n* `abs_mul a b : |a * b| = |a| * |b|`\n* `abs_nonneg a : 0 \u2264 |a|`\n* `abs_pos : 0 < |a| \u2194 a \u2260 0`\n* `sub_neq_zero : a - b \u2260 0 \u2194 a \u2260 b`\n* `le_mul_of_one_le_right : 0 \u2264 b \u2192 1 \u2264 a \u2192 b \u2264 b * a`.\n* `abs_pos : 0 < |a| \u2194 a \u2260 0`.\n* `sub_ne_zero : x - y \u2260 0 \u2194 x \u2260 y`\n", "If you were proving this by hand, you might start by noting that\n$r_1 = r_2 + b(q_2 - q_1)$ and that $r_1 - r_2 = b(q_2 - q_1)$. The variable $a$ and the equations\ninvolving $a$ can thereafter by ignored.\n\nConsider separately the cases $q_2 = q_1$ and $q_2 \\ne q_1$.\n\nIn the first case, where $q_2 = q_1$, we can\nwe can replace replace $r_1$ with $r_2 + b(q_2 -q_1)$ and $q_2$ with $q_1$ in the target so\nthat our goal is to prove $q_1 = q_1$ and $r_2 + b(q_2 - q_2) = r_2$. Each of these equations\nis clearly true.\n\nThe more difficult case to consider is when $q_2 \\ne q_1$. As this hypothesis contradicts the target,\nit's evident that we should proceed by ex falso.\n\nFrom $r_1 - r_2 = b(q_2 - q_1)$, we have that $|b| |q_2 - q_1| = |b(q_2 - q_1)| = |r_2 - r_1|$.\nBut $0 \\le |r_1| < |b|$ and $0 \\le |r_2| < |b|$, so $|r_2 - r_1| < |b|$.\n\nThus, $|b||q_2 - q_1| < |b|$. This contradicts $q_2 \\ne q_1$.\n", "A sketch 'handwritten' proof", "You can begin by decomposing the hypotheses.\n```\nrcases h\u2081 with \u27e8heq\u2081 : a = b * q\u2081 + r\u2081, hineq\u2081 : 0 \u2264 r\u2081 \u2227 r\u2081 < |b|\u27e9,\nrcases h\u2082 with \u27e8heq\u2082 : a = b * q\u2082 + r\u2082, hineq\u2082 : 0 \u2264 r\u2082 \u2227 r\u2082 < |b|\u27e9,\n```\n\nYou can introduce some useful equations into the context via\n```\nhave h\u2084 : r\u2081 = r\u2082  + b * (q\u2082 - q\u2081), by linarith only [heq\u2081, heq\u2082],\nhave h\u2085 : r\u2081 - r\u2082  = b * (q\u2082 - q\u2081), linarith only [h\u2084],\nclear heq\u2081 heq\u2082,\n```\n\nHere, the `clear` line removes the named hypotheses from the context. It isn't necessary but it\nhelps in keepingthe proof tidy and efficient.\n\nYou'll then need to consider separately the cases `q\u2082 = q\u2081` and `q\u2082 \u2260 q\u2081`.\nYou can do this with `by_cases heq : q\u2082 = q\u2081`.\n\nAs some point, you'll want to prove `|r\u2081 - r\u2082| < |b|`. This sort of statement is the\nconclusion of `abs_sub_lt`.\n", "Ideas for the Lean proof", "If you followed my sketch proof above, you'll know that the second case of the proof\ninvolves assuming $q_2 \\ne q_1$, deriving $|b||q_2 - q_1| < |b|$ and thereby deriving\na contradiction. But what is this contradiction?\n\nBy applying `le_mul_of_one_le_right`, you can prove `|b| \u2264 |b| * |q\u2082 - q\u2081|`, which clearly\ncontradicts `|b| * |q\u2082 - q\u2081| < |b|`.\n\nThus, you can try\n```\nhave lt2 : |b| \u2264 |b| * |q\u2082 - q\u2081|,\n{ apply le_mul_of_one_le_right,\n  { show 0 \u2264 |b|, sorry },\n  { show 1 \u2264 |q\u2082 - q\u2081|, sorry },\n```\nafter which `linarith` will find the contradiction. It remains to complete the `sorry`s.\nThe tricky part of this is the second `sorry`. see below for a hint.\n", "Getting the final contradiction via `le_mul_of_one_le_right`", "If you followed the hints above, you'll be left with proving `1 \u2264 |q\u2082 - q\u2081|`.\nOne way to do this is first to introduce a proof of `0 < |q\u2082 - q\u2081|` and then use linarith:\n```\nhave hqpos : 0 < |q\u2082 - q\u2081|,\n{ sorry },\nlinarith,\n```\nTo complete this last `sorry`, rewrite the target using `abs_pos` and `sub_ne_zero`.\n", "Proving `1 \u2264 |q\u2082 - q\u2081|`", "Let $a, b$ be integers with $b \u2260 0$. If $a = b q_1 + r_1 = b q_2  + r_2$, where\n$0 \\le r_1 < |b|$ and $0 \\le r_2 < |b|$, then $q_1 = q_2$ and $r_1 = r_2$.\n", "end exlean -- hide", "import tactic.linarith divisibility.division -- hide\n", "# Divisibility\n\n## Level 16: Non-divisibility examples\n", "namespace exlean -- hide\n", "In any particular numerical example, it's easy to show divisibility. For example, here's a proof\nthat $7 \\mid 42$.\n", "example : (7 : \u2124) \u2223  42 :=\nbegin\n  show \u2203 (m : \u2124), 42 = 7 * m,\n  use 6,\n  norm_num,\nend\n", "But how can we prove non-divisibility? How would you prove $7 \\nmid 31$?\n\nThe idea is to use the uniqueness of division result. Suppose (for a contradiction), that\n$h: 7 \\mid 31$. Decomposing $h$ gives $m : \\mathbb Z$ and $h : 31 = 7m = 7m + 0$.\n\nBut (as you may easily verify), we have $h_2 : 31 = 7 \\times 4 + 3$.\n\nUsing $h$ and $h_2$ in the uniquness of division result, we infer $m = 4$ and $0 = 3$. This\nlatter is a contradiction.\n", "Here we use the semi-colon `;` 'tactic combinator'. This is a time-saving measure that applies\nthe following tactic to each remaining goal. In our application, the tactic `tidy` is used\nto complete each of the three goals that arise from the application of `division_unique 31 7`.\n", "example : \u00ac((7 : \u2124) \u2223 31) :=\nbegin\n  assume h : (7 : \u2124) \u2223 31,\n  cases h with m h, -- We have `m : \u2124` and `h : 31 = 7 * m`.\n  have h\u2081 : (31 : \u2124) = 7 * m + 0, linarith,\n  have h\u2082 : (31 : \u2124) = 7 * 4 + 3, norm_num,\n  have k\u2081 : m = 4 \u2227 (0 : \u2124) = 3,\n  { apply division_unique 31 7;\n    tidy, },\n  linarith, -- `k\u2081` gives a contradiction.\nend\n", "5 does not divide sixty-two.\n", "end exlean -- hide", "import tactic.linarith strong_induction.well_ordering_principle divisibility.division -- hide\n", "# Divisibility\n\n## Level 17: B\u00e9zout's lemma (version 1)\n", "namespace exlean -- hide\n", "**Warning**: this is a challenging level! Feel free to move on to the next level if you get stuck.\n\nLet $a$ and $b$ be integers. B\u00e9zout's lemma asserts that there exists an integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$ and such that $d = as + bt$, for some integers \n$s$ and $t$.\n\nIn this level, you'll prove B\u00e9zout's lemma via the well-ordering principle. If you haven't already\ndone so, please try the level on the well-ordering principle from the 'Strong Induction' world.\n\nThe proof contains several components. First, we need to consider the set\n$\\\\{y : \\mathbb N \\mid (0 < y) \\land (\\exists (s\\ t\\ : \\mathbb Z),\\, |a s + b t|  = y)\\\\}$.\n\nWe call this set `set_T a b`.\n", "open int \nvariables {a b : \u2124} {k : \u2115}\nnamespace gcd_set\n", "def set_T (a b : \u2124) := {y : \u2115 | 0 < y \u2227 \u2203 (s t : \u2124), nat_abs (a * s + b * t)  = y}\n", "lemma lin_combo_of_min_element (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), \u2191k = a * x + b * y :=\nbegin\n  rcases h with \u27e8\u27e8hkpos, s, t, hst\u27e9, hkmin\u27e9,\n  rw nat_abs_eq_iff at hst,\n  cases hst,\n  { use [s, t],\n    from hst.symm, },\n  { use [-s, -t],\n    linarith, },\nend\nlemma dvd_of_min_element (a b : \u2124) (k : \u2115) (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  rcases lin_combo_of_min_element h with \u27e8x, y, hxy\u27e9,\n  rcases h with \u27e8\u27e8hkpos, hst\u27e9, hkmin\u27e9,\n  clear hst,\n  rcases division a k (show (k : \u2124) \u2260 0, by linarith) with \u27e8q, r, hqr, hrnonneg, hrlt\u27e9,\n  by_cases hrzero : r = 0,\n  { use q,\n    rw [hqr, hrzero, add_zero], },\n  exfalso,\n  have hrinT : r.nat_abs \u2208 set_T a b,\n  { rw [set_T, set.mem_set_of_eq],\n    split,\n    { apply nat_abs_pos_of_ne_zero hrzero,  },\n    { use [1 - x * q, - y * q],\n      congr,\n      rw [(show r = a - k * q, by linarith), hxy],\n      linarith, }, },\n  specialize hkmin (nat_abs r) hrinT,\n  have : nat_abs r < k,\n  { rw \u2190nat_abs_of_nat k, \n    apply nat_abs_lt_nat_abs_of_nonneg_of_lt hrnonneg, \n    rwa coe_nat_abs at hrlt, },\n  linarith, \nend\nlemma set_T_nonempty (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  use nat_abs a,\n  rw [set_T, set.mem_set_of_eq],\n  split,\n  { apply nat_abs_pos_of_ne_zero h, },\n  use [1, 0],\n  rw [mul_one, mul_zero, add_zero],\nend\nlemma set_T_comm : (set_T b a) = (set_T a b) :=\nbegin\n  suffices h\u2082 : \u2200 (m n : \u2124), set_T m n \u2286 set_T n m,\n  { ext y,\n    from \u27e8\u03bb h, h\u2082 b a h, \u03bb h, h\u2082 a b h\u27e9, },\n  rintros m n y \u27e8ypos, s, t, h\u27e9,\n  apply and.intro ypos _,\n  use [t,s],\n  rwa add_comm,\nend\n", "You'll need to use the following lemmas concerning this set.\n* `lin_combo_of_min_element`\n* `dvd_of_min_element`\n* `set_T_nonempty`\n* `set_T_comm`\n\nThe use of these lemmas is shown below.\n", "example (h : min_element k (set_T a b)) : \u2203 (x y : \u2124), (k : \u2124) = a * x + b * y :=\nbegin\n  from lin_combo_of_min_element h,\nend\n", "\n", "example (h : min_element k (set_T a b)) : \u2191k \u2223 a :=\nbegin\n  from dvd_of_min_element a b k h,\nend\n", "\n", "example (h : a \u2260 0) : (set_T a b).nonempty :=\nbegin\n  from set_T_nonempty h,\nend\n", "\n", "example : (set_T b a) = (set_T a b) :=\nbegin\n  from set_T_comm,\nend\n", "end gcd_set -- hide\n", "### An overview of the proof\nThere are two cases to consider: either $a = 0$ or $a \\ne 0$.\nIn the first case, the result follows in a relatively straightforward manner, using\nsome of the results we've proved already concerning greatest common divisors.\n\nIn the second case, the idea is to show that the minimal element of the set `set_T a b`\nwill be the greatest common divisor of $a$ and $b$. We can extract the minimal element of\nthis set via the well-ordering principle.\n\nThe remainder of the proof uses the lemmas above and our previous material on divisibility.\n", "open gcd_set -- hide\n", "B\u00e9zout's lemma (version 1). Every pair of integers $a$ and $b$ has a greatest common divisor $d$\nthat can be written as $d = as + bt$, for some integers $s$ and $t$.\n", "end exlean -- hide", "import tactic.linarith divisibility.bezout -- hide\n", "# Divisibility\n\n## Level 18: The negative of a greatest common divisor\n", "namespace exlean -- hide\n", "In preparation for another version of B\u00e9zout's lemma, we first need a result about greatest common\ndivisors.\n\n### Task\nSuppose $d$ is a greatest common divisor of $a$ and $b$. Prove that $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n\nSome of the following results on divisibility will be useful.\n", "open int -- hide\n", "variables {a b d : \u2124} -- hide\n", "(h : d \u2223 a) : -d \u2223 a\n", "lemma neg_dvd_of_dvd (h : d \u2223 a) : -d \u2223 a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 a = -d * -m`,\n  rw h\u2082, -- `\u22a2 d * m = -d * -m`,\n  ring, -- This follows by algebra.\nend\n", "-d \u2223 a \u2194 d \u2223 a\n", "lemma neg_dvd : -d \u2223 a \u2194 d \u2223 a :=\nbegin\n  split,\n  { assume h : -d \u2223 a,\n    rw \u2190neg_neg d,\n    from neg_dvd_of_dvd h, },\n  { assume h : d \u2223 a,\n    from neg_dvd_of_dvd h, },\nend\n", "(h : d \u2223 a) : d \u2223 -a\n", "lemma dvd_neg_of_dvd (h : d \u2223 a) : d \u2223 -a :=\nbegin\n  cases h with m h\u2082, -- `h\u2082 : a = d * m`\n  use -m, -- `\u22a2 - a = d * -m`,\n  rw h\u2082, -- `\u22a2 -(d * m) = d * -m`,\n  ring, -- This follows by algebra.\nend\n", "The basic ideas behind this proof are similar to those from the previous level on\ncommutativity of greatest common divisor.\n", "Approaching the proof", "Suppose $d$ is a greatest common divisor of $a$ and $b$. Then $-d$ is also a greatest common\ndivisor of $a$ and $b$.\n", "end exlean -- hide", "import tactic.linarith divisibility.gcd_neg -- hide\n", "# Divisibility\n\n## Level 19: B\u00e9zout's lemma (version 2)\n", "namespace exlean -- hide\n", "You'll show that for all integers $a$ and $b$, there exists a *non-negative integer* $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n\nThis is a slight variant of our previous version of B\u00e9zout's lemma. The only difference being the\nnonnegativity of $d$. The simplest apporach to this problem is to use the result `bezout1`\ntogether with our result `gcd_neg` from the last level.\n", "open int -- hide\n", "variables (a b : \u2124) -- hide\n", "The lemma `nonneg_or_nonneg_neg'` will be useful.\n", "lemma nonneg_or_nonneg_neg' (a : \u2124) : (0 \u2264 a) \u2228 (0 \u2264 -a) :=\nbegin\n  by_cases h : 0 \u2264 a,\n  { left, from h, },\n  { right,\n    linarith, },\nend\n", "\nYou can start by decomposing `bezout1 a b`.\n```\nrcases (bezout1 a b) with \u27e8e, x, y, hgcd, heq\u27e9,\ngiven hgcd : greatest_common_divisor a b e,\ngiven heq : e = a * x + b * y,\nsorry,\n```\n\nIf you do this unthinkingly, you might suspect the next step would be to take `d` to be `e`.\nBut `e` might not be nonnegative.\n\nThus, you shoud proceed by cases on `nonneg_or_nonneg_neg e`. For example,\n```\ncases (nonneg_or_nonneg_neg' e) with hnn hnp,\n```\n", "Starting the proof", "example : 0 \u2264 a \u2228 0 \u2264 -a := nonneg_or_nonneg_neg' a\n", "For all integers $a$ and $b$, there exists a non-negative integer $d$ such that\n$d$ is a greatest common divisor of $a$ and $b$.\n", "end exlean -- hide", "import tactic.linarith divisibility.bezout2  -- hide\n", "# Divisibility\n\n## Level 20: The Euclidean algorithm - basic step\n", "namespace exlean -- hide\n", "As a result of B\u00e9zout's lemma, we can define a *function* `gcd` such that `gcd a b` is\nthe greatest common divisor of `a` and `b`.\n", "noncomputable theory\nlemma gcd_exists (a b : \u2124) : \u2203 (d : \u2124), (greatest_common_divisor a b d \u2227 0 \u2264 d) :=\nbegin\n  rcases bezout a b with \u27e8d, s, t, h, h\u2082, h\u2083\u27e9,\n  from \u27e8d, h, h\u2082\u27e9,\nend\nnoncomputable def gcd (a b : \u2124) := classical.some (gcd_exists a b)\nnoncomputable def egcd (a b : \u2124) := classical.some (bezout a b)\n", "(greatest_common_divisor (gcd a b) a b) \u2227 (0 \u2264 gcd a b)\n", "lemma greatest_common_divisor_gcd (a b : \u2124) :\n(greatest_common_divisor a b (gcd a b)) \u2227 (0 \u2264 gcd a b) :=\nbegin\n  apply @classical.some_spec _ (\u03bb d, (greatest_common_divisor a b d) \u2227 (0 \u2264 d)),\nend\n", "The lemma `greatest_common_divisor_gcd` asserts that `gcd a b` is a greatest common divisor of `a`\nand `b` and that `0 \u2264 gcd a b`\n", "example (a b : \u2124) : (greatest_common_divisor a b (gcd a b)) \u2227 (0 \u2264 gcd a b) :=\nbegin\n  from greatest_common_divisor_gcd a b,\nend\n", "You may be wondering how `gcd` is defined in Lean. Essentially, I use the Axiom of Choice.\nThe details are unimportant to your understanding of this mathematical topic, but the intrepid\nmay read on!\n\nLean provides two functions, `classical.some` and `classical.some_spec` that are, in a sense,\ngeneralisations of the Axiom of Choice. The functions work in harmony with each other.\n\nLet `P` be a predicate on a type `\u03b1`. Then the function\n`classical.some` produces a term of type `\u03b1` given the proof of `\u2203 d, P(d)`, for a predicate `P`.\nIn our case, `P` is the predicate defined so `P(d)` means `greatest_common_divisor a b d \u2227 0 \u2264 d`,\nfor fixed integers `a` and `b`. From B\u00e9zout's theorem, we can prove\n```\nh : \u2203 (d : \u2124), greatest_common_divisor a b d \u2227 0 \u2264 d\n```\nWe define `gcd a b` to be the integer produced by `classical.some h`.\n\nThe discussion above says nothing about the properties of the integer produced by\n`classical.some h`. This is where `classical.some_spec` enters the picture. The theorem\n`classical.some_spec` asserts `P(classical.some h)`.\n\nWrite `d` for `gcd a b`. Then `d` is the integer producesd by `classical.some h`. Hence `P(d)`\nholds. By definition of `P`, this means `greatest_common_divisor a b d \u2227 0 \u2264 d`.\n\nThis is the theorem we call `greatest_common_divisor_gcd`.\n\nBut why use the Axiom of Choice? In general, one should only use the Axiom of Choice (and related\nprinciples) if it is unavoidable. Unfortunately, functions defined via the Axiom of Choice are\nnot computable. There is a better way to define the gcd (essentially using Euclid's algorithm),\nbut this approach works better for teaching purposes.\n", "Under the hood: how is `gcd` defined?", "open int -- hide\n", "### Task\nSuppose $a = bq + r$. Show that $\\gcd(a,b) = \\gcd(b,r)$. This result is a crucial component of\nEuclid's algorithm for computing greatest common divisors.\n\nThe result isn't easier, but it should not be as difficult s some of the 'challenging' levels.\n", "As usual, we'll use `rcases` to decompose the hypotheses. We'll also label commonly-arising\nquantities via the `set` tactic.\n```\nset a := b * q + r with ha,\nrcases (greatest_common_divisor_gcd a b) with \u27e8\u27e8\u27e8hda, hdb\u27e9, hngtd\u27e9, hdnn\u27e9,\nrcases (greatest_common_divisor_gcd b r) with \u27e8\u27e8\u27e8heb, her\u27e9, hngte\u27e9, henn\u27e9,\nset d := gcd a b,\nset e := gcd b r,\n```\nThe `set` lines above provide a convenient shorthand, replacing `gcd a b` everywhere with `d`,\nfor example. In the first `set` line, we use `with ha` to introduce into\nthe context `ha : a = b * q + r`. This is necessary if we ever need to replace `a` with\n`b * q + r`.\n", "Starting the proof and setting variables", "Here, you have to prove $d = e$, where $d = \\gcd(a,b)$ and $e = \\gcd(b,r)$. Since this is a \nproblem about divisibility, it's a good idea to use antisymmetry of divisibility.\n```\napply dvd_antisymm hdnn henn,\n```\nwhere `hdnn : 0 \u2264 d` and `henn : 0 \u2264 e`, as derived in the hint above.\n\nDoing this introduces two new goals: to prove `d \u2223 e` and to prove `e \u2223 d`.\nThe fact that $e$ is the greatest common divisor of $b$ and $r$ will help in proving the first\ngoal. A similar approach works for the second goal.\n", "How do I prove equality?", "In the second goal (for instance), you'll at some point need to prove $d \\mid r$. You know\n$d \\mid a$ and $d \\mid b$. You can first prove (by `linarith`) that `r = a * 1 + b * (-q)`\nand rewrite using this equation. Then it remains to prove `d \u2223 a * 1 + b * (-q)`. A lemma\nfrom a previous level will complete this goal.\n", "How do I prove $d \\mid r$?", "variables {a : \u2124}  -- hide\n", "Suppose $a$, $b$, $q$, $r$ are integers and that $a = bq + r$.\nThen $\\gcd(a, b) = \\gcd(b, r)$.\n", "end exlean -- hide", "import tactic.linarith divisibility.euclid_basic  -- hide\n", "# Divisibility\n\n## Level 21: The Euclidean algorithm\n", "namespace exlean -- hide\n", "Using the result `euclid_basic` from our previous level, we can *compute* greatest common divisors.\n", "open int -- hide\n", "variables (a b d q r x y: \u2124)  -- hide\n", "As an example, we'll compute $\\gcd(100,7)$. As a first step, we'll use `euclid_basic` to justify\nthe assertion that $\\gcd(100,7) = \\gcd(7, 2)$. The reason for this is that \n$100 = 7 \\times 14 + 2$, so $\\gcd(7 \\times 14 + 2, 7) = \\gcd(7, 2)$, by `euclid_basic`.\n\nHere ia a proof in Lean.\n", "example : gcd 100 7 = gcd 7 2 := euclid_basic 7 14 2\n", "In the above proof, note that the arguments  $7$, $14$, and $2$ correspond to the calculation\n$100 = 7 \\times 14 + 2$.\n", " (h\u2081 : greatest_common_divisor d a b) (h\u2082 : 0 \u2264 d) : gcd a b = d\n", "lemma gcd_eq_greatest_common_divisor {a b d : \u2124} (h\u2081 : greatest_common_divisor a b d) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\nbegin\n  rcases (greatest_common_divisor_gcd a b) with \u27e8hxgreat, hxnn\u27e9,\n  from uniqueness_of_greatest_common_divisor hxnn h\u2082 hxgreat h\u2081,\nend\n", "In later worlds, we'll have occasion to use the lemma `gcd_eq_greatest_common_divisor`. This states\nthat if $d$ is a greatest common divisor of $a$ and $b$ and if $d$ is non-negative, then\n$\\gcd(a,b) = d$.\n", "example (h\u2081 : greatest_common_divisor a b d) (h\u2082 : 0 \u2264 d) : gcd a b = d :=\ngcd_eq_greatest_common_divisor h\u2081 h\u2082\n", "gcd a 0 = |a|\n", "lemma gcd_zero : gcd a 0 = |a| :=\nbegin\n  refine gcd_eq_greatest_common_divisor  _ (abs_nonneg a),\n  rcases abs_cases a with \u27e8habs, hineq\u27e9 | \u27e8habs, hineq\u27e9; rw habs,\n  { apply greatest_common_divisor_zero, },\n  { split,\n    { split,\n      { rw neg_dvd, },\n      { apply dvd_zero, }, },\n    { rintros e \u27e8ha, _\u27e9,\n      apply dvd_neg_of_dvd ha, }, },\nend\n", "We'll apply this process repeatedly until we reach $\\gcd(a, 0)$, for some integer $a$. We then\nuse the lemma `gcd_zero`.\n", "example : gcd a 0 = abs a := gcd_zero a\n", "Below is a Lean proof that 1 is a greatest common divisor of 7 and 100.\n", "example : gcd 100 7 = 1 :=\nbegin\n  calc gcd 100 7\n      = gcd 7 2 : euclid_basic 7 14 2\n  ... = gcd 2 1 : euclid_basic 2  3 1\n  ... = gcd 1 0 : euclid_basic 1  2 0\n  ... = 1       : gcd_zero 1,\nend\n", "### Task\n\nAdapt the proof above to show that $\\gcd(340, 23) = 1$. The proof is nothing more than a few lines\nof calculation.\n", "Try this:\n```\ncalc gcd 340 23\n    = gcd 23 18 : euclid_basic 23 14 18\n... = 1         : sorry\n```\nYou will need to add about 5 additional lines of calculation and, finally, to replace `sorry` with\n`gcd_zero 1`.\n\n", "A proof template", "$\\gcd(340, 23) = 1$\n", "end exlean -- hide", "Congruences", "import divisibility.euclidean_algorithm tactic.norm_cast -- hide\n", "#  Congruences\n\n## Level 1: The definition of congruence\n\nThe notation `a \u2261 b [MOD n]`, read '`a` is congruent to `b` modulo `n`' means `n \u2223 b - a`. \n\nType `\u2261` as `\\==`.\n", "namespace exlean -- hide\n", "def modeq (n a b : \u2124) := n \u2223 b - a  -- hide\n", "notation a ` \u2261 `:50 b ` [MOD `:50 n `]`:0 := modeq n a b -- hide\n", "If you forget this definition or ever want to replace `a \u2261 b [MOD n]` with the definition in a proof, use\nthe result `mod_def`.\n", "variables {a b n : \u2124} -- hide\n", "a \u2261 b [MOD n] \u2194 n \u2223 b - a\n", "lemma mod_def : a \u2261 b [MOD n] \u2194 n \u2223 b - a := by refl -- hide\n", "For example, we will prove that `17 \u2261 45 [MOD 7]`. The `rw` and `show` lines here are\nunnecessary, but may be helpful in understanding how to apply definitions.\n\nIn the first line, we rewrite `\u22a2 17 \u2261 45 [MOD 7]` using the definition of congruence to give\n`\u22a2 7 \u2223 45 - 17`.\n\nUsing the definition of divisibility, this becomes `\u22a2 \u2203 (m : \u2124), 45 - 17 = 7 * m`.\n\nTo prove this existentially-quantified statement, we take `m` to be `4`. The result follows by\narithmetic.\n", "example : 17 \u2261 45 [MOD 7] :=\nbegin\n  rw mod_def, -- show `7 \u2223 45 - 17`.\n  show \u2203 (m : \u2124), 45 - 17 = 7 * m,\n  use 4,      -- Take 'm' to be 4. `\u22a2 45 - 17 = 7 * 4`,\n  norm_num,\nend\n", "If you were to write the proof 'by hand', you might write the following:\n\n> By definition, we must prove `7 \u2223 45 - 17`. That is, that `45 - 17 = 7 * m`, for some `m`.\n> This holds if one takes `m` to be `4`.\n", "### Tasks\n* By making a minor variation to the proof above, show that `60 \u2261 38 [MOD 11] `.\n\n* Write the same proof by hand.\n", "`60 \u2261 38 [MOD 11]` \n", "end exlean -- hide", "import congruences.mod_def -- hide\n", "#  Congruences\n\n## Level 2: Reduction of an integer modulo $n$\n", "namespace exlean -- hide\n", "Let $x$ and $n$ be integers with $n \\ne 0$. One can find an integer $a$ in the range $0 \\le a < |n|$\nsuch that $x \\equiv a \\pmod n$.\n\nThis is sometimes called _reduction_ of $x$ modulo $n$.\n", "variables {x a n : \u2124} -- hide\n", "We'll find a number $a$ such that $321 \\equiv a \\pmod{12}$ and such that $0 \\le a < |12|$\n\nFor $a$, I'll take the remainder on dividing $321$ by $12$. Note that\n$321 = q \\times 12 + r$, where $q = 26$ and $r = 9$.\n", "example : \u2203 (a : \u2124), 321 \u2261 a [MOD 12] \u2227 ((0 \u2264 a) \u2227 (a < |12|)) :=\nbegin\n  use 9,          -- `\u22a2 321 \u2261 9 [MOD 12] \u2227 ((0 \u2264 9) \u2227 (9 < |12|))`\n  split,\n  { rw mod_def,   -- By definition, we must show `63 \u2223 59 - 600`.\n    norm_num, },\n  tidy,           -- Prove `(0 \u2264 9) \u2227 (9 < |12|)`.\nend\n", "### Task\n\nAdapting the proof above, show that there is an integer $a$ such that\n$500 \\equiv a \\pmod{63}$ with $0 \\le a < |63|$.\n\n", "There is an integer $a$ such that $500 \\equiv a \\pmod{63}$ with\n$0 \\le a < |63|$.\n", "end exlean -- hide", "import congruences.reduction1 -- hide\n", "#  Congruences\n\n## Level 3: Reflexivity and symmetry of mod\n", "namespace exlean -- hide\n", "As a first proper theorem on congruences, we'll show that `\u2261` is a reflexive relation.\n", "variables {a b n : \u2124} -- hide\n", "a \u2261 a [MOD n]\n", "lemma mod_refl : a \u2261 a [MOD n] :=\nbegin\n  show n \u2223 a - a,\n  rw (show a - a = 0, by norm_num),\n  show n \u2223 0,\n  apply dvd_zero,\nend\n", "A handwritten proof might be:\n\n> By definition of congruence, it suffices to prove $n \\mid a - a$. That is, to prove $n \\mid 0$.\n> But every integer divides zero. \u220e\n", "Alternatively, the result can be proved directly from the definitions, without using previous\nresults on divisibility.\n", "example : a \u2261 a [MOD n] :=\nbegin\n  show \u2203 m, a - a = n * m,\n  use 0,\n  show a - a = n * 0, by norm_num,\nend\n", "### Tasks\n* Show that `\u2261` is a symmetric relation.\n\n* Write the same proof by hand.\n", "\nIn the problem below, you are _given_ a congruence `h : a \u2261 b [MOD n]`, which corresponds\nto the statement `n \u2223 b - a`.\nYou need to show `b \u2261 a [MOD n]`. That is, to show `n \u2223 a - b`. There are two approaches to this\nproblem.\n\n* You could rewrite the target to one of proving `n \u2223 -(b - a)` and then use\n  a result from the divisibility world.\n\n* Alternatively, you could note that `h` is a proof of `\u2203 m, b - a = n`\n  To extract information\n  from this statement, use either `cases` or `rcases`.\n\n  For example, write `cases h with m h\u2082` to produce an integer `m` and the hypothesis\n  `h\u2082 : b - a = n * m`.\n", "Two approaches to the proof", "The relation `\u2261` is symmetric.\n", "end exlean -- hide", "import congruences.mod_refl_symm -- hide\n", "#  Congruences\n\n## Level 4: Transitivity of mod\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "Your next task is to prove that `\u2261` is transitive. That is, assuming `a \u2261 b [MOD n]` and\n`b \u2261 c [MOD n]` to prove `a \u2261 c [MOD n]`. The clever way to do this is to invoke an appropriate\nresult you've already seen concerning divisibility. \n", "As an example of the kind of technique you'll need, we'll give a proof that $a \\mid b + 2c + d$\ngiven $h_1 : a \\mid b + c$ and $h_2 : a \\mid c + d$.\n\nFirst we note $h_3 : b + 2c + d = (b + c) + (c + d)$. Rewriting with $h_3$, the goal becomes\n$\\vdash a \\mid (b + c) + (c + d)$. Applying the 'addition of divisibility' result, it suffices\nto prove two new goals (1) $a \\mid b + c$ and (2) $a \\mid c + d$. The first of these goals follows\nfrom $h_1$ and the second from $h_2$.\n\nNote the use of the `apply` tactic to construct new goals from the conditions of the `dvd_add`\ntheorem.\n", "example (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  have h\u2083 : b + 2 * c + d = (b + c) + (c + d), linarith,\n  rw h\u2083,\n  show a \u2223 (b + c) + (c + d),\n  apply dvd_add,\n  { show a \u2223 b + c, from h\u2081 },\n  { show a \u2223 c + d, from h\u2082 },\nend\n", "We can prove the same result more briefly by (a) dispensing with additional hypothesis `h\u2083` and\nrewriting 'in place' via 'show' and (b) giving `apply` the desired conditions without the need\nto introduce additional goals.\n", "example (h\u2081 : a \u2223 b + c) (h\u2082 : a \u2223 c + d) : a \u2223 b + 2 * c + d :=\nbegin\n  rw (show b + 2 * c + d = (b + c) + (c + d), by linarith),\n  apply dvd_add h\u2081 h\u2082,\nend\n", "### Tasks\n* Show that `\u2261` is a transitive relation.\n\n* Write the same proof by hand.\n", "Start by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n\nYou can then either decompose the hypothesis and do some arithmetic or you can use a\nresult from the divisibility world.\n", "Starting the problem", "If you took the hint above, the target will be `\u22a2 n \u2223 c - a`. If you want to use a result\nfrom the divisibility world, a clever idea is to write `c - a` as `(c - b) + (b - a)`.\n\nOne way to do this is via:\n```\nhave h\u2083 : c - a = (c - b) + (b - a), by linarith,\nrw h\u2083,\n```\n\nAlternatively,\n```\nrw (show c - a = (c - b) + (b - a), by linarith),\n```\nThe latter approach obviates the need for an additional hypothesis.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n", "A clever rewriting", "The relation `\u2261` is transitive.\n", "end exlean -- hide", "import congruences.mod_trans -- hide\n", "#  Congruences\n\n## Level 5: A condition for an integer to be congruent to zero\n", "namespace exlean -- hide\n", "variables {a n : \u2124} -- hide\n", "### Tasks\n* Let $a$ and $n$ be integers. Prove, by hand, that $0 \\equiv a \\pmod n$ if and only if $n \\mid a$.\n\n\n* Write the same proof in Lean.\n", "At some point in your proof, you may want to replace `a - 0` with `a`.\nWe can easily prove `a - 0 = a` using `linarith`, so you can do the\nreplacement with\n```\nrw (show a - 0 = a, by linarith)\n```\nAs it happens, the proof of `a - 0 = a` is known to Lean as `sub_zero`,\nso you could alternatively do `rw sub_zero`.\n", "Rewriting with easy equations", "Let $a$ be an integer. Then $0 \\equiv a \\pmod n \\leftrightarrow n \\mid a$.\n", "end exlean -- hide", "import congruences.modeq_zero_iff   -- hide\n", "#  Congruences\n\n## Level 6: Multiplying a congruence on the right\n", "namespace exlean -- hide\n", "variables {a b c n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]`, show `a * c \u2261 b * c [MOD n]`. As in the previous level, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n", "Start by rewriting the target and hypotheses with the definition of congruence. Do this with\n`rw mod_def at *`.\n", "Starting the problem", "The expression `b * c - a * c` in the target can be factored to `(b - a) * c` using the technique\nshown in a previous level, namely,\n```\nrw (show b * c - a * c = (b - a) * c, by linarith),\n```\n\nIn fact, this factoring result is built in to Lean's mathematical library as the lemma `sub_mul`.\nSo you could, alternatively, use `rw \u2190sub_mul`.\n\nAfter rewriting (by either method), you can use one of the divisibility lemmas (see the sidebar)\nto finish the proof.\n", "Factoring", "Given `a \u2261 b [MOD n]`, the congruence `a * c \u2261 b * c [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_mul_right -- hide\n", "#  Congruences\n\n## Level 7: Adding congruences\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a + c \u2261 b + d [MOD n]`. As before, you can prove\nthis using an appropriate divisibilty lemma.\n\n* Write the same proof by hand.\n", "Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a + c \u2261 b + d [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_add -- hide\n", "#  Congruences\n\n## Level 8: Multiplying congruences\n", "namespace exlean -- hide\n", "variables {a b c d n : \u2124} -- hide\n", "### Tasks\n* Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, show `a * c \u2261 b * d [MOD n]`.\n\n* Write the same proof by hand.\n\nThe nicest way to do this is by using two different divisibility results.\n", "As before, start by converging the congruences to divisibility statements using `rw mod_def at *`.\n", "Starting the proof", "Your next task is to rewrite the goal from `n \u2223 b * d - a * c` to something of the form\n`n \u2223 p + q`, for appropriate `p` and `q`. You can then use `apply dvd_add`.\n\nYou should then `apply` another of the divisibility results to each of the\nresulting goals.\n", "A cunning rewrite", "Given `a \u2261 b [MOD n]` and `c \u2261 d [MOD n]`, the congruence `a * c \u2261 b * d [MOD n]` follows.\n", "end exlean -- hide", "import congruences.mod_mul  -- hide\n", "#  Congruences\n\n## Level 9: Reduction of congruences\n", "namespace exlean -- hide\n", "variables {n m a b : \u2124} -- hide\n", "We've seen the idea of reducing an integer $x$ modulo $n$. This means finding an integer $a$\nsuch that $x \\equiv a \\pmod n$ with $0 \\le a < |n|$.\n\nThe word 'reduction' has another meaning in the study of congruences.\n\nSuppose $a$, $b$, $n$ and $m$ are integers with $m \\mid n$. Suppose $a \\equiv b \\pmod n$.\nIt follows that $a \\equiv b \\pmod m$. This is called the _reduction of the congruence_\n$a \\equiv \\pmod n$, modulo $m$.\n", "### Task\nProve the reduction result mentioned above. You should be able to do this in one line by employing\nan appropriate result from Divisibility World.\n\n", "Given $m \\mid n$ and $a \\equiv b \\pmod n$, the congruence $a \\equiv b \\pmod m$ follows.\n", "end exlean -- hide", "import congruences.mod_reduction -- hide\n", "#  Congruences\n\n## Level 10: Reduction of integers in general\n", "namespace exlean -- hide\n", "We now return to the other meaning of reduction. You will show that for all integers $x$ and $n$\nwith $n \\ne 0$, there exists an integer $a$ in the range $0 \\le a < |n|$ such that\n$x \\equiv a \\pmod n$.\n\nThe statement above has some similarity with the `division` lemma, as seen in Divisibility World.\n", "variables {x a n : \u2124} -- hide\n", "Start by applying `division` to `x n h` and then decomposing the result:\n```\nrcases division x n h with \u27e8q, r, h\u2082 : x = n * q + r, h\u2083 : 0 \u2264 r, h\u2084 : r < |n|\u27e9,\nsorry,\n```\n", "A proof template", "For every non-zero integer $n$, there exists an integer $a$ such that $x \\equiv a \\pmod n$ with\n$0 \\le a < |n|$.\n", "end exlean -- hide", "import congruences.reduction2  -- hide\n", "#  Congruences\n\n## Level 11: A necessary condition for solving a linear congruence\n", "namespace exlean -- hide\n", "variables {n d a b x : \u2124} -- hide\n", "Suppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n", "### Task\nProve the reduction result mentioned above, first by hand and then in Lean.\n", "Recall that if $d \\mid n$, and $s \\equiv t \\pmod n$, then $s \\equiv t \\pmod d$. We called this result\n`modeq_of_dvd_of_modeq`.\n", "A useful result", "Suppose $d$ is a common divisor of integers $a$ and $n$. The linear congruence\n$a x \\equiv b \\pmod n$ has a solution only if $d \\mid b$.\n", "end exlean -- hide", "import congruences.condition_for_linear_congruence -- hide\n", "#  Congruences\n\n## Level 12: A linear congruence without a solution\n", "namespace exlean -- hide\n", "variables {x : \u2124} -- hide\n", "It's easy to check that a given value $x$ _is_ a solution of a linear congruence.\n", "example (h : x = 5) : 7 * x \u2261 3 [MOD 4] :=\nbegin\n  rw h, -- `\u22a2 7 * 5 \u2261 3 [MOD 4]`\n  use -8, -- `\u22a2 3 - 7 * 5 = 4 * -8`\n  norm_num,\nend\n", "It's significantly more difficuult to show that a congruence doesn't have a solution.\n\nIn the previous level, you showed that the congruence $ax \\equiv b \\pmod n$ has a solution only if\n$d \\mid b$, where $d$ is a common divisor of $a$ and $n$.\n\nIn this level, you'll use this to show that a certain linear congruence has no solutions.\nThis boils down to showing that a number doesn't divide another number, a topic we covered in\nDivision World.\n", "### Task\n\nUsing the ideas above and any other lemmas you've seen, show that\nthere is no $x$ for which  $12 x \\equiv 10 \\pmod {60}$.\n", "The congruence $12 x \\equiv 10 \\pmod {60}$ has no solution for $x$.\n", "end exlean -- hide", "import congruences.linear_congruences_no_soln-- hide\n", "#  Congruences\n\n## Level 13: Solving a linear congruence\n", "namespace exlean -- hide\n", "variables {a n x : \u2124} -- hide\n", "We've seen a necessary condition for a linear congruence to have a solution. You'll now prove a\nsufficient condition.\n\nSpecifically, you'll show that if $1$ is a greatest common divisor of $a$ and $n$, then the \ncongruence $ax \\equiv 1 \\pmod n$ has a solution for $x$.\n", "### Task\n\nProve the result above, both by hand and in Lean.\n", "From the Divisibility world, you'll need both B\u00e9zout's Lemma and the uniqueness\nof greatest common divisor.\n", "Useful results", "Use the following to start your proof.\n```\nrcases (bezout a n) with \u27e8d, s, t, hgcd, hdnn, heq\u27e9,\nsorry,\n```\n", "A proof template", "If $1$ is a greatest common divisor of $a$ and $n$, then there exists an integer $x$ such that\n$a x \\equiv 1 \\pmod n$.\n", "end exlean -- hide", "Groups I", "import  group.basic -- hide\n", "# Groups\n\n## Level 1: The group axioms; the inverse of an inverse\n", "A group $(G, \\ast)$ is a type (or set) $G$ together with a binary operation $\\ast : G \\times G \\to G$\nand a special element $e_G \\in G$ satisfying the following properties (called the _group axioms_):\n* [identity] for every $a : G$, $a \\ast e_G = a$ and $e_G \\ast a = a$.\n* [associativity] for all $a, b, c : G$, $(a \\ast b) \\ast c = a \\ast (b \\ast c)$\n* [inverse] for every $a : G$, there exists $b : G$ such that $a \\ast b = e_G$ and $b \\ast a = e_G$.\n", "### Groups in Lean\n\nIn Lean, we write $1$ for the identity element $e_G$ of a group. The symbol `1` here isn't \n(necessarily) the same as the ordinary number $1$.\n\nThe group axioms in Lean are the following:\n* `mul_one : \u2200 (a : G), a * 1 = a`\n* `one_mul : \u2200 (a : G), 1 * a = a`\n* `mul_assoc : \u2200 (a b c : G), (a * b) * c = a * (b * c)`\n* `mul_left_inv : \u2200 (a : G), a\u207b\u00b9 * a = 1` (note `a\u207b\u00b9` is typed `a\\inv` or `a\\-1`)\n\nIf you forget them, you can refresh your memory using the 'Groups' drop-down in the\n'Theorem statements' drop-down menu on the left \n\nHere are the group axioms in practice.\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "(a : G) : a * 1 = a\n", "(a : G) : 1 * a = a\n", "(a b c : G) : (a * b) * c = a * (b * c)\n", "(a : G) : a\u207b\u00b9 * a = 1\n", "example : a * 1 = a := mul_one a\nexample : 1 * a = a := one_mul a\nexample : (a * b) * c = a * (b * c) := mul_assoc a b c\nexample : a\u207b\u00b9 * a = 1 := mul_left_inv a\n", "Together, `mul_one` and `one_mul` are equivalent to the 'normal' group identity axiom; `mul_assoc`\nis the same as the normal associativity axiom. The odd-one-out is `mul_left_inv`.\n\nRather than merely asserting the existence of an inverse of `g`, we name the inverse `g\u207b\u00b9`.\nMoreover, the `mul_left_inv` axiom only provides that `g\u207b\u00b9` is a left inverse of `g`.\nAs we'll soon see, the right inverse property can be proved from the other properties.\n\n", "### Uniqueness of identity\n\n**Theorem**:\nSuppose $b$ is an element of $G$ such that for every $a : G$, $b \\ast a = a$,\nthen $b = 1$.\n\nWe'll give a proof 'by calculation'. This is a series of equations, each with its own proof, \nstarting with the left-side and ending with the right-side of the desired equation $b = 1$.\n\n**Proof**:\n$$\n\\begin{align}\nb &= b \\ast 1 && \\text{[by identity axiom (mul one)]}\\\\\\\\\n&= b \\ast (b^{-1} \\ast b) && \\text{[by left inverse]} \\\\\\\\\n& = (b \\ast b^{-1}) \\ast b && \\text{[by associativity]} \\\\\\\\\n& = b^{-1} \\ast b && \\text{[by the hypothesis]} \\\\\\\\\n& = 1. && \\text{[by left inverse]}\n\\end{align}\n$$\n\u220e\n", "The Lean proof of this result is remarkably similar to the handwritten proof:\n", "(h : \u2200 (a : G), b * a = a) : b = 1\n", "lemma eq_one_of_self_mul_eq (h : \u2200 (a : G), b * a = a) : b = 1 :=\nbegin\n  calc\n    b = b * 1         : by rw mul_one\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n  ... = b\u207b\u00b9 * b       : by rw h\n  ... = 1             : by rw mul_left_inv\nend\n", "Above, `calc` indicates that we are starting a proof by calculation. The\nproof for each line of calculation is shown after the colon.\n\nConsider the following two lines from the proof.\n```\n  ... = b * (b\u207b\u00b9 * b) : by rw mul_left_inv\n  ... = (b * b\u207b\u00b9) * b : by rw mul_assoc\n```\nThe second line asserts `b = (b\u207b\u00b9 * b) = (b * b\u207b\u00b9) * b`, the proof of which is: `by rw mul_assoc`\n", "### Tasks\n\n* By hand, write a proof that if $a$ is an element of a group $G$, then $(a^{-1})^{-1} = a$. Use\nonly the group axoims from Lean (in particular, you may not use the 'right inverse' property).\n\n* Complete the Lean 'proof by calculation' below. I have supplied a suggested first\nline of the proof. You will need to add intermediate lines and replace all\n`sorry`s with proofs. I suggest working from top to bottom, one line at a time. By this process,\nyou may check if your proof is 'structurally correct', the test of which is that Lean will\nprovide no error message.\n", "The inverse of the inverse of $a$ is $a$.\n", "end exlean -- hide", "import  group.inv_inv -- hide\n", "# Groups\n\n## Level 2: Right inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "In the previous level, we introduced the left inverse axiom for groups. In this level, you'll\n*prove* that the right inverse property follows from the other group axioms.\n\n\n### Tasks\n\n* By hand, write a proof that if $b$ is an element of a group $G$, then $b * b^{-1} = 1$. You may\nuse any axioms or theorems proved in the previous level.\n\n* Complete the Lean 'proof by calculation' below.\n", "$b \\ast b^{-1} = 1$.\n", "end exlean -- hide", "import group.mul_right_inv -- hide\n", "# Groups\n\n## Level 3: Uniqueness of inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] {a b c : G} -- hide\n", "In the first level of this world, you saw the 'uniqueness of identity' result. In this level,\nyou'll prove an equivalent 'uniqueness of inverse' result.\n\n\n### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$ and if $a \\ast b = 1$, then\n$a^{-1}$ equals $b$. You will only need the group axioms.\n\n* Write a Lean proof by calculation, using only the group axioms.\n", "If $a \\ast b = 1$, then $a^{-1} = b$.\n", "end exlean -- hide", "import group.unique_inverse -- hide\n", "# Groups\n\n## Level 4: The inverse of a product\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} [group G] (a b c : G) -- hide\n", "### Tasks\n\n* By hand, write a proof that if $a, b$ are elements of a group $G$, then\n$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n\n* Complete the Lean proof below.\n", "You've seen `inv_eq_of_mul_eq_one`. This result states that if `s * t = 1`, then `s\u207b\u00b9 = t`.\nHere, you can apply this result, via `apply inv_eq_of_mul_eq_one` to change the\ngoal to one of proving `(a * b) * (b\u207b\u00b9 * a\u207b\u00b9) = 1`.\n\nThis latter goal can be proved by calculation.\n", "A helpful result", "$(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}$.\n", "end exlean -- hide", "import  group.mul_inv_rev -- hide\n", "# Groups\n\n## Level 5: Left cancellation\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G}  -- hide\n", "Just as with 'ordinary' multiplication, we can cancel the same factor on the left of\nboth sides of an equation.\n\n### Tasks\n\n* Give a handwritten proof that if $a \\ast b = a \\ast c$, then $b = c$.\n\n* Give a Lean 'proof by calculation' below.\n", "If $a \\ast b = a \\ast c$, then $b = c$.\n", "end exlean -- hide", "import  group.left_cancellation -- hide\n", "# Groups\n\n## Level 6: Injectivity of inverse\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G)  -- hide\n", "One way to prove two group elements are equal is to show that their inverses are equal.\n\n### Tasks\n\n* Give a handwritten proof that if $a$ and $b$ are group elements, then\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n\n* Give a Lean proof of this result.\n", "Let $a$ and $b$ be elements of a group $G$. We have\n$a^{-1} = b^{-1} \\leftrightarrow a = b$.\n", "end exlean -- hide", "import  group.injectivity_of_inverse -- hide\n", "# Groups\n\n## Level 7: Right cancellation\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G)  -- hide\n", "From the left cancellation result, we cheaply prove an iff result.\n", "(a b c : G) : a * b = a * c \u2194 a = b\n", "lemma mul_left_cancel_iff : a * b = a * c \u2194 b = c :=\nbegin\n  split,\n  { assume h : a * b = a * c,\n    show b = c, exact mul_left_cancel h, },\n  { assume h : b = c,\n    show a * b = a * c, rw h,\n  }\nend\n", "### Tasks\n\n* Give a handwritten proof of the right cancellation result, that\n$b \\ast a = c \\ast a \\leftrightarrow b = c$. \n\n* Give a Lean proof of this result.\n", "A proof by calculation will work here. The result `inv_inj` may prove to be highly effective.\n", "Proof ideas", "Let $a$ and $b$ be elements of a group $G$. We have\n$b \\ast a = c \\ast a \\leftrightarrow b = c$.\n", "end exlean -- hide", "import  group.right_cancellation group.power_def -- hide\n", "# Groups\n\n## Level 8: Powers\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G) {n m : \u2115} -- hide\n", "Exponentiation is defined to be repeated multiplication. That is, if $a$ is an element of a group\n$G$, then $a^0 := 1$ and $a^{n + 1} := a \\ast a^n$, for a natural number $n$.\n\nIn Lean, these defining equations are called `pow_zero` and `pow_succ`.\n", "(a : G) : a ^ 0 = 1\n", "(a : G) : a ^ (n + 1) = a * a ^ n\n", "example : a ^ 0 = 1 :=\nbegin\n  rw pow_zero,\nend\n", "-- hide\n", "example : a ^ (n + 1) = a * a ^ n :=\nbegin\n  rw pow_succ,\nend\n", "In the next few levels, we will prove the laws of indices.\nThat is, we'll show that if $a : G$ and $n, m : \\mathbb N$, then:\n* $a ^ 1 = a$,\n* $1 ^ n = 1$,\n* $a ^{n + m} = a ^ n \\ast a ^ m$,\n* $a^{nm} = (a ^ n) ^ m$.\n", "### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n", "Any arithmetic result you may need for this level can be proved using the\n`trivial` tactic.\n", "Proving arithmetic results", "$a^1 = a$, for $a$ an element of a group.\n", "end exlean -- hide", "import group.pow_one tactic.modded -- hide\n", "# Groups\n\n## Level 9: One pow\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n", "In this level, you'll prove, by induction on $n$, that\n$1 ^ n = 1$, for every natural number $n$. Here, $1$ is the\nidentity element in the group $G$.\n\nSometimes, you will need to write `(1 : G)` otherwise Lean will treat\n`1` as the natural number $1$ rather than the identity in the group $G$.\n", "### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n", "$1^n = 1$, for $n$ a natural number and $1$ the identity in a group.\n", "end exlean -- hide", "import group.one_pow tactic.modded -- hide\n", "# Groups\n\n## Level 10: Pow succ prime\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G) {n m : \u2115} -- hide\n", "By definition, $g^{n + 1} = g \\ast g^n$. We will now prove that\n$g^{n + 1} = g^n \\ast g$.\n", "### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result. While writing your\nproof, ensure to fill in the underscores in the inductive step\nto state both the inductive hypothesis and the result to be proved.\n\n", "$a^{n + 1} = a^n \\ast a$, for $n$ a natural number and $a$ an\nelement of the group $G$.\n", "end exlean -- hide", "import group.pow_succ_prime tactic.modded -- hide\n", "# Groups\n\n## Level 11: Adding exponents\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n", "In this level, you will prove $a^{m + n} = a^m \\ast a^n$ for\n$a$ in a group $G$ and natural numbers $m$ and $n$.\n", "### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n", "Any arithmetic result you may need for this level can be proved using the\n`trivial` tactic.\n", "Proving arithmetic results", "Take inspiration from the structure of the problems in the previous\nthree levels of this world.\n", "The structure of your proof", "$a^{m + n} = a^m \\ast a^n$ for\n$a$ in a group $G$ and natural numbers $m$ and $n$.\n", "end exlean -- hide", "import group.pow_add tactic.modded -- hide\n", "# Groups\n\n## Level 12: Multiplying exponents\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] (a b c : G) (n m : \u2115) -- hide\n", "In this level, you will prove $a^{m n} = (a^m)^n$ for\n$a$ in a group $G$ and natural numbers $n$ and $m$.\n", "### Tasks\n\n* Prove the result below by hand.\n\n* Write a Lean proof of the same result.\n\n", " $a^{m n} = (a^m)^n$ for\n$a$ in a group $G$ and natural numbers $n$ and $m$.\n", "end exlean -- hide", "import  group.pow_mul -- hide\n", "# Groups\n\n## Level 13: Application of powers\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G} {n m : \u2115} -- hide\n", "As an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{26} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nnatural numbers $q$ and $r$ such that $a ^ {26} = a ^r$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be 3 and $r$ to be $5$. We must show both that $a^{26} = a^{7\\times 3 + 5}$\nand that $0 \\le 5 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{26} &= a ^ {7 \\times 3 + 5} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ 3 \\ast a ^ 5 && \\text{[by laws of indices]} \\\\\\\\\n&= 1 ^ 3 \\ast a ^ 5  && \\text{[by $h$]} \\\\\\\\\n& = a ^ 5. && \\text{[by laws of indices and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n", "example (h : a ^ 7 = 1) :\n\u2203 (r : \u2115), a ^ 26 = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use 5,\n  split,\n  { calc a ^ 26\n        = a ^ (7 * 3 + 5)     : by trivial\n    ... = (a ^ 7) ^ 3 * a ^ 5 : by rw [pow_add, pow_mul]\n    ... = (1 ^ 3) * a ^ 5     : by rw h \n    ... = a ^ 5               : by rw [one_pow, one_mul] },\n  { tidy, },\nend\n", "### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n", "If $a ^ 8 = 1$, then there exist natural numbers $q$ and $r$ such that $a ^ {39} = a ^ r$ and\n$0 \\le r < 8$.\n", "end exlean -- hide", "import group.power_lemmas -- hide\n", "# Groups\n\n## Level 14: Negative powers\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G: Type* } [group G] {a b c : G} {n m : \u2124} -- hide\n", "We've seen how to define $a ^ n$ where $a$ is a group element and $n$ is a natural number.\nWe can extend the definition to consider $a ^ m$, where $m$ is an integer.\n\nThere are two possibilities:\n* $m = n$ for a natural number $n$. We then take $a ^ m := a ^ n$.\n* $m = -(n + 1)$ for a natural number $n$. We define $a ^ m = (a ^ {n + 1})^{-1}$.\n\n\n### Laws of indices in Lean\n\nThe laws of indices for integers powers are virtually the same as laws of indices for natural\nnumber powers. Only the names of the results are different.\n\nTaking `n` and `m` to be integers, the laws of indices in Lean are as follows.\n* `one_gpow n : 1 ^ n = 1`\n* `gpow_add a n m : a ^ (n + m) = (a ^ n) * (a ^ m)`\n* `gpow_mul a n m : a ^ (n * m) = (a ^ n) ^ m`\n\nHere they are in action!\n", "(n : \u2124) : 1 ^ n = 1\n", "(a : G) (n m : \u2124) : a ^ (n + m) = a ^ n * a ^ m\n", "(a : G) (n m : \u2124) : a ^ (n * m) = (a ^ n) ^ m\n", "example : (1 : G) ^ n = 1 := one_gpow n\nexample : a ^ (n + m) = a ^ n * a ^ m := gpow_add a n m\nexample : a ^ (n * m) = (a ^ n) ^ m := gpow_mul a n m\n", "As an example, we'll suppose $a^7 = 1$ and find $q$ and $r$ such that $a^{-22} = a^{7q + r}$ and\nsuch that $0 \\le r < 7$.\n\n**Theorem**: Let $a$ be an element of a group $G$. Suppose $h : a ^ 7 = 1$. Then there exist\nintegers $q$ and $r$ such that $a ^ {-20} = a^ {7q + r}$, where $0 \\le r < 7$.\n\n**Proof**: Take $q$ to be $-4$ and $r$ to be $6$. We must show both that $a^{-20} = a^{7\\times (-4) + 6}$\nand that $0 \\le 6 < 7$.\n\nThe first part is proved by calculation.\n$$\n\\begin{align}\na^{-22} &= a ^ {7 \\times (-4) + 6} && \\text{[trivially]} \\\\\\\\\n&= (a ^ 7) ^ (-4) \\ast a ^ 6 && \\text{[by laws of indices]} \\\\\\\\\n& = a ^ 6. && \\text{[by laws of indices, $h$, and the identity axiom]}\n\\end{align}\n$$\nThe second part is easily proved.\n\n\nThe same argument can be written in Lean. The `tidy` tactic here proves `0 \u2264 5 \u2227 5 < 7`.\n", "example (h : a ^ (7 : \u2124) = 1) :\n\u2203 (r : \u2124), a ^ (-22 : \u2124) = a ^ r \u2227 (0 \u2264 r) \u2227 (r < 7) :=\nbegin\n  use 6,\n  split,\n  { calc a ^ (-22 : \u2124) = a ^ ((7 : \u2124) * -4 + 6) : by trivial\n    ... = a ^ ((7 : \u2124) * -4) * a ^ (6 : \u2124) : by rw gpow_add\n    ... = a ^ (6 : \u2124) : by rw [gpow_mul, h, one_gpow, one_mul], },\n  { tidy, },\nend\n", "In the proof above, note that we need to specify, on occassion, that the quantities we are\npresenting to Lean are integers, not natural numbers. We do this with a type annotation. \nFor example, `(-22 : \u2124)` is the integer `-22`. If you just type `-22`, Lean will complain that\nyou can't take negatives of natural numbers!\n", "### Tasks\n\n* Complete the Lean proof below, closely following the proof above.\n\n* Write a proof of the same result by hand.\n\n", "If $a ^ 8 = 1$, then there exists and integer $r$ such that $a ^ {-70} = a ^ r$ and\n$0 \\le r < 8$.\n", "end exlean -- hide", "Homomorphisms", "import hom.basic -- hide\n", "# Group Homomorphisms\n\n## Level 1: The image of the identity element\n", "Let $(G, \\ast)$ and $(H, \\odot)$ be groups.  A *group homomorphism* (or, more simply, a\n*homomorphism*), is a function $p : G \\to H$ that preserves the group structure. That is,\na function for which $p(g_1 \\ast g_2) = p(g_1) \\odot p(g_2)$, for all $g_1$ and $g_2$ in $G$.\n", "**Theorem** Let  $(G, \\ast)$ and $(H, \\odot)$ be groups and let $p : G \\to H$ be a homomorphism.\nThen $p(1) = 1$.\n\nIn this theorem, $1$ on the left-side of the equation denotes the identity in the group $G$ whereas\n$1$ on the right side denotes the identity in the group $H$.\n\nBefore starting the proof, recall the left cancellation result. This states that $b = c$ follows\non the assumption that $a \\ast b = a \\ast c$.\n\n**Proof**\nBy left cancellation, it suffices to prove that $p(1) \\odot p(1) = p(1) \\odot 1$.\n\nBut\n$$\n\\begin{align}\np(1)\\odot p(1)   &= p(1 \\ast 1) && \\text{[by definition of hom]} \\\\\\\\\n&= p(1)                         && \\text{[by multiplicative identity]} \\\\\\\\\n& = p(1) \\odot 1                && \\text{[by multiplicative identity]}\n\\end{align}\n$$\n\u220e\n", "namespace exlean -- hide\n", "open group hom_class -- hide\n", "variables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H]  (p : F) (a b : G) -- hide\n", "### Homomorphisms in Lean\n\nSuppose `G` and `H` are groups in Lean. Suppose that `p` is a group homomorphism. Given\nthat `a` and `b` are elements of `G`, the Lean result `map_mul` asserts that\n`p(a * b) = p(a) * p(b)`.\n\n**WARNING**: To save effort, Lean uses the symbol `*` for the multiplication operator in every\ngroup. Thus, the `*` in the left side of the above equation refers to multiplication in the\ngroup `G` while the symbol `*` in the right side refers to multiplication in the group `H`.\n", "p (a * b) = p(a) * p(b)\n", "include hc -- hide\n", "example : p (a * b) = p(a) * p(b) :=\nbegin\n  rw map_mul,\nend\n", "### Tasks\n\nFollowing the ideas above, prove that $p(1) = 1$ for a group homomorphism\n$p : G \\to H$. As noted above, `map_mul` is the Lean name for the defining\nproperty of group homomorphisms.\n", "Start with\n```\n  apply mul_left_cancel,\n  show p(1) * p(1) = p(1) * 1,\n  calc\n    p(1) * p(1)\n        = sorry    : sorry\n    ... = p(1) * 1 : sorry\n```\n", "A proof template", "The inverse of the inverse of $a$ is $a$.\n", "end exlean -- hide", "import hom.basic -- hide\n", "# Group Homomorphisms\n\n## Level 2: Constructing homomorphisms\n", "### The trivial homomorphism\n\nLet $(G, \\ast)$ and $(H, \\odot)$ be groups.  The function $p : G \\to H$ defined by $p(a) = 1$, for\nevery $a$ in $G$, is a homomorphism, called the _trivial homomorphism_.\n\nIn Lean, a homomorphism is a structure that consists of two items:\n\n* a function, `p` from a group `G` to a group `H` and\n* a proof that for every `a` and `b` in `G`, `p(a * b) = p(a) * p(b)`.\n\nBelow, we give a Lean construction of the trivial homomorphism between two groups `G` and `H`. It ends with\n```\nfrom \u27e8p, h\u27e9,\n```\nHere `p` is a specified function `p : G \u2192 H` and `h` is a proof that\n`\u2200 (a b : G), p(a * b) = p(a) * p(b)`.\n\nThe function `p` is specified in Lean by\n```\nlet p : G \u2192 H := \u03bb a, 1\n```\nThis function maps each `a` in `G` to the identity element `1` in `H`.\n", "namespace exlean -- hide\n", "open group -- hide\n", "variables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] -- hide\n", "def one_map : hom G H :=\nbegin\n  let p : G \u2192 H := \u03bb a, 1,\n  have h : \u2200 (a b : G), p(a * b) = p(a) * p(b),\n  { assume a b : G,\n    show p(a * b) = p(a) * p(b),\n    calc\n      p(a * b)\n          = 1            : by refl\n      ... = 1 * 1        : by rw mul_one\n      ... = p(a) * p(b)  : by refl, },\n  from \u27e8p, h\u27e9,\nend\n", "### Tasks\n\nLet $G$ be a group and let $c$ be a fixed element of $G$. Let $p : G \\to G$ be the function\ndefined so that each $x$ in $G$ maps to $c \\ast x \\ast c^{-1}$.\n\n* Proof, by hand, that $p$ as defined above is a group homormorphism.\n\n* Prove the same result in Lean.\n", "Start with\n```\nlet p : G \u2192 G := \u03bb x, c * x * c\u207b\u00b9,\n\nhave h : \u2200 (a b : G), p(a * b) = p(a) * p(b), {\n  assume (a b : G),\n  show p(a * b) = p(a) * p(b),\n  calc\n    p(a * b)\n        = sorry                           : sorry\n    ... = p(a) * p(b)                     : sorry, },\n\nfrom \u27e8p, h\u27e9,\n```\n", "A proof template", "Many applications of associativity can be combined using\n`simp only [mul_assoc]`, as in the following example.\n\n```\nexample : (a * b) * (c * d) = a * ((b * c) * d) :=\nbegin\n  calc\n  (a * b) * (c * d)\n      = a * ((b * c) * d) : by simp only [mul_assoc],\nend\n```\n", "Simplifying the use of associativity", "For a fixed element $c$ in a group $G$,\nthe map $p : G \\to G$ given by $p(x) = c \\ast x \\ast c^{-1}$ is\na group homomorphism.\n", "end exlean -- hide", "import hom.conjugation -- hide\n", "# Group Homomorphisms\n\n## Level 3: The composite of two homomorphisms\n", "In this level, you will prove that if $p : G \\to H$ and $q : H \\to K$ are \nhomomorphims of groups, then so is the composite $q \\circ p$.\n", "namespace exlean -- hide\n", "open group hom_class -- hide\n", "variables {G : Type*} {H : Type*} {K : Type*} (F : Type*) [group G] [group H] [group K] (a b c : G) -- hide\n", "### Tasks\n\n* By hand, write a proof that the composite of two homomorphism is a homomorphism.\n\n* Prove the same result in Lean. Recall that the `refl` tactic can be used to prove\n`(q \u2218 p)(x) = q(p(x))`. **Recall** that the composition symbol `\u2218` is typed `\\o` or `\\circ` in Lean.\n", "\nStart with\n```\nhave h : \u2200 (a b : G), (q \u2218 p)(a * b) = (q \u2218 p)(a) * (q \u2218 p)(b),\n{ sorry },\n\n  from \u27e8q \u2218 p, h\u27e9,\n```\nRefer to the previous level for ideas regarding the proof of `h`.\n", "A proof template", "The composite of two homomorphims is a homomorphism\n", "end exlean -- hide", "import hom.composite -- hide\n", "# Group Homomorphisms\n\n## Level 4: The inverse of the image of a group element under a homomorphism.\n", "We've seen that if $p : G \\to H$ is a group homomorphism, then\n$p(a \\ast b) = p(a) \\odot p(b)$ and that $p(1) = 1$. In this level, you'll\nshow that $p(g)^{-1} = p(g^{-1})$. So, in every respect, homomorphims preserve the\ngroup structure.\n", "namespace exlean -- hide\n", "open group hom_class -- hide\n", "variables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H] (p : F) -- hide\n", "### Tasks\n\n* By hand, write a proof that $p(g)^{-1} = p(g^{-1})$.\n\n* Prove the same result in Lean.\n", "In this level, you are required to prove a result of the form `a\u207b\u00b9 = b`.\nRecall that using `apply inv_eq_of_mul_eq_one` changes the target of proving `a\u207b\u00b9 = b` to one\nof proving `a * b = 1`.\n", "Starting the proof", "Try this:\n```\napply inv_eq_of_mul_eq_one,\nshow p(g) * p(g\u207b\u00b9) = 1,\ncalc\n  p(g) * p(g\u207b\u00b9)\n      = sorry      : sorry\n  ... = 1          : sorry\n```\n\n", "A proof template", "include hc -- hide\n", "Given a group homomorphism $p : G \\to H$, the inverse of $p(g)$ is $p(g^{-1})$.\n", "end exlean -- hide", "import hom.map_inv -- hide\n", "# Group Homomorphisms\n\n## Level 5: The inverse of the image of a product of elements under a group homomorphism\n", "namespace exlean -- hide\n", "open group hom_class -- hide\n", "variables {G : Type*} {H : Type*} {F : Type*} [group G] [group H]  [hc : hom_class F G H] (p : F) -- hide\n", "### Tasks\n\n* Prove that if $p : G \\to H$ is a group homomorphism, then $p(a \\ast b)^{-1} = p(b^{-1}) \\odot p(a^{-1})$.\n\n* Prove the same result in Lean.\n", "Try this\n```\ncalc\n  (p(a * b))\u207b\u00b9\n      = sorry             : sorry\n  ... = p(b\u207b\u00b9) * p(a\u207b\u00b9)   : sorry\n```\n", "A proof template", "In the groups world, we proved `mul_inv_rev`, that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a \u207b\u00b9`.\n", "A useful result", "include hc -- hide\n", "Given a group homomorphism $p : G \\to H$, we have $p(a \\ast b)^{-1} = p(b^{-1}) \\odot p(a^{-1})$.\n", "end exlean -- hide", "import hom.map_mul_inv -- hide\n", "# Group Homomorphisms\n\n## Level 6: Powers of images of elements under a group homomorphism\n", "namespace exlean -- hide\n", "open group hom_class -- hide\n", "variables {G : Type*} {H : Type*} {F : Type*} [group G] [group H] [hc : hom_class F G H]  -- hide\n", "By induction, you can prove that if $p : G \\to H$ is a homomorphism, if $a$ is an\nelement of $G$ and if $n$ is a natural number (non-negative integer), then $p(a)^n = p(a^n)$.\n", "### Tasks\n\n* Prove that if $p : G \\to H$ is a group homomorphism and if $n$ is a natural number, then\nthen $p(a)^n = p(a^n)$.\n\n* Prove the same result in Lean.\n", "include hc -- hide\n", "Given a group homomorphism $p : G \\to H$, we have $p(a)^n = p(a^n)$, for every natural number $n$.\n", "end exlean -- hide"]]}